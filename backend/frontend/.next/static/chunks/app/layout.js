/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Csrc%5C%5Ccomponents%5C%5Ctma%5C%5Cindex.tsx%22%2C%22ids%22%3A%5B%22TmaSDKProvider%22%5D%7D&server=false!":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Csrc%5C%5Ccomponents%5C%5Ctma%5C%5Cindex.tsx%22%2C%22ids%22%3A%5B%22TmaSDKProvider%22%5D%7D&server=false! ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src\\\\\\\\app\\\\\\\\layout.tsx\\\",\\\"import\\\":\\\"Inter\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"inter\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/globals.css */ \"(app-pages-browser)/./src/app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/tma/index.tsx */ \"(app-pages-browser)/./src/components/tma/index.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDQWRtaW4lNUMlNUNEZXNrdG9wJTVDJTVDbHMlNUMlNUNiYWNrZW5kJTVDJTVDZnJvbnRlbmQlNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZm9udCU1QyU1Q2dvb2dsZSU1QyU1Q3RhcmdldC5jc3MlM0YlN0IlNUMlMjJwYXRoJTVDJTIyJTNBJTVDJTIyc3JjJTVDJTVDJTVDJTVDYXBwJTVDJTVDJTVDJTVDbGF5b3V0LnRzeCU1QyUyMiUyQyU1QyUyMmltcG9ydCU1QyUyMiUzQSU1QyUyMkludGVyJTVDJTIyJTJDJTVDJTIyYXJndW1lbnRzJTVDJTIyJTNBJTVCJTdCJTVDJTIyc3Vic2V0cyU1QyUyMiUzQSU1QiU1QyUyMmxhdGluJTVDJTIyJTVEJTdEJTVEJTJDJTVDJTIydmFyaWFibGVOYW1lJTVDJTIyJTNBJTVDJTIyaW50ZXIlNUMlMjIlN0QlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDQWRtaW4lNUMlNUNEZXNrdG9wJTVDJTVDbHMlNUMlNUNiYWNrZW5kJTVDJTVDZnJvbnRlbmQlNUMlNUNzcmMlNUMlNUNhcHAlNUMlNUNnbG9iYWxzLmNzcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJDJTNBJTVDJTVDVXNlcnMlNUMlNUNBZG1pbiU1QyU1Q0Rlc2t0b3AlNUMlNUNscyU1QyU1Q2JhY2tlbmQlNUMlNUNmcm9udGVuZCU1QyU1Q3NyYyU1QyU1Q2NvbXBvbmVudHMlNUMlNUN0bWElNUMlNUNpbmRleC50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJUbWFTREtQcm92aWRlciUyMiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLGtjQUFxUTtBQUNyUTtBQUNBLG9LQUE0RztBQUM1RztBQUNBLHNMQUEwSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2ZhZTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFxBZG1pblxcXFxEZXNrdG9wXFxcXGxzXFxcXGJhY2tlbmRcXFxcZnJvbnRlbmRcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZm9udFxcXFxnb29nbGVcXFxcdGFyZ2V0LmNzcz97XFxcInBhdGhcXFwiOlxcXCJzcmNcXFxcXFxcXGFwcFxcXFxcXFxcbGF5b3V0LnRzeFxcXCIsXFxcImltcG9ydFxcXCI6XFxcIkludGVyXFxcIixcXFwiYXJndW1lbnRzXFxcIjpbe1xcXCJzdWJzZXRzXFxcIjpbXFxcImxhdGluXFxcIl19XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwiaW50ZXJcXFwifVwiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcQWRtaW5cXFxcRGVza3RvcFxcXFxsc1xcXFxiYWNrZW5kXFxcXGZyb250ZW5kXFxcXHNyY1xcXFxhcHBcXFxcZ2xvYmFscy5jc3NcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcIlRtYVNES1Byb3ZpZGVyXCJdICovIFwiQzpcXFxcVXNlcnNcXFxcQWRtaW5cXFxcRGVza3RvcFxcXFxsc1xcXFxiYWNrZW5kXFxcXGZyb250ZW5kXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXHRtYVxcXFxpbmRleC50c3hcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Csrc%5C%5Ccomponents%5C%5Ctma%5C%5Cindex.tsx%22%2C%22ids%22%3A%5B%22TmaSDKProvider%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={592:(e,r,t)=>{var n=t(722);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},722:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(592);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz8zY2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs1OTI6KGUscix0KT0+e3ZhciBuPXQoNzIyKTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDcyMjplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNTkyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"0ddcd7f95fdd\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvZ2xvYmFscy5jc3M/ZDE0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjBkZGNkN2Y5NWZkZFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/tma/index.tsx":
/*!**************************************!*\
  !*** ./src/components/tma/index.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TmaSDKProvider: function() { return /* binding */ TmaSDKProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _tma_js_sdk_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tma.js/sdk-react */ \"(app-pages-browser)/./node_modules/@tma.js/sdk-react/dist/index.js\");\n/* __next_internal_client_entry_do_not_use__ TmaSDKProvider auto */ \n\nfunction TmaSDKProvider(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tma_js_sdk_react__WEBPACK_IMPORTED_MODULE_1__.SDKProvider, {\n        options: {\n            cssVars: true,\n            acceptCustomStyles: true,\n            async: true\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Admin\\\\Desktop\\\\ls\\\\backend\\\\frontend\\\\src\\\\components\\\\tma\\\\index.tsx\",\n        lineNumber: 8,\n        columnNumber: 5\n    }, this);\n}\n_c = TmaSDKProvider;\nvar _c;\n$RefreshReg$(_c, \"TmaSDKProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3RtYS9pbmRleC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUdnRDtBQUV6QyxTQUFTQyxlQUFlLEtBQStCO1FBQS9CLEVBQUVDLFFBQVEsRUFBcUIsR0FBL0I7SUFDN0IscUJBQ0UsOERBQUNGLDBEQUFXQTtRQUFDRyxTQUFTO1lBQ3BCQyxTQUFTO1lBQ1RDLG9CQUFvQjtZQUNwQkMsT0FBTztRQUNUO2tCQUNHSjs7Ozs7O0FBR1A7S0FWZ0JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3RtYS9pbmRleC50c3g/MDU4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyBQcm9wc1dpdGhDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgU0RLUHJvdmlkZXIgfSBmcm9tICdAdG1hLmpzL3Nkay1yZWFjdCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gVG1hU0RLUHJvdmlkZXIoeyBjaGlsZHJlbiB9OiBQcm9wc1dpdGhDaGlsZHJlbikge1xyXG4gIHJldHVybiAoXHJcbiAgICA8U0RLUHJvdmlkZXIgb3B0aW9ucz17eyBcclxuICAgICAgY3NzVmFyczogdHJ1ZSwgXHJcbiAgICAgIGFjY2VwdEN1c3RvbVN0eWxlczogdHJ1ZSwgXHJcbiAgICAgIGFzeW5jOiB0cnVlIFxyXG4gICAgfX0+XHJcbiAgICAgIHtjaGlsZHJlbn1cclxuICAgIDwvU0RLUHJvdmlkZXI+XHJcbiAgKTtcclxufSJdLCJuYW1lcyI6WyJTREtQcm92aWRlciIsIlRtYVNES1Byb3ZpZGVyIiwiY2hpbGRyZW4iLCJvcHRpb25zIiwiY3NzVmFycyIsImFjY2VwdEN1c3RvbVN0eWxlcyIsImFzeW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/tma/index.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}":
/*!**************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"src\\app\\layout.tsx","import":"Inter","arguments":[{"subsets":["latin"]}],"variableName":"inter"} ***!
  \**************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Inter_f367f3', '__Inter_Fallback_f367f3'\",\"fontStyle\":\"normal\"},\"className\":\"__className_f367f3\"};\n    if(true) {\n      // 1771756742000\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwic3JjXFxcXGFwcFxcXFxsYXlvdXQudHN4XCIsXCJpbXBvcnRcIjpcIkludGVyXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcImludGVyXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsZ0ZBQWdGO0FBQzNHLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdNQUFnSSxjQUFjLHNEQUFzRDtBQUNsTyxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/YWEwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wic3R5bGVcIjp7XCJmb250RmFtaWx5XCI6XCInX19JbnRlcl9mMzY3ZjMnLCAnX19JbnRlcl9GYWxsYmFja19mMzY3ZjMnXCIsXCJmb250U3R5bGVcIjpcIm5vcm1hbFwifSxcImNsYXNzTmFtZVwiOlwiX19jbGFzc05hbWVfZjM2N2YzXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3NzE3NTY3NDIwMDBcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvQWRtaW4vRGVza3RvcC9scy9iYWNrZW5kL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8yMzdhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/ZTU1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tma.js/sdk-react/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tma.js/sdk-react/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackButton: function() { return /* binding */ Ne; },\n/* harmony export */   BasicNavigator: function() { return /* binding */ Is; },\n/* harmony export */   BiometryManager: function() { return /* binding */ ze; },\n/* harmony export */   BrowserNavigator: function() { return /* binding */ ee; },\n/* harmony export */   ClosingBehavior: function() { return /* binding */ Fe; },\n/* harmony export */   CloudStorage: function() { return /* binding */ ts; },\n/* harmony export */   ERR_INVALID_PATH_BASE: function() { return /* binding */ ye; },\n/* harmony export */   ERR_INVOKE_CUSTOM_METHOD_RESPONSE: function() { return /* binding */ we; },\n/* harmony export */   ERR_METHOD_PARAMETER_UNSUPPORTED: function() { return /* binding */ _e; },\n/* harmony export */   ERR_METHOD_UNSUPPORTED: function() { return /* binding */ de; },\n/* harmony export */   ERR_NAVIGATION_HISTORY_EMPTY: function() { return /* binding */ be; },\n/* harmony export */   ERR_NAVIGATION_INDEX_INVALID: function() { return /* binding */ ve; },\n/* harmony export */   ERR_NAVIGATION_ITEM_INVALID: function() { return /* binding */ _n; },\n/* harmony export */   ERR_PARSE: function() { return /* binding */ Ct; },\n/* harmony export */   ERR_SSR_INIT: function() { return /* binding */ gn; },\n/* harmony export */   ERR_TIMED_OUT: function() { return /* binding */ fe; },\n/* harmony export */   ERR_UNEXPECTED_TYPE: function() { return /* binding */ me; },\n/* harmony export */   ERR_UNKNOWN_ENV: function() { return /* binding */ ge; },\n/* harmony export */   EventEmitter: function() { return /* binding */ D; },\n/* harmony export */   HapticFeedback: function() { return /* binding */ ss; },\n/* harmony export */   InitData: function() { return /* binding */ rs; },\n/* harmony export */   Invoice: function() { return /* binding */ os; },\n/* harmony export */   MainButton: function() { return /* binding */ cs; },\n/* harmony export */   MiniApp: function() { return /* binding */ ls; },\n/* harmony export */   Popup: function() { return /* binding */ gs; },\n/* harmony export */   QRScanner: function() { return /* binding */ fs; },\n/* harmony export */   SDKError: function() { return /* binding */ W; },\n/* harmony export */   SDKProvider: function() { return /* binding */ ir; },\n/* harmony export */   SettingsButton: function() { return /* binding */ bs; },\n/* harmony export */   ThemeParams: function() { return /* binding */ ys; },\n/* harmony export */   Utils: function() { return /* binding */ Ps; },\n/* harmony export */   Viewport: function() { return /* binding */ xs; },\n/* harmony export */   array: function() { return /* binding */ Xe; },\n/* harmony export */   bindMiniAppCSSVars: function() { return /* binding */ vn; },\n/* harmony export */   bindThemeParamsCSSVars: function() { return /* binding */ yn; },\n/* harmony export */   bindViewportCSSVars: function() { return /* binding */ En; },\n/* harmony export */   boolean: function() { return /* binding */ E; },\n/* harmony export */   captureSameReq: function() { return /* binding */ qt; },\n/* harmony export */   classNames: function() { return /* binding */ st; },\n/* harmony export */   compareVersions: function() { return /* binding */ Te; },\n/* harmony export */   createBrowserNavigatorFromLocation: function() { return /* binding */ Os; },\n/* harmony export */   createPostEvent: function() { return /* binding */ ke; },\n/* harmony export */   createSafeURL: function() { return /* binding */ M; },\n/* harmony export */   date: function() { return /* binding */ Lt; },\n/* harmony export */   getHash: function() { return /* binding */ Cn; },\n/* harmony export */   getPathname: function() { return /* binding */ te; },\n/* harmony export */   initBackButton: function() { return /* binding */ je; },\n/* harmony export */   initBiometryManager: function() { return /* binding */ Je; },\n/* harmony export */   initClosingBehavior: function() { return /* binding */ Qe; },\n/* harmony export */   initCloudStorage: function() { return /* binding */ es; },\n/* harmony export */   initHapticFeedback: function() { return /* binding */ ns; },\n/* harmony export */   initInitData: function() { return /* binding */ is; },\n/* harmony export */   initInvoice: function() { return /* binding */ as; },\n/* harmony export */   initMainButton: function() { return /* binding */ hs; },\n/* harmony export */   initMiniApp: function() { return /* binding */ ds; },\n/* harmony export */   initNavigator: function() { return /* binding */ Sn; },\n/* harmony export */   initPopup: function() { return /* binding */ ws; },\n/* harmony export */   initQRScanner: function() { return /* binding */ ms; },\n/* harmony export */   initSettingsButton: function() { return /* binding */ vs; },\n/* harmony export */   initThemeParams: function() { return /* binding */ Es; },\n/* harmony export */   initUtils: function() { return /* binding */ Rs; },\n/* harmony export */   initViewport: function() { return /* binding */ Cs; },\n/* harmony export */   initWeb: function() { return /* binding */ Ss; },\n/* harmony export */   invokeCustomMethod: function() { return /* binding */ q; },\n/* harmony export */   isColorDark: function() { return /* binding */ Bt; },\n/* harmony export */   isIframe: function() { return /* binding */ at; },\n/* harmony export */   isPageReload: function() { return /* binding */ Ft; },\n/* harmony export */   isRGB: function() { return /* binding */ ct; },\n/* harmony export */   isRGBShort: function() { return /* binding */ Oe; },\n/* harmony export */   isSDKError: function() { return /* binding */ As; },\n/* harmony export */   isSDKErrorOfType: function() { return /* binding */ xn; },\n/* harmony export */   isSSR: function() { return /* binding */ Ts; },\n/* harmony export */   isTMA: function() { return /* binding */ Pn; },\n/* harmony export */   json: function() { return /* binding */ v; },\n/* harmony export */   mergeClassNames: function() { return /* binding */ fn; },\n/* harmony export */   mockTelegramEnv: function() { return /* binding */ Rn; },\n/* harmony export */   number: function() { return /* binding */ x; },\n/* harmony export */   off: function() { return /* binding */ z; },\n/* harmony export */   on: function() { return /* binding */ y; },\n/* harmony export */   parseInitData: function() { return /* binding */ mn; },\n/* harmony export */   parseLaunchParams: function() { return /* binding */ lt; },\n/* harmony export */   parseThemeParams: function() { return /* binding */ Zt; },\n/* harmony export */   postEvent: function() { return /* binding */ V; },\n/* harmony export */   request: function() { return /* binding */ g; },\n/* harmony export */   requestBiometryInfo: function() { return /* binding */ Ke; },\n/* harmony export */   requestThemeParams: function() { return /* binding */ bn; },\n/* harmony export */   requestViewport: function() { return /* binding */ Xt; },\n/* harmony export */   retrieveLaunchParams: function() { return /* binding */ nt; },\n/* harmony export */   rgb: function() { return /* binding */ Ve; },\n/* harmony export */   searchParams: function() { return /* binding */ ut; },\n/* harmony export */   serializeLaunchParams: function() { return /* binding */ Ue; },\n/* harmony export */   serializeThemeParams: function() { return /* binding */ Kt; },\n/* harmony export */   setCSSVar: function() { return /* binding */ P; },\n/* harmony export */   setDebug: function() { return /* binding */ ue; },\n/* harmony export */   setTargetOrigin: function() { return /* binding */ wn; },\n/* harmony export */   string: function() { return /* binding */ u; },\n/* harmony export */   subscribe: function() { return /* binding */ he; },\n/* harmony export */   supports: function() { return /* binding */ C; },\n/* harmony export */   targetOrigin: function() { return /* binding */ Ie; },\n/* harmony export */   toRGB: function() { return /* binding */ Vt; },\n/* harmony export */   unsubscribe: function() { return /* binding */ xt; },\n/* harmony export */   urlToPath: function() { return /* binding */ U; },\n/* harmony export */   useBackButton: function() { return /* binding */ Vs; },\n/* harmony export */   useBackButtonRaw: function() { return /* binding */ Ds; },\n/* harmony export */   useBiometryManager: function() { return /* binding */ Ms; },\n/* harmony export */   useBiometryManagerRaw: function() { return /* binding */ Bs; },\n/* harmony export */   useClosingBehavior: function() { return /* binding */ $s; },\n/* harmony export */   useClosingBehaviorRaw: function() { return /* binding */ Ls; },\n/* harmony export */   useCloudStorage: function() { return /* binding */ Us; },\n/* harmony export */   useCloudStorageRaw: function() { return /* binding */ Hs; },\n/* harmony export */   useHapticFeedback: function() { return /* binding */ Gs; },\n/* harmony export */   useHapticFeedbackRaw: function() { return /* binding */ Ws; },\n/* harmony export */   useInitData: function() { return /* binding */ zs; },\n/* harmony export */   useInitDataRaw: function() { return /* binding */ js; },\n/* harmony export */   useInvoice: function() { return /* binding */ Js; },\n/* harmony export */   useInvoiceRaw: function() { return /* binding */ Ks; },\n/* harmony export */   useLaunchParams: function() { return /* binding */ tr; },\n/* harmony export */   useMainButton: function() { return /* binding */ Qs; },\n/* harmony export */   useMainButtonRaw: function() { return /* binding */ Fs; },\n/* harmony export */   useMiniApp: function() { return /* binding */ Zs; },\n/* harmony export */   useMiniAppRaw: function() { return /* binding */ Ys; },\n/* harmony export */   usePopup: function() { return /* binding */ tn; },\n/* harmony export */   usePopupRaw: function() { return /* binding */ Xs; },\n/* harmony export */   useQRScanner: function() { return /* binding */ sn; },\n/* harmony export */   useQRScannerRaw: function() { return /* binding */ en; },\n/* harmony export */   useSDK: function() { return /* binding */ Ns; },\n/* harmony export */   useSettingsButton: function() { return /* binding */ rn; },\n/* harmony export */   useSettingsButtonRaw: function() { return /* binding */ nn; },\n/* harmony export */   useThemeParams: function() { return /* binding */ an; },\n/* harmony export */   useThemeParamsRaw: function() { return /* binding */ on; },\n/* harmony export */   useUtils: function() { return /* binding */ hn; },\n/* harmony export */   useUtilsRaw: function() { return /* binding */ cn; },\n/* harmony export */   useViewport: function() { return /* binding */ un; },\n/* harmony export */   useViewportRaw: function() { return /* binding */ pn; },\n/* harmony export */   withBackButton: function() { return /* binding */ An; },\n/* harmony export */   withBackButtonRaw: function() { return /* binding */ Tn; },\n/* harmony export */   withBiometryManager: function() { return /* binding */ kn; },\n/* harmony export */   withBiometryManagerRaw: function() { return /* binding */ In; },\n/* harmony export */   withClosingBehavior: function() { return /* binding */ qn; },\n/* harmony export */   withClosingBehaviorRaw: function() { return /* binding */ On; },\n/* harmony export */   withCloudStorage: function() { return /* binding */ Dn; },\n/* harmony export */   withCloudStorageRaw: function() { return /* binding */ Nn; },\n/* harmony export */   withHapticFeedback: function() { return /* binding */ Bn; },\n/* harmony export */   withHapticFeedbackRaw: function() { return /* binding */ Vn; },\n/* harmony export */   withInitData: function() { return /* binding */ Ln; },\n/* harmony export */   withInitDataRaw: function() { return /* binding */ Mn; },\n/* harmony export */   withInvoice: function() { return /* binding */ Hn; },\n/* harmony export */   withInvoiceRaw: function() { return /* binding */ $n; },\n/* harmony export */   withMainButton: function() { return /* binding */ Wn; },\n/* harmony export */   withMainButtonRaw: function() { return /* binding */ Un; },\n/* harmony export */   withMiniApp: function() { return /* binding */ jn; },\n/* harmony export */   withMiniAppRaw: function() { return /* binding */ Gn; },\n/* harmony export */   withPopup: function() { return /* binding */ Kn; },\n/* harmony export */   withPopupRaw: function() { return /* binding */ zn; },\n/* harmony export */   withQRScanner: function() { return /* binding */ Fn; },\n/* harmony export */   withQRScannerRaw: function() { return /* binding */ Jn; },\n/* harmony export */   withSettingsButton: function() { return /* binding */ Yn; },\n/* harmony export */   withSettingsButtonRaw: function() { return /* binding */ Qn; },\n/* harmony export */   withThemeParams: function() { return /* binding */ Xn; },\n/* harmony export */   withThemeParamsRaw: function() { return /* binding */ Zn; },\n/* harmony export */   withTimeout: function() { return /* binding */ Dt; },\n/* harmony export */   withUtils: function() { return /* binding */ sr; },\n/* harmony export */   withUtilsRaw: function() { return /* binding */ er; },\n/* harmony export */   withViewport: function() { return /* binding */ rr; },\n/* harmony export */   withViewportRaw: function() { return /* binding */ nr; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\nvar ae = Object.defineProperty, ce = (e, t, s) => t in e ? ae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, c = (e, t, s) => ce(e, typeof t != \"symbol\" ? t + \"\" : t, s);\nfunction Rt(e, t) {\n  let s;\n  const n = () => {\n    s !== void 0 && t && t(s), s = void 0;\n  };\n  return [() => s === void 0 ? s = e(n) : s, n];\n}\nfunction xt(e) {\n  const t = j(), { count: s } = t;\n  t.unsubscribe(e), s && !t.count && Se();\n}\nfunction he(e) {\n  return j().subscribe(e), () => xt(e);\n}\nclass pe {\n  constructor(t, s = {}) {\n    this.scope = t, this.options = s;\n  }\n  /**\n   * Prints message into a console in case, logger is currently enabled.\n   * @param level - log level.\n   * @param args - arguments.\n   */\n  print(t, ...s) {\n    const n = /* @__PURE__ */ new Date(), r = Intl.DateTimeFormat(\"en-GB\", {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      fractionalSecondDigits: 3,\n      timeZone: \"UTC\"\n    }).format(n), { textColor: i, bgColor: o } = this.options, a = \"font-weight: bold;padding: 0 5px;border-radius:5px\";\n    console[t](\n      `%c${r}%c / %c${this.scope}`,\n      `${a};background-color: lightblue;color:black`,\n      \"\",\n      `${a};${i ? `color:${i};` : \"\"}${o ? `background-color:${o}` : \"\"}`,\n      ...s\n    );\n  }\n  /**\n   * Prints error message into a console.\n   * @param args\n   */\n  error(...t) {\n    this.print(\"error\", ...t);\n  }\n  /**\n   * Prints log message into a console.\n   * @param args\n   */\n  log(...t) {\n    this.print(\"log\", ...t);\n  }\n}\nconst it = new pe(\"SDK\", {\n  bgColor: \"forestgreen\",\n  textColor: \"white\"\n});\nlet X = !1;\nconst bt = ({ name: e, payload: t }) => {\n  it.log(\"Event received:\", t ? { name: e, payload: t } : { name: e });\n};\nfunction ue(e) {\n  X !== e && (X = e, e ? he(bt) : xt(bt));\n}\nfunction le(...e) {\n  X && it.log(...e);\n}\nclass D {\n  constructor() {\n    c(this, \"listeners\", /* @__PURE__ */ new Map()), c(this, \"listenersCount\", 0), c(this, \"subscribeListeners\", []);\n  }\n  /**\n   * Removes all event listeners.\n   */\n  clear() {\n    this.listeners.clear(), this.subscribeListeners = [];\n  }\n  /**\n   * Returns count of bound listeners.\n   */\n  get count() {\n    return this.listenersCount + this.subscribeListeners.length;\n  }\n  emit(t, ...s) {\n    this.subscribeListeners.forEach((n) => n({\n      event: t,\n      args: s\n    })), (this.listeners.get(t) || []).forEach(([n, r]) => {\n      n(...s), r && this.off(t, n);\n    });\n  }\n  /**\n   * Adds new event listener.\n   * @param event - event name.\n   * @param listener - event listener.\n   * @param once - should listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  on(t, s, n) {\n    let r = this.listeners.get(t);\n    return r || this.listeners.set(t, r = []), r.push([s, n]), this.listenersCount += 1, () => this.off(t, s);\n  }\n  /**\n   * Removes event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param event - event name.\n   * @param listener - event listener.\n   */\n  off(t, s) {\n    const n = this.listeners.get(t) || [];\n    for (let r = 0; r < n.length; r += 1)\n      if (s === n[r][0]) {\n        n.splice(r, 1), this.listenersCount -= 1;\n        return;\n      }\n  }\n  /**\n   * Adds a new event listener for all events.\n   * @param listener - event listener.\n   * @returns Function to remove event listener.\n   */\n  subscribe(t) {\n    return this.subscribeListeners.push(t), () => this.unsubscribe(t);\n  }\n  /**\n   * Removes global event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param listener - event listener.\n   */\n  unsubscribe(t) {\n    for (let s = 0; s < this.subscribeListeners.length; s += 1)\n      if (this.subscribeListeners[s] === t) {\n        this.subscribeListeners.splice(s, 1);\n        return;\n      }\n  }\n}\nfunction tt(e, t, s) {\n  return window.addEventListener(e, t, s), () => window.removeEventListener(e, t, s);\n}\nfunction ot(...e) {\n  let t = !1;\n  const s = e.flat(1);\n  return [\n    (n) => !t && s.push(n),\n    () => {\n      t || (t = !0, s.forEach((n) => n()));\n    },\n    t\n  ];\n}\nclass W extends Error {\n  constructor(t, s, n) {\n    super(s, { cause: n }), this.type = t, Object.setPrototypeOf(this, W.prototype);\n  }\n}\nfunction m(e, t, s) {\n  return new W(e, t, s);\n}\nconst de = \"ERR_METHOD_UNSUPPORTED\", _e = \"ERR_METHOD_PARAMETER_UNSUPPORTED\", ge = \"ERR_UNKNOWN_ENV\", we = \"ERR_INVOKE_CUSTOM_METHOD_RESPONSE\", fe = \"ERR_TIMED_OUT\", me = \"ERR_UNEXPECTED_TYPE\", Ct = \"ERR_PARSE\", be = \"ERR_NAVIGATION_LIST_EMPTY\", ve = \"ERR_NAVIGATION_CURSOR_INVALID\", _n = \"ERR_NAVIGATION_ITEM_INVALID\", gn = \"ERR_SSR_INIT\", ye = \"ERR_INVALID_PATH_BASE\";\nfunction T() {\n  return m(me, \"Value has unexpected type\");\n}\nclass G {\n  constructor(t, s, n) {\n    this.parser = t, this.isOptional = s, this.type = n;\n  }\n  /**\n   * Attempts to parse passed value\n   * @param value - value to parse.\n   * @throws {SDKError} ERR_PARSE\n   * @see ERR_PARSE\n   */\n  parse(t) {\n    if (!(this.isOptional && t === void 0))\n      try {\n        return this.parser(t);\n      } catch (s) {\n        throw m(\n          Ct,\n          `Unable to parse value${this.type ? ` as ${this.type}` : \"\"}`,\n          s\n        );\n      }\n  }\n  optional() {\n    return this.isOptional = !0, this;\n  }\n}\nfunction A(e, t) {\n  return () => new G(e, !1, t);\n}\nconst E = A((e) => {\n  if (typeof e == \"boolean\")\n    return e;\n  const t = String(e);\n  if (t === \"1\" || t === \"true\")\n    return !0;\n  if (t === \"0\" || t === \"false\")\n    return !1;\n  throw T();\n}, \"boolean\");\nfunction St(e, t) {\n  const s = {};\n  for (const n in e) {\n    const r = e[n];\n    if (!r)\n      continue;\n    let i, o;\n    if (typeof r == \"function\" || \"parse\" in r)\n      i = n, o = typeof r == \"function\" ? r : r.parse.bind(r);\n    else {\n      const { type: a } = r;\n      i = r.from || n, o = typeof a == \"function\" ? a : a.parse.bind(a);\n    }\n    try {\n      const a = o(t(i));\n      a !== void 0 && (s[n] = a);\n    } catch (a) {\n      throw m(Ct, `Unable to parse field \"${n}\"`, a);\n    }\n  }\n  return s;\n}\nfunction Tt(e) {\n  let t = e;\n  if (typeof t == \"string\" && (t = JSON.parse(t)), typeof t != \"object\" || t === null || Array.isArray(t))\n    throw T();\n  return t;\n}\nfunction v(e, t) {\n  return new G((s) => {\n    const n = Tt(s);\n    return St(e, (r) => n[r]);\n  }, !1, t);\n}\nconst x = A((e) => {\n  if (typeof e == \"number\")\n    return e;\n  if (typeof e == \"string\") {\n    const t = Number(e);\n    if (!Number.isNaN(t))\n      return t;\n  }\n  throw T();\n}, \"number\"), u = A((e) => {\n  if (typeof e == \"string\" || typeof e == \"number\")\n    return e.toString();\n  throw T();\n}, \"string\");\nfunction At(e) {\n  return v({\n    eventType: u(),\n    eventData: (t) => t\n  }).parse(e);\n}\nfunction Ee() {\n  [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((e) => {\n    delete window[e];\n  });\n}\nfunction et(e, t) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: e, eventData: t }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nfunction Pe() {\n  [\n    [\"TelegramGameProxy_receiveEvent\"],\n    // Windows Phone.\n    [\"TelegramGameProxy\", \"receiveEvent\"],\n    // Desktop.\n    [\"Telegram\", \"WebView\", \"receiveEvent\"]\n    // Android and iOS.\n  ].forEach((e) => {\n    let t = window;\n    e.forEach((s, n, r) => {\n      if (n === r.length - 1) {\n        t[s] = et;\n        return;\n      }\n      s in t || (t[s] = {}), t = t[s];\n    });\n  });\n}\nconst Re = {\n  clipboard_text_received: v({\n    req_id: u(),\n    data: (e) => e === null ? e : u().optional().parse(e)\n  }),\n  custom_method_invoked: v({\n    req_id: u(),\n    result: (e) => e,\n    error: u().optional()\n  }),\n  popup_closed: {\n    parse(e) {\n      return v({\n        button_id: (t) => t == null ? void 0 : u().parse(t)\n      }).parse(e ?? {});\n    }\n  },\n  viewport_changed: v({\n    height: x(),\n    width: (e) => e == null ? window.innerWidth : x().parse(e),\n    is_state_stable: E(),\n    is_expanded: E()\n  })\n};\nfunction xe() {\n  const e = new D(), t = new D();\n  t.subscribe((n) => {\n    e.emit(\"event\", { name: n.event, payload: n.args[0] });\n  }), Pe();\n  const [, s] = ot(\n    // Don't forget to remove created handlers.\n    Ee,\n    // Add \"resize\" event listener to make sure, we always have fresh viewport information.\n    // Desktop version of Telegram is sometimes not sending the viewport_changed\n    // event. For example, when the MainButton is shown. That's why we should\n    // add our own listener to make sure, viewport information is always fresh.\n    // Issue: https://github.com/Telegram-Mini-Apps/tma.js/issues/10\n    tt(\"resize\", () => {\n      t.emit(\"viewport_changed\", {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        is_state_stable: !0,\n        is_expanded: !0\n      });\n    }),\n    // Add listener, which handles events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    tt(\"message\", (n) => {\n      if (n.source !== window.parent)\n        return;\n      let r;\n      try {\n        r = At(n.data);\n      } catch {\n        return;\n      }\n      const { eventType: i, eventData: o } = r, a = Re[i];\n      try {\n        const h = a ? a.parse(o) : o;\n        t.emit(...h ? [i, h] : [i]);\n      } catch (h) {\n        it.error(\n          `An error occurred processing the \"${i}\" event from the Telegram application.\nPlease, file an issue here:\nhttps://github.com/Telegram-Mini-Apps/tma.js/issues/new/choose`,\n          r,\n          h\n        );\n      }\n    }),\n    // Clear emitters.\n    () => e.clear(),\n    () => t.clear()\n  );\n  return [{\n    on: t.on.bind(t),\n    off: t.off.bind(t),\n    subscribe(n) {\n      return e.on(\"event\", n);\n    },\n    unsubscribe(n) {\n      e.off(\"event\", n);\n    },\n    get count() {\n      return t.count + e.count;\n    }\n  }, s];\n}\nconst [Ce, Se] = Rt(\n  (e) => {\n    const [t, s] = xe(), n = t.off.bind(t);\n    return t.off = (r, i) => {\n      const { count: o } = t;\n      n(r, i), o && !t.count && e();\n    }, [t, s];\n  },\n  ([, e]) => e()\n);\nfunction j() {\n  return Ce()[0];\n}\nfunction z(e, t) {\n  j().off(e, t);\n}\nfunction y(e, t, s) {\n  return j().on(e, t, s);\n}\nfunction L(e) {\n  return typeof e == \"object\" && e !== null && !Array.isArray(e);\n}\nfunction Te(e, t) {\n  const s = e.split(\".\"), n = t.split(\".\"), r = Math.max(s.length, n.length);\n  for (let i = 0; i < r; i += 1) {\n    const o = parseInt(s[i] || \"0\", 10), a = parseInt(n[i] || \"0\", 10);\n    if (o !== a)\n      return o > a ? 1 : -1;\n  }\n  return 0;\n}\nfunction f(e, t) {\n  return Te(e, t) <= 0;\n}\nfunction C(e, t, s) {\n  if (typeof s == \"string\") {\n    if (e === \"web_app_open_link\") {\n      if (t === \"try_instant_view\")\n        return f(\"6.4\", s);\n      if (t === \"try_browser\")\n        return f(\"7.6\", s);\n    }\n    if (e === \"web_app_set_header_color\" && t === \"color\")\n      return f(\"6.9\", s);\n    if (e === \"web_app_close\" && t === \"return_back\")\n      return f(\"7.6\", s);\n  }\n  switch (e) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return f(\"6.1\", t);\n    case \"web_app_open_popup\":\n      return f(\"6.2\", t);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return f(\"6.4\", t);\n    case \"web_app_switch_inline_query\":\n      return f(\"6.7\", t);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return f(\"6.9\", t);\n    case \"web_app_setup_settings_button\":\n      return f(\"6.10\", t);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return f(\"7.2\", t);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(e);\n  }\n}\nfunction It(e) {\n  return \"external\" in e && L(e.external) && \"notify\" in e.external && typeof e.external.notify == \"function\";\n}\nfunction kt(e) {\n  return \"TelegramWebviewProxy\" in e && L(e.TelegramWebviewProxy) && \"postEvent\" in e.TelegramWebviewProxy && typeof e.TelegramWebviewProxy.postEvent == \"function\";\n}\nfunction at() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nconst Ae = \"https://web.telegram.org\";\nlet Ot = Ae;\nfunction wn(e) {\n  Ot = e;\n}\nfunction Ie() {\n  return Ot;\n}\nfunction V(e, t, s) {\n  let n = {}, r;\n  if (!t && !s ? n = {} : t && s ? (n = s, r = t) : t && (\"targetOrigin\" in t ? n = t : r = t), le(\"Posting event:\", r ? { event: e, data: r } : { event: e }), at())\n    return window.parent.postMessage(\n      JSON.stringify({ eventType: e, eventData: r }),\n      n.targetOrigin || Ie()\n    );\n  if (It(window)) {\n    window.external.notify(JSON.stringify({ eventType: e, eventData: r }));\n    return;\n  }\n  if (kt(window)) {\n    window.TelegramWebviewProxy.postEvent(e, JSON.stringify(r));\n    return;\n  }\n  throw m(\n    ge,\n    \"Unable to determine current environment and possible way to send event. You are probably trying to use Mini Apps method outside the Telegram application environment.\"\n  );\n}\nfunction ke(e) {\n  return (t, s) => {\n    if (!C(t, e))\n      throw m(de, `Method \"${t}\" is unsupported in Mini Apps version ${e}`);\n    if (L(s) && t === \"web_app_set_header_color\" && \"color\" in s && !C(t, \"color\", e))\n      throw m(\n        _e,\n        `Parameter \"color\" of \"${t}\" method is unsupported in Mini Apps version ${e}`\n      );\n    return V(t, s);\n  };\n}\nfunction qt(e) {\n  return ({ req_id: t }) => t === e;\n}\nfunction Nt(e) {\n  return m(fe, `Timeout reached: ${e}ms`);\n}\nfunction Dt(e, t) {\n  return Promise.race([\n    typeof e == \"function\" ? e() : e,\n    new Promise((s, n) => {\n      setTimeout(() => {\n        n(Nt(t));\n      }, t);\n    })\n  ]);\n}\nasync function g(e) {\n  let t;\n  const s = new Promise((a) => t = a), { event: n, capture: r, timeout: i } = e, [, o] = ot(\n    // We need to iterate over all tracked events, and create their event listeners.\n    (Array.isArray(n) ? n : [n]).map((a) => y(a, (h) => {\n      (!r || (Array.isArray(n) ? r({\n        event: a,\n        payload: h\n      }) : r(h))) && t(h);\n    }))\n  );\n  try {\n    return (e.postEvent || V)(e.method, e.params), await (i ? Dt(s, i) : s);\n  } finally {\n    o();\n  }\n}\nasync function q(e, t, s, n = {}) {\n  const {\n    result: r,\n    error: i\n  } = await g({\n    ...n,\n    method: \"web_app_invoke_custom_method\",\n    event: \"custom_method_invoked\",\n    params: {\n      method: e,\n      params: t,\n      req_id: s\n    },\n    capture: qt(s)\n  });\n  if (i)\n    throw m(we, i);\n  return r;\n}\nfunction st(...e) {\n  return e.map((t) => {\n    if (typeof t == \"string\")\n      return t;\n    if (L(t))\n      return st(Object.entries(t).map((s) => s[1] && s[0]));\n    if (Array.isArray(t))\n      return st(...t);\n  }).filter(Boolean).join(\" \");\n}\nfunction fn(...e) {\n  return e.reduce((t, s) => (L(s) && Object.entries(s).forEach(([n, r]) => {\n    const i = st(t[n], r);\n    i.length && (t[n] = i);\n  }), t), {});\n}\nfunction ct(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction Oe(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction Vt(e) {\n  const t = e.replace(/\\s/g, \"\").toLowerCase();\n  if (ct(t))\n    return t;\n  if (Oe(t)) {\n    let n = \"#\";\n    for (let r = 0; r < 3; r += 1)\n      n += t[1 + r].repeat(2);\n    return n;\n  }\n  const s = t.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || t.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!s)\n    throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return s.slice(1).reduce((n, r) => {\n    const i = parseInt(r, 10).toString(16);\n    return n + (i.length === 1 ? \"0\" : \"\") + i;\n  }, \"#\");\n}\nfunction Bt(e) {\n  const t = Vt(e);\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce((s, n, r) => {\n      const i = parseInt(t.slice(1 + r * 2, 1 + (r + 1) * 2), 16);\n      return s + i * i * n;\n    }, 0)\n  ) < 120;\n}\nclass qe {\n  constructor(t) {\n    c(this, \"ee\", new D()), c(this, \"on\", this.ee.on.bind(this.ee)), c(this, \"off\", this.ee.off.bind(this.ee)), this.state = t;\n  }\n  /**\n   * Clones current state and returns its copy.\n   */\n  clone() {\n    return { ...this.state };\n  }\n  set(t, s) {\n    Object.entries(typeof t == \"string\" ? { [t]: s } : t).reduce((n, [r, i]) => this.state[r] === i || i === void 0 ? n : (this.state[r] = i, this.ee.emit(`change:${r}`, i), !0), !1) && this.ee.emit(\"change\", this.state);\n  }\n  /**\n   * Returns value by specified key.\n   * @param key - state key.\n   */\n  get(t) {\n    return this.state[t];\n  }\n}\nclass ht {\n  constructor(t) {\n    c(this, \"state\"), c(this, \"get\"), c(this, \"set\"), c(this, \"clone\"), this.state = new qe(t), this.set = this.state.set.bind(this.state), this.get = this.state.get.bind(this.state), this.clone = this.state.clone.bind(this.state);\n  }\n}\nfunction Mt(e, t) {\n  return (s) => C(t[s], e);\n}\nclass pt extends ht {\n  constructor(t, s, n) {\n    super(t), c(this, \"supports\"), this.supports = Mt(s, n);\n  }\n}\nclass Ne extends pt {\n  constructor(t, s, n) {\n    super({ isVisible: t }, s, {\n      show: \"web_app_setup_back_button\",\n      hide: \"web_app_setup_back_button\"\n    }), c(this, \"on\", (r, i) => r === \"click\" ? y(\"back_button_pressed\", i) : this.state.on(r, i)), c(this, \"off\", (r, i) => r === \"click\" ? z(\"back_button_pressed\", i) : this.state.off(r, i)), this.postEvent = n;\n  }\n  set isVisible(t) {\n    this.set(\"isVisible\", t), this.postEvent(\"web_app_setup_back_button\", { is_visible: t });\n  }\n  /**\n   * True if BackButton is currently visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Hides the BackButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the BackButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nconst Lt = A((e) => e instanceof Date ? e : new Date(x().parse(e) * 1e3), \"Date\");\nfunction ut(e, t) {\n  return new G((s) => {\n    if (typeof s != \"string\" && !(s instanceof URLSearchParams))\n      throw T();\n    const n = typeof s == \"string\" ? new URLSearchParams(s) : s;\n    return St(e, (r) => {\n      const i = n.get(r);\n      return i === null ? void 0 : i;\n    });\n  }, !1, t);\n}\nconst De = v({\n  id: x(),\n  type: u(),\n  title: u(),\n  photoUrl: {\n    type: u().optional(),\n    from: \"photo_url\"\n  },\n  username: u().optional()\n}, \"Chat\").optional(), vt = v({\n  addedToAttachmentMenu: {\n    type: E().optional(),\n    from: \"added_to_attachment_menu\"\n  },\n  allowsWriteToPm: {\n    type: E().optional(),\n    from: \"allows_write_to_pm\"\n  },\n  firstName: {\n    type: u(),\n    from: \"first_name\"\n  },\n  id: x(),\n  isBot: {\n    type: E().optional(),\n    from: \"is_bot\"\n  },\n  isPremium: {\n    type: E().optional(),\n    from: \"is_premium\"\n  },\n  languageCode: {\n    type: u().optional(),\n    from: \"language_code\"\n  },\n  lastName: {\n    type: u().optional(),\n    from: \"last_name\"\n  },\n  photoUrl: {\n    type: u().optional(),\n    from: \"photo_url\"\n  },\n  username: u().optional()\n}, \"User\").optional();\nfunction $t() {\n  return ut({\n    authDate: {\n      type: Lt(),\n      from: \"auth_date\"\n    },\n    canSendAfter: {\n      type: x().optional(),\n      from: \"can_send_after\"\n    },\n    chat: De,\n    chatInstance: {\n      type: u().optional(),\n      from: \"chat_instance\"\n    },\n    chatType: {\n      type: u().optional(),\n      from: \"chat_type\"\n    },\n    hash: u(),\n    queryId: {\n      type: u().optional(),\n      from: \"query_id\"\n    },\n    receiver: vt,\n    startParam: {\n      type: u().optional(),\n      from: \"start_param\"\n    },\n    user: vt\n  }, \"InitData\");\n}\nconst Ve = A((e) => Vt(u().parse(e)), \"rgb\");\nfunction Be(e) {\n  return e.replace(/_[a-z]/g, (t) => t[1].toUpperCase());\n}\nfunction Me(e) {\n  return e.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`);\n}\nconst Ht = A(\n  (e) => {\n    const t = Ve().optional();\n    return Object.entries(Tt(e)).reduce((s, [n, r]) => (s[Be(n)] = t.parse(r), s), {});\n  },\n  \"ThemeParams\"\n);\nfunction lt(e) {\n  return ut({\n    botInline: {\n      type: E().optional(),\n      from: \"tgWebAppBotInline\"\n    },\n    initData: {\n      type: $t().optional(),\n      from: \"tgWebAppData\"\n    },\n    initDataRaw: {\n      type: u().optional(),\n      from: \"tgWebAppData\"\n    },\n    platform: {\n      type: u(),\n      from: \"tgWebAppPlatform\"\n    },\n    showSettings: {\n      type: E().optional(),\n      from: \"tgWebAppShowSettings\"\n    },\n    startParam: {\n      type: u().optional(),\n      from: \"tgWebAppStartParam\"\n    },\n    themeParams: {\n      type: Ht(),\n      from: \"tgWebAppThemeParams\"\n    },\n    version: {\n      type: u(),\n      from: \"tgWebAppVersion\"\n    }\n  }).parse(e);\n}\nfunction Ut(e) {\n  return lt(\n    e.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\")\n  );\n}\nfunction Le() {\n  return Ut(window.location.href);\n}\nfunction Wt() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction $e() {\n  const e = Wt();\n  if (!e)\n    throw new Error(\"Unable to get first navigation entry.\");\n  return Ut(e.name);\n}\nfunction Gt(e) {\n  return `tma.js/${e.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`)}`;\n}\nfunction jt(e, t) {\n  sessionStorage.setItem(Gt(e), JSON.stringify(t));\n}\nfunction zt(e) {\n  const t = sessionStorage.getItem(Gt(e));\n  try {\n    return t ? JSON.parse(t) : void 0;\n  } catch {\n  }\n}\nfunction He() {\n  return lt(zt(\"launchParams\") || \"\");\n}\nfunction Kt(e) {\n  return JSON.stringify(\n    Object.fromEntries(\n      Object.entries(e).map(([t, s]) => [Me(t), s])\n    )\n  );\n}\nfunction Ue(e) {\n  const {\n    initDataRaw: t,\n    themeParams: s,\n    platform: n,\n    version: r,\n    showSettings: i,\n    startParam: o,\n    botInline: a\n  } = e, h = new URLSearchParams();\n  return h.set(\"tgWebAppPlatform\", n), h.set(\"tgWebAppThemeParams\", Kt(s)), h.set(\"tgWebAppVersion\", r), t && h.set(\"tgWebAppData\", t), o && h.set(\"tgWebAppStartParam\", o), typeof i == \"boolean\" && h.set(\"tgWebAppShowSettings\", i ? \"1\" : \"0\"), typeof a == \"boolean\" && h.set(\"tgWebAppBotInline\", a ? \"1\" : \"0\"), h.toString();\n}\nfunction Jt(e) {\n  jt(\"launchParams\", Ue(e));\n}\nfunction nt() {\n  for (const e of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed and then page was reloaded.\n    Le,\n    // Then, try using the lower level API - window.performance.\n    $e,\n    // Finally, try to extract launch parameters from the session storage.\n    He\n  ])\n    try {\n      const t = e();\n      return Jt(t), t;\n    } catch {\n    }\n  throw new Error(\"Unable to retrieve launch parameters from any known source.\");\n}\nfunction Ft() {\n  const e = Wt();\n  return !!(e && e.type === \"reload\");\n}\nfunction We() {\n  let e = 0;\n  return () => (e += 1).toString();\n}\nconst [Ge] = Rt(We);\nfunction l(e, t) {\n  return () => {\n    const s = nt(), n = {\n      ...s,\n      postEvent: ke(s.version),\n      createRequestId: Ge()\n    };\n    if (typeof e == \"function\")\n      return e(n);\n    const [r, i, o] = ot(), a = t({\n      ...n,\n      // State should only be passed only in case, current page was reloaded. If we don't add\n      // this check, state restoration will work improperly in the web version of Telegram,\n      // when we are always working in the same \"session\" (tab).\n      state: Ft() ? zt(e) : void 0,\n      addCleanup: r\n    }), h = (p) => (o || r(\n      p.on(\"change\", (S) => {\n        jt(e, S);\n      })\n    ), p);\n    return [\n      a instanceof Promise ? a.then(h) : h(a),\n      i\n    ];\n  };\n}\nconst je = l(\"backButton\", ({\n  postEvent: e,\n  version: t,\n  state: s = { isVisible: !1 }\n}) => new Ne(s.isVisible, t, e));\nclass $ extends pt {\n  constructor() {\n    super(...arguments), c(this, \"on\", this.state.on.bind(this.state)), c(this, \"off\", this.state.off.bind(this.state));\n  }\n}\nfunction Qt(e) {\n  const t = e.available ? e : {\n    available: !1,\n    device_id: \"\",\n    token_saved: !1,\n    access_requested: !1,\n    access_granted: !1,\n    type: \"\"\n  };\n  return {\n    available: !0,\n    type: t.type,\n    deviceId: t.device_id,\n    tokenSaved: t.token_saved,\n    accessRequested: t.access_requested,\n    accessGranted: t.access_granted\n  };\n}\nclass ze extends $ {\n  constructor({ postEvent: t, version: s, ...n }) {\n    super(n, s, {\n      auth: \"web_app_biometry_request_auth\",\n      openSettings: \"web_app_biometry_open_settings\",\n      requestAccess: \"web_app_biometry_request_access\",\n      updateToken: \"web_app_biometry_update_token\"\n    }), c(this, \"postEvent\"), c(this, \"authPromise\"), c(this, \"accessPromise\"), this.postEvent = t;\n  }\n  /**\n   * Shows whether biometry is available.\n   */\n  get available() {\n    return this.get(\"available\");\n  }\n  /**\n   * Shows whether permission to use biometrics has been granted.\n   */\n  get accessGranted() {\n    return this.get(\"accessGranted\");\n  }\n  /**\n   * Shows whether if permission to use biometrics has been requested.\n   */\n  get accessRequested() {\n    return this.get(\"accessRequested\");\n  }\n  /**\n   * Authenticates the user using biometrics.\n   * @param options - method options.\n   * @since 7.2\n   * @returns Token from the local secure storage, if authentication was successful.\n   */\n  async authenticate({\n    reason: t,\n    ...s\n  }) {\n    return this.authPromise || (this.authPromise = g({\n      ...s,\n      method: \"web_app_biometry_request_auth\",\n      event: \"biometry_auth_requested\",\n      postEvent: this.postEvent,\n      params: {\n        // TODO: Check if reason is empty works fine.\n        reason: (t || \"\").trim()\n      }\n    }).then(({ token: n }) => n).finally(() => this.authPromise = void 0)), this.authPromise;\n  }\n  /**\n   * A unique device identifier that can be used to match the token to the device.\n   */\n  get deviceId() {\n    return this.get(\"deviceId\");\n  }\n  /**\n   * Opens the biometric access settings for bots. Useful when you need to request biometrics\n   * access to users who haven't granted it yet.\n   *\n   * _Note that this method can be called only in response to user interaction with the Mini App\n   * interface (e.g. a click inside the Mini App or on the main button)_.\n   * @since 7.2\n   */\n  openSettings() {\n    this.postEvent(\"web_app_biometry_open_settings\");\n  }\n  /**\n   * Requests permission to use biometrics.\n   * @since 7.2\n   * @returns Promise with true, if access was granted.\n   */\n  requestAccess({ reason: t, ...s } = {}) {\n    return this.accessPromise || (this.accessPromise = g({\n      ...s,\n      postEvent: this.postEvent,\n      method: \"web_app_biometry_request_access\",\n      event: \"biometry_info_received\",\n      params: { reason: t || \"\" }\n    }).then((n) => {\n      const r = Qt(n);\n      return this.set(r), r.accessGranted;\n    }).finally(() => this.accessPromise = void 0)), this.accessPromise;\n  }\n  /**\n   * The type of biometrics currently available on the device.\n   */\n  get biometryType() {\n    return this.get(\"biometryType\");\n  }\n  /**\n   * Shows whether token was saved previously in the local secure storage.\n   */\n  get tokenSaved() {\n    return this.get(\"tokenSaved\");\n  }\n  /**\n   * Updates the biometric token in a secure storage on the device.\n   * @returns Promise with `true`, if token was updated.\n   */\n  async updateToken({ token: t, ...s } = {}) {\n    return [\"removed\", \"updated\"].includes(\n      (await g({\n        ...s,\n        postEvent: this.postEvent,\n        method: \"web_app_biometry_update_token\",\n        event: \"biometry_token_updated\",\n        params: { token: t || \"\" }\n      })).status\n    );\n  }\n}\nasync function Ke(e) {\n  return Qt(\n    await g({\n      ...e || {},\n      method: \"web_app_biometry_get_info\",\n      event: \"biometry_info_received\"\n    })\n  );\n}\nconst Je = l(\n  \"biometryManager\",\n  async ({ postEvent: e, version: t, state: s }) => new ze({\n    ...s || C(\"web_app_biometry_get_info\", t) ? s || await Ke({ timeout: 1e3 }) : {\n      available: !1,\n      accessGranted: !1,\n      accessRequested: !1,\n      tokenSaved: !1,\n      deviceId: \"\"\n    },\n    version: t,\n    postEvent: e\n  })\n);\nclass dt extends ht {\n  constructor() {\n    super(...arguments), c(this, \"on\", this.state.on.bind(this.state)), c(this, \"off\", this.state.off.bind(this.state));\n  }\n}\nclass Fe extends dt {\n  constructor(t, s) {\n    super({ isConfirmationNeeded: t }), this.postEvent = s;\n  }\n  set isConfirmationNeeded(t) {\n    this.set(\"isConfirmationNeeded\", t), this.postEvent(\"web_app_setup_closing_behavior\", { need_confirmation: t });\n  }\n  /**\n   * True, if the confirmation dialog should be shown while the user is trying to close\n   * the Mini App.\n   */\n  get isConfirmationNeeded() {\n    return this.get(\"isConfirmationNeeded\");\n  }\n  /**\n   * Disables the confirmation dialog when closing the Mini App.\n   */\n  disableConfirmation() {\n    this.isConfirmationNeeded = !1;\n  }\n  /**\n   * Enables the confirmation dialog when closing the Mini App.\n   */\n  enableConfirmation() {\n    this.isConfirmationNeeded = !0;\n  }\n}\nconst Qe = l(\n  \"closingBehavior\",\n  ({\n    postEvent: e,\n    state: t = { isConfirmationNeeded: !1 }\n  }) => new Fe(t.isConfirmationNeeded, e)\n);\nclass _t {\n  constructor(t, s) {\n    c(this, \"supports\"), this.supports = Mt(t, s);\n  }\n}\nfunction Ye(e) {\n  if (Array.isArray(e))\n    return e;\n  if (typeof e == \"string\")\n    try {\n      const t = JSON.parse(e);\n      if (Array.isArray(t))\n        return t;\n    } catch {\n    }\n  throw T();\n}\nclass Ze extends G {\n  constructor(t, s, n) {\n    super(Ye, s, n), c(this, \"itemParser\"), this.itemParser = typeof t == \"function\" ? t : t.parse.bind(t);\n  }\n  /**\n   * Attempts to parse passed value\n   * @param value - value to parse.\n   * @throws {SDKError} ERR_PARSE\n   * @see ERR_PARSE\n   */\n  parse(t) {\n    const s = super.parse(t);\n    return s === void 0 ? s : s.map(this.itemParser);\n  }\n  of(t) {\n    return this.itemParser = typeof t == \"function\" ? t : t.parse.bind(t), this;\n  }\n}\nfunction Xe(e) {\n  return new Ze((t) => t, !1, e);\n}\nfunction yt(e, t) {\n  return Object.fromEntries(e.map((s) => [s, t]));\n}\nclass ts extends _t {\n  constructor(t, s, n) {\n    super(t, {\n      delete: \"web_app_invoke_custom_method\",\n      get: \"web_app_invoke_custom_method\",\n      getKeys: \"web_app_invoke_custom_method\",\n      set: \"web_app_invoke_custom_method\"\n    }), this.createRequestId = s, this.postEvent = n;\n  }\n  /**\n   * Deletes specified key or keys from the cloud storage.\n   * @param keyOrKeys - key or keys to delete.\n   * @param options - request execution options.\n   */\n  async delete(t, s = {}) {\n    const n = Array.isArray(t) ? t : [t];\n    n.length && await q(\n      \"deleteStorageValues\",\n      { keys: n },\n      this.createRequestId(),\n      { ...s, postEvent: this.postEvent }\n    );\n  }\n  /**\n   * Returns list of all keys presented in the cloud storage.\n   * @param options - request execution options.\n   */\n  async getKeys(t = {}) {\n    return Xe().of(u()).parse(\n      await q(\n        \"getStorageKeys\",\n        {},\n        this.createRequestId(),\n        { ...t, postEvent: this.postEvent }\n      )\n    );\n  }\n  async get(t, s = {}) {\n    const n = Array.isArray(t) ? t : [t];\n    if (!n.length)\n      return yt(n, \"\");\n    const r = await q(\n      \"getStorageValues\",\n      { keys: n },\n      this.createRequestId(),\n      { ...s, postEvent: this.postEvent }\n    ), i = v(yt(n, u()), \"CloudStorageData\").parse(r);\n    return Array.isArray(t) ? i : i[t];\n  }\n  /**\n   * Saves specified value by key.\n   * @param key - storage key.\n   * @param value - storage value.\n   * @param options - request execution options.\n   */\n  async set(t, s, n = {}) {\n    await q(\n      \"saveStorageValue\",\n      { key: t, value: s },\n      this.createRequestId(),\n      { ...n, postEvent: this.postEvent }\n    );\n  }\n}\nconst es = l(\n  ({ createRequestId: e, postEvent: t, version: s }) => new ts(s, e, t)\n);\nclass ss extends _t {\n  constructor(t, s) {\n    super(t, {\n      impactOccurred: \"web_app_trigger_haptic_feedback\",\n      notificationOccurred: \"web_app_trigger_haptic_feedback\",\n      selectionChanged: \"web_app_trigger_haptic_feedback\"\n    }), this.postEvent = s;\n  }\n  /**\n   * A method tells that an impact occurred. The Telegram app may play the\n   * appropriate haptics based on style value passed.\n   * @param style - impact style.\n   */\n  impactOccurred(t) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"impact\",\n      impact_style: t\n    });\n  }\n  /**\n   * A method tells that a task or action has succeeded, failed, or produced\n   * a warning. The Telegram app may play the appropriate haptics based on\n   * type value passed.\n   * @param type - notification type.\n   */\n  notificationOccurred(t) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"notification\",\n      notification_type: t\n    });\n  }\n  /**\n   * A method tells that the user has changed a selection. The Telegram app\n   * may play the appropriate haptics.\n   *\n   * Do not use this feedback when the user makes or confirms a selection;\n   * use it only when the selection changes.\n   */\n  selectionChanged() {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", { type: \"selection_change\" });\n  }\n}\nconst ns = l(\n  ({ version: e, postEvent: t }) => new ss(e, t)\n);\nclass rs {\n  constructor(t) {\n    this.initData = t;\n  }\n  /**\n   * @see InitDataParsed.authDate\n   */\n  get authDate() {\n    return this.initData.authDate;\n  }\n  /**\n   * @see InitDataParsed.canSendAfter\n   */\n  get canSendAfter() {\n    return this.initData.canSendAfter;\n  }\n  /**\n   * Date after which it is allowed to call\n   * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n   */\n  get canSendAfterDate() {\n    const { canSendAfter: t } = this;\n    return t ? new Date(this.authDate.getTime() + t * 1e3) : void 0;\n  }\n  /**\n   * @see InitDataParsed.chat\n   */\n  get chat() {\n    return this.initData.chat;\n  }\n  /**\n   * @see InitDataParsed.chatType\n   */\n  get chatType() {\n    return this.initData.chatType;\n  }\n  /**\n   * @see InitDataParsed.chatInstance\n   */\n  get chatInstance() {\n    return this.initData.chatInstance;\n  }\n  /**\n   * @see InitDataParsed.hash\n   */\n  get hash() {\n    return this.initData.hash;\n  }\n  /**\n   * @see InitDataParsed.queryId\n   */\n  get queryId() {\n    return this.initData.queryId;\n  }\n  /**\n   * @see InitDataParsed.receiver\n   */\n  get receiver() {\n    return this.initData.receiver;\n  }\n  /**\n   * @see InitDataParsed.startParam\n   */\n  get startParam() {\n    return this.initData.startParam;\n  }\n  /**\n   * @see InitDataParsed.user\n   */\n  get user() {\n    return this.initData.user;\n  }\n}\nconst is = l(\n  ({ initData: e }) => e ? new rs(e) : void 0\n);\nfunction mn(e) {\n  return $t().parse(e);\n}\nclass os extends $ {\n  constructor(t, s, n) {\n    super({ isOpened: t }, s, { open: \"web_app_open_invoice\" }), this.postEvent = n;\n  }\n  set isOpened(t) {\n    this.set(\"isOpened\", t);\n  }\n  /**\n   * True if invoice is currently opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  async open(t, s) {\n    if (this.isOpened)\n      throw new Error(\"Invoice is already opened\");\n    let n;\n    if (!s)\n      n = t;\n    else {\n      const { hostname: r, pathname: i } = new URL(t, window.location.href);\n      if (r !== \"t.me\")\n        throw new Error(`Incorrect hostname: ${r}`);\n      const o = i.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n      if (!o)\n        throw new Error('Link pathname has incorrect format. Expected to receive \"/invoice/{slug}\" or \"/${slug}\"');\n      [, , n] = o;\n    }\n    this.isOpened = !0;\n    try {\n      return (await g({\n        method: \"web_app_open_invoice\",\n        event: \"invoice_closed\",\n        params: { slug: n },\n        postEvent: this.postEvent,\n        capture(r) {\n          return n === r.slug;\n        }\n      })).status;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nconst as = l(\n  ({ version: e, postEvent: t }) => new os(!1, e, t)\n);\nclass cs extends ht {\n  constructor({ postEvent: t, ...s }) {\n    super(s), c(this, \"postEvent\"), c(this, \"on\", (n, r) => n === \"click\" ? y(\"main_button_pressed\", r) : this.state.on(n, r)), c(this, \"off\", (n, r) => n === \"click\" ? z(\"main_button_pressed\", r) : this.state.off(n, r)), this.postEvent = t;\n  }\n  /**\n   * The MainButton background color.\n   */\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  /**\n   * Sends current local state to the Telegram application.\n   */\n  commit() {\n    this.text !== \"\" && this.postEvent(\"web_app_setup_main_button\", {\n      is_visible: this.isVisible,\n      is_active: this.isEnabled,\n      is_progress_visible: this.isLoaderVisible,\n      text: this.text,\n      color: this.bgColor,\n      text_color: this.textColor\n    });\n  }\n  /**\n   * Disables the MainButton.\n   * @see Does not work on Android: https://github.com/Telegram-Mini-Apps/issues/issues/1\n   */\n  disable() {\n    return this.isEnabled = !1, this;\n  }\n  /**\n   * Enables the MainButton.\n   */\n  enable() {\n    return this.isEnabled = !0, this;\n  }\n  /**\n   * Hides the MainButton.\n   */\n  hide() {\n    return this.isVisible = !1, this;\n  }\n  /**\n   * Hides the MainButton loading indicator.\n   */\n  hideLoader() {\n    return this.isLoaderVisible = !1, this;\n  }\n  set isEnabled(t) {\n    this.setParams({ isEnabled: t });\n  }\n  /**\n   * True if the MainButton is enabled.\n   */\n  get isEnabled() {\n    return this.get(\"isEnabled\");\n  }\n  set isLoaderVisible(t) {\n    this.setParams({ isLoaderVisible: t });\n  }\n  /**\n   * True if the MainButton loader is visible.\n   */\n  get isLoaderVisible() {\n    return this.get(\"isLoaderVisible\");\n  }\n  set isVisible(t) {\n    this.setParams({ isVisible: t });\n  }\n  /**\n   * True if the MainButton is visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Shows the MainButton.\n   *\n   * Note that opening the Mini App from the attachment menu hides the main button until the\n   * user interacts with the Mini App interface.\n   */\n  show() {\n    return this.isVisible = !0, this;\n  }\n  /**\n   * Shows a loading indicator on the Main Button.\n   */\n  showLoader() {\n    return this.isLoaderVisible = !0, this;\n  }\n  /**\n   * Sets a new MainButton text. Minimal length for the text is 1 symbol, and maximum is 64 symbols.\n   * @param text - a new text.\n   */\n  setText(t) {\n    return this.setParams({ text: t });\n  }\n  /**\n   * Sets a new Main Button text color.\n   * @param textColor - new text color.\n   */\n  setTextColor(t) {\n    return this.setParams({ textColor: t });\n  }\n  /**\n   * Updates current Main Button color.\n   * @param bgColor - color to set.\n   */\n  setBgColor(t) {\n    return this.setParams({ bgColor: t });\n  }\n  /**\n   * Allows setting multiple Main Button parameters.\n   * @param params - Main Button parameters.\n   */\n  setParams(t) {\n    return this.set(t), this.commit(), this;\n  }\n  /**\n   * The MainButton text.\n   */\n  get text() {\n    return this.get(\"text\");\n  }\n  /**\n   * The MainButton text color.\n   */\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nconst hs = l(\n  \"mainButton\",\n  ({\n    postEvent: e,\n    themeParams: t,\n    state: s = {\n      isVisible: !1,\n      isEnabled: !1,\n      text: \"\",\n      isLoaderVisible: !1,\n      textColor: t.buttonTextColor || \"#ffffff\",\n      bgColor: t.buttonColor || \"#000000\"\n    }\n  }) => new cs({ ...s, postEvent: e })\n);\nfunction ps() {\n  return ut({\n    contact: v({\n      userId: {\n        type: x(),\n        from: \"user_id\"\n      },\n      phoneNumber: {\n        type: u(),\n        from: \"phone_number\"\n      },\n      firstName: {\n        type: u(),\n        from: \"first_name\"\n      },\n      lastName: {\n        type: u().optional(),\n        from: \"last_name\"\n      }\n    }),\n    authDate: {\n      type: Lt(),\n      from: \"auth_date\"\n    },\n    hash: u()\n  }, \"RequestedContact\");\n}\nfunction Yt(e, t) {\n  return (s) => {\n    const [n, r] = t[s];\n    return C(n, r, e);\n  };\n}\nfunction us(e) {\n  return new Promise((t) => {\n    setTimeout(t, e);\n  });\n}\nclass ls extends $ {\n  constructor({ postEvent: t, createRequestId: s, version: n, botInline: r, ...i }) {\n    super(i, n, {\n      requestPhoneAccess: \"web_app_request_phone\",\n      requestWriteAccess: \"web_app_request_write_access\",\n      switchInlineQuery: \"web_app_switch_inline_query\",\n      setHeaderColor: \"web_app_set_header_color\",\n      setBackgroundColor: \"web_app_set_background_color\"\n    }), c(this, \"botInline\"), c(this, \"postEvent\"), c(this, \"createRequestId\"), c(this, \"requestPhoneAccessPromise\"), c(this, \"requestWriteAccessPromise\"), c(this, \"supportsParam\"), this.createRequestId = s, this.postEvent = t, this.botInline = r;\n    const o = this.supports.bind(this);\n    this.supports = (a) => o(a) ? a !== \"switchInlineQuery\" || r : !1, this.supportsParam = Yt(n, {\n      \"setHeaderColor.color\": [\"web_app_set_header_color\", \"color\"]\n    });\n  }\n  /**\n   * Attempts to get requested contact.\n   * @param timeout - request timeout.\n   */\n  async getRequestedContact({\n    timeout: t = 1e4\n  } = {}) {\n    return ps().parse(\n      await q(\n        \"getRequestedContact\",\n        {},\n        this.createRequestId(),\n        { postEvent: this.postEvent, timeout: t }\n      )\n    );\n  }\n  /**\n   * The Mini App background color.\n   * @example \"#ffaabb\"\n   */\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  /**\n   * Closes the Mini App.\n   * @param returnBack - should the application be wrapped into the bottom bar.\n   */\n  close(t) {\n    this.postEvent(\"web_app_close\", { return_back: t });\n  }\n  /**\n   * The Mini App header color.\n   * @example \"#ffaabb\"\n   * @example \"bg_color\"\n   */\n  get headerColor() {\n    return this.get(\"headerColor\");\n  }\n  /**\n   * True if the Mini App is currently launched in bot inline mode.\n   */\n  get isBotInline() {\n    return this.botInline;\n  }\n  /**\n   * True if the current Mini App background color is recognized as dark.\n   */\n  get isDark() {\n    return Bt(this.bgColor);\n  }\n  /**\n   * Informs the Telegram app that the Mini App is ready to be displayed.\n   *\n   * It is recommended to call this method as early as possible, as soon as all essential\n   * interface elements loaded. Once this method called, the loading placeholder is hidden\n   * and the Mini App shown.\n   *\n   * If the method not called, the placeholder will be hidden only when the page fully loaded.\n   */\n  ready() {\n    this.postEvent(\"web_app_ready\");\n  }\n  /**\n   * Requests current user contact information. In contrary to requestPhoneAccess, this method\n   * returns promise with contact information that rejects in case, user denied access, or request\n   * failed.\n   * @param options - additional options.\n   */\n  async requestContact({ timeout: t = 5e3 } = {}) {\n    try {\n      return await this.getRequestedContact();\n    } catch {\n    }\n    if (await this.requestPhoneAccess() !== \"sent\")\n      throw new Error(\"Access denied.\");\n    const s = Date.now() + t;\n    let n = 50;\n    return Dt(async () => {\n      for (; Date.now() < s; ) {\n        try {\n          return await this.getRequestedContact();\n        } catch {\n        }\n        await us(n), n += 50;\n      }\n      throw Nt(t);\n    }, t);\n  }\n  /**\n   * Requests current user phone access. Method returns promise, which resolves\n   * status of the request. In case, user accepted the request, Mini App bot will receive\n   * the according notification.\n   *\n   * To obtain the retrieved information instead, utilize the `requestContact` method.\n   * @param options - additional options.\n   * @see requestContact\n   */\n  async requestPhoneAccess(t = {}) {\n    return this.requestPhoneAccessPromise || (this.requestPhoneAccessPromise = g({\n      ...t,\n      method: \"web_app_request_phone\",\n      event: \"phone_requested\",\n      postEvent: this.postEvent\n    }).then(({ status: s }) => s).finally(() => this.requestPhoneAccessPromise = void 0)), this.requestPhoneAccessPromise;\n  }\n  /**\n   * Requests write message access to current user.\n   * @param options - additional options.\n   */\n  async requestWriteAccess(t = {}) {\n    return this.requestWriteAccessPromise || (this.requestWriteAccessPromise = g({\n      ...t,\n      method: \"web_app_request_write_access\",\n      event: \"write_access_requested\",\n      postEvent: this.postEvent\n    }).then(({ status: s }) => s).finally(() => this.requestWriteAccessPromise = void 0)), this.requestWriteAccessPromise;\n  }\n  /**\n   * A method used to send data to the bot. When this method called, a service message sent to\n   * the bot containing the data of the length up to 4096 bytes, and the Mini App closed. See the\n   * field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n   *\n   * This method is only available for Mini Apps launched via a Keyboard button.\n   * @param data - data to send to bot.\n   * @throws {Error} data has incorrect size.\n   */\n  sendData(t) {\n    const { size: s } = new Blob([t]);\n    if (!s || s > 4096)\n      throw new Error(`Passed data has incorrect size: ${s}`);\n    this.postEvent(\"web_app_data_send\", { data: t });\n  }\n  /**\n   * Updates current Mini App header color.\n   *\n   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/tma.js/issues/9\n   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/tma.js/issues/8\n   * @param color - color key or RGB color.\n   */\n  setHeaderColor(t) {\n    this.postEvent(\"web_app_set_header_color\", ct(t) ? { color: t } : { color_key: t }), this.set(\"headerColor\", t);\n  }\n  /**\n   * Updates current Mini App background color.\n   *\n   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/tma.js/issues/9\n   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/tma.js/issues/8\n   * @param color - RGB color.\n   */\n  setBgColor(t) {\n    this.postEvent(\"web_app_set_background_color\", { color: t }), this.set(\"bgColor\", t);\n  }\n  /**\n   * Inserts the bot's username and the specified inline query in the current chat's input field.\n   * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n   * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n   * the specified inline query in the input field.\n   * @param text - text which should be inserted in the input after the current bot name. Max\n   * length is 256 symbols.\n   * @param chatTypes - List of chat types which could be chosen to send the message. Could be\n   * empty list.\n   */\n  switchInlineQuery(t, s = []) {\n    if (!this.supports(\"switchInlineQuery\") && !this.isBotInline)\n      throw new Error(\"Method is unsupported because Mini App should be launched in inline mode.\");\n    this.postEvent(\"web_app_switch_inline_query\", { query: t, chat_types: s });\n  }\n}\nconst ds = l(\n  \"miniApp\",\n  ({\n    themeParams: e,\n    botInline: t = !1,\n    state: s = {\n      bgColor: e.bgColor || \"#ffffff\",\n      headerColor: e.headerBgColor || \"#000000\"\n    },\n    ...n\n  }) => new ls({ ...n, ...s, botInline: t })\n);\nfunction _s(e) {\n  const t = e.message.trim(), s = (e.title || \"\").trim(), n = e.buttons || [];\n  let r;\n  if (s.length > 64)\n    throw new Error(`Title has incorrect size: ${s.length}`);\n  if (!t.length || t.length > 256)\n    throw new Error(`Message has incorrect size: ${t.length}`);\n  if (n.length > 3)\n    throw new Error(`Buttons have incorrect size: ${n.length}`);\n  return n.length ? r = n.map((i) => {\n    const { id: o = \"\" } = i;\n    if (o.length > 64)\n      throw new Error(`Button ID has incorrect size: ${o}`);\n    if (!i.type || i.type === \"default\" || i.type === \"destructive\") {\n      const a = i.text.trim();\n      if (!a.length || a.length > 64) {\n        const h = i.type || \"default\";\n        throw new Error(`Button text with type \"${h}\" has incorrect size: ${i.text.length}`);\n      }\n      return { ...i, text: a, id: o };\n    }\n    return { ...i, id: o };\n  }) : r = [{ type: \"close\", id: \"\" }], { title: s, message: t, buttons: r };\n}\nclass gs extends $ {\n  constructor(t, s, n) {\n    super({ isOpened: t }, s, { open: \"web_app_open_popup\" }), this.postEvent = n;\n  }\n  set isOpened(t) {\n    this.set(\"isOpened\", t);\n  }\n  /**\n   * True if the Popup is opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  /**\n   * A method that shows a native popup described by the `params` argument.\n   * Promise will be resolved when popup is closed. Resolved value will have\n   * an identifier of pressed button.\n   *\n   * In case, user clicked outside the popup or clicked top right popup close\n   * button, null will be returned.\n   *\n   * @param options - popup parameters.\n   * @throws {Error} Popup is already opened.\n   */\n  async open(t) {\n    if (this.isOpened)\n      throw new Error(\"Popup is already opened.\");\n    this.isOpened = !0;\n    try {\n      const { button_id: s = null } = await g({\n        event: \"popup_closed\",\n        method: \"web_app_open_popup\",\n        postEvent: this.postEvent,\n        params: _s(t)\n      });\n      return s;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nconst ws = l(\n  ({ postEvent: e, version: t }) => new gs(!1, t, e)\n);\nclass fs extends $ {\n  constructor(t, s, n) {\n    super({ isOpened: t }, s, {\n      close: \"web_app_close_scan_qr_popup\",\n      open: \"web_app_open_scan_qr_popup\"\n    }), this.postEvent = n;\n  }\n  /**\n   * Closes the scanner.\n   */\n  close() {\n    this.postEvent(\"web_app_close_scan_qr_popup\"), this.isOpened = !1;\n  }\n  set isOpened(t) {\n    this.set(\"isOpened\", t);\n  }\n  /**\n   * Returns true if the scanner is currently opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  async open(t) {\n    if (this.isOpened)\n      throw new Error(\"The scanner is already opened\");\n    const { text: s, capture: n } = (typeof t == \"string\" ? { text: t } : t) || {};\n    this.isOpened = !0;\n    try {\n      const r = (await g({\n        method: \"web_app_open_scan_qr_popup\",\n        event: [\"qr_text_received\", \"scan_qr_popup_closed\"],\n        postEvent: this.postEvent,\n        params: { text: s },\n        capture(i) {\n          return i.event === \"scan_qr_popup_closed\" || !n || n(i.payload);\n        }\n      }) || {}).data || null;\n      return r && this.close(), r;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n  // TODO: Streaming mode, allowing to scan several QRs until closed.\n}\nconst ms = l(\n  ({ version: e, postEvent: t }) => new fs(!1, e, t)\n);\nclass bs extends pt {\n  constructor(t, s, n) {\n    super({ isVisible: t }, s, {\n      show: \"web_app_setup_settings_button\",\n      hide: \"web_app_setup_settings_button\"\n    }), c(this, \"on\", (r, i) => r === \"click\" ? y(\"settings_button_pressed\", i) : this.state.on(r, i)), c(this, \"off\", (r, i) => r === \"click\" ? z(\"settings_button_pressed\", i) : this.state.off(r, i)), this.postEvent = n;\n  }\n  set isVisible(t) {\n    this.set(\"isVisible\", t), this.postEvent(\"web_app_setup_settings_button\", { is_visible: t });\n  }\n  /**\n   * True if the SettingsButton is visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Hides the SettingsButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the SettingsButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nconst vs = l(\n  \"settingsButton\",\n  ({\n    version: e,\n    postEvent: t,\n    state: s = { isVisible: !1 }\n  }) => new bs(s.isVisible, e, t)\n);\nfunction Zt(e) {\n  return Ht().parse(e);\n}\nclass ys extends dt {\n  /**\n   * @since v6.10\n   */\n  get accentTextColor() {\n    return this.get(\"accentTextColor\");\n  }\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  get buttonColor() {\n    return this.get(\"buttonColor\");\n  }\n  get buttonTextColor() {\n    return this.get(\"buttonTextColor\");\n  }\n  get destructiveTextColor() {\n    return this.get(\"destructiveTextColor\");\n  }\n  /**\n   * Returns the copy of the internal state of the current component instance.\n   */\n  getState() {\n    return this.clone();\n  }\n  /**\n   * @since v6.10\n   */\n  get headerBgColor() {\n    return this.get(\"headerBgColor\");\n  }\n  get hintColor() {\n    return this.get(\"hintColor\");\n  }\n  /**\n   * @returns True in case, current color scheme is recognized as dark. This\n   * value is calculated according to theme bg color.\n   */\n  get isDark() {\n    return !this.bgColor || Bt(this.bgColor);\n  }\n  get linkColor() {\n    return this.get(\"linkColor\");\n  }\n  get secondaryBgColor() {\n    return this.get(\"secondaryBgColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionBgColor() {\n    return this.get(\"sectionBgColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionHeaderTextColor() {\n    return this.get(\"sectionHeaderTextColor\");\n  }\n  /**\n   * @since v7.6\n   */\n  get sectionSeparatorColor() {\n    return this.get(\"sectionHeaderTextColor\");\n  }\n  /**\n   * Starts listening to the external theme changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return y(\"theme_changed\", (t) => {\n      this.set(Zt(t.theme_params));\n    });\n  }\n  /**\n   * @since v6.10\n   */\n  get subtitleTextColor() {\n    return this.get(\"subtitleTextColor\");\n  }\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nconst Es = l(\n  \"themeParams\",\n  ({ themeParams: e, state: t = e, addCleanup: s }) => {\n    const n = new ys(t);\n    return s(n.listen()), n;\n  }\n);\nfunction bn(e = {}) {\n  return g({\n    ...e,\n    method: \"web_app_request_theme\",\n    event: \"theme_changed\"\n  }).then(Zt);\n}\nfunction B(e, t) {\n  return e.startsWith(t) ? e : `${t}${e}`;\n}\nfunction M(e) {\n  return new URL(\n    typeof e == \"string\" ? e : `${e.pathname || \"\"}${B(e.search || \"\", \"?\")}${B(e.hash || \"\", \"#\")}`,\n    \"http://a\"\n  );\n}\nclass Ps extends _t {\n  constructor(t, s, n) {\n    super(t, { readTextFromClipboard: \"web_app_read_text_from_clipboard\" }), c(this, \"supportsParam\"), this.version = t, this.createRequestId = s, this.postEvent = n, this.supportsParam = Yt(t, {\n      \"openLink.tryInstantView\": [\"web_app_open_link\", \"try_instant_view\"]\n    });\n  }\n  openLink(t, s) {\n    const n = M(t).toString();\n    if (!C(\"web_app_open_link\", this.version)) {\n      window.open(n, \"_blank\");\n      return;\n    }\n    const r = typeof s == \"boolean\" ? { tryInstantView: s } : s || {};\n    this.postEvent(\"web_app_open_link\", {\n      url: n,\n      try_browser: r.tryBrowser,\n      try_instant_view: r.tryInstantView\n    });\n  }\n  /**\n   * Opens a Telegram link inside Telegram app. The Mini App will be closed. It expects passing\n   * link in full format, with hostname \"t.me\".\n   * @param url - URL to be opened.\n   * @throws {Error} URL has not allowed hostname.\n   */\n  openTelegramLink(t) {\n    const { hostname: s, pathname: n, search: r } = new URL(t, \"https://t.me\");\n    if (s !== \"t.me\")\n      throw new Error(`URL has not allowed hostname: ${s}. Only \"t.me\" is allowed`);\n    if (!C(\"web_app_open_tg_link\", this.version)) {\n      window.location.href = t;\n      return;\n    }\n    this.postEvent(\"web_app_open_tg_link\", { path_full: n + r });\n  }\n  /**\n   * Reads text from clipboard and returns string or null. null is returned\n   * in cases:\n   * - Value in clipboard is not text\n   * - Access to clipboard is not allowed\n   */\n  async readTextFromClipboard() {\n    const t = this.createRequestId(), {\n      data: s = null\n    } = await g({\n      method: \"web_app_read_text_from_clipboard\",\n      event: \"clipboard_text_received\",\n      postEvent: this.postEvent,\n      params: { req_id: t },\n      capture: qt(t)\n    });\n    return s;\n  }\n  /**\n   * Shares specified URL with the passed to the chats, selected by user. After being called,\n   * it closes the mini application.\n   *\n   * This method uses Telegram's Share Links.\n   * @param url - URL to share.\n   * @param text - text to append after the URL.\n   * @see https://core.telegram.org/api/links#share-links\n   * @see https://core.telegram.org/widgets/share#custom-buttons\n   */\n  shareURL(t, s) {\n    this.openTelegramLink(\n      \"https://t.me/share/url?\" + new URLSearchParams({ url: t, text: s || \"\" }).toString().replace(/\\+/g, \"%20\")\n    );\n  }\n}\nconst Rs = l(\n  ({ version: e, postEvent: t, createRequestId: s }) => new Ps(e, s, t)\n);\nasync function Xt(e = {}) {\n  const {\n    is_expanded: t,\n    is_state_stable: s,\n    ...n\n  } = await g({\n    ...e,\n    method: \"web_app_request_viewport\",\n    event: \"viewport_changed\"\n  });\n  return { ...n, isExpanded: t, isStateStable: s };\n}\nfunction O(e) {\n  return e < 0 ? 0 : e;\n}\nclass xs extends dt {\n  constructor({ postEvent: t, stableHeight: s, height: n, width: r, isExpanded: i }) {\n    super({\n      height: O(n),\n      isExpanded: i,\n      stableHeight: O(s),\n      width: O(r)\n    }), c(this, \"postEvent\"), this.postEvent = t;\n  }\n  /**\n   * Requests viewport information from the Telegram application and updates current Viewport\n   * instance.\n   * @param options - options to request fresh data.\n   */\n  async sync(t) {\n    const { isStateStable: s, ...n } = await Xt(t);\n    this.set({\n      ...n,\n      stableHeight: s ? n.height : this.get(\"stableHeight\")\n    });\n  }\n  /**\n   * The current height of the **visible area** of the Mini App.\n   *\n   * The application can display just the top part of the Mini App, with its lower part remaining\n   * outside the screen area. From this position, the user can \"pull\" the Mini App to its\n   * maximum height, while the bot can do the same by calling `expand` method. As the position of\n   * the Mini App changes, the current height value of the visible area will be updated  in real\n   * time.\n   *\n   * Please note that the refresh rate of this value is not sufficient to smoothly follow the\n   * lower border of the window. It should not be used to pin interface elements to the bottom\n   * of the visible area. It's more appropriate to use the value of the `stableHeight`\n   * field for this purpose.\n   *\n   * @see stableHeight\n   */\n  get height() {\n    return this.get(\"height\");\n  }\n  /**\n   * The height of the visible area of the Mini App in its last stable state.\n   *\n   * The application can display just the top part of the Mini App, with its lower part remaining\n   * outside the screen area. From this position, the user can \"pull\" the Mini App to its\n   * maximum height, while the application can do the same by calling `expand` method.\n   *\n   * Unlike the value of `height`, the value of `stableHeight` does not change as the position\n   * of the Mini App changes with user gestures or during animations. The value of `stableHeight`\n   * will be updated after all gestures and animations are completed and\n   * the Mini App reaches its final size.\n   *\n   * @see height\n   */\n  get stableHeight() {\n    return this.get(\"stableHeight\");\n  }\n  /**\n   * Starts listening to viewport changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return y(\"viewport_changed\", (t) => {\n      const {\n        height: s,\n        width: n,\n        is_expanded: r,\n        is_state_stable: i\n      } = t, o = O(s);\n      this.set({\n        height: o,\n        isExpanded: r,\n        width: O(n),\n        ...i ? { stableHeight: o } : {}\n      });\n    });\n  }\n  /**\n   * True if the Mini App is expanded to the maximum available height. Otherwise, if\n   * the Mini App occupies part of the screen and can be expanded to the full height using\n   * `expand` method.\n   * @see expand\n   */\n  get isExpanded() {\n    return this.get(\"isExpanded\");\n  }\n  /**\n   * Current visible area width.\n   */\n  get width() {\n    return this.get(\"width\");\n  }\n  /**\n   * A method that expands the Mini App to the maximum available height. To find out if the Mini\n   * App is expanded to the maximum height, refer to the value of the `isExpanded`.\n   * @see isExpanded\n   */\n  expand() {\n    this.postEvent(\"web_app_expand\"), this.set(\"isExpanded\", !0);\n  }\n  /**\n   * True if the current viewport height is stable and is not going to change in the next moment.\n   */\n  get isStable() {\n    return this.stableHeight === this.height;\n  }\n}\nconst Cs = l(\n  \"viewport\",\n  async ({ state: e, platform: t, postEvent: s, addCleanup: n }) => {\n    let r = !1, i = 0, o = 0, a = 0;\n    if (e)\n      r = e.isExpanded, i = e.height, o = e.width, a = e.stableHeight;\n    else if ([\"macos\", \"tdesktop\", \"unigram\", \"webk\", \"weba\", \"web\"].includes(t))\n      r = !0, i = window.innerHeight, o = window.innerWidth, a = window.innerHeight;\n    else {\n      const p = await Xt({ timeout: 1e3, postEvent: s });\n      r = p.isExpanded, i = p.height, o = p.width, a = p.isStateStable ? i : 0;\n    }\n    const h = new xs({\n      postEvent: s,\n      height: i,\n      width: o,\n      stableHeight: a,\n      isExpanded: r\n    });\n    return n(h.listen()), h;\n  }\n);\nfunction P(e, t) {\n  document.documentElement.style.setProperty(e, t);\n}\nfunction vn(e, t, s) {\n  s || (s = (a) => `--tg-${a}-color`);\n  const n = s(\"header\"), r = s(\"bg\"), i = () => {\n    const { headerColor: a } = e;\n    if (ct(a))\n      P(n, a);\n    else {\n      const { bgColor: h, secondaryBgColor: p } = t;\n      a === \"bg_color\" && h ? P(n, h) : a === \"secondary_bg_color\" && p && P(n, p);\n    }\n    P(r, e.bgColor);\n  }, o = [\n    t.on(\"change\", i),\n    e.on(\"change\", i)\n  ];\n  return i(), () => o.forEach((a) => a());\n}\nfunction yn(e, t) {\n  t || (t = (n) => `--tg-theme-${n.replace(/[A-Z]/g, (r) => `-${r.toLowerCase()}`)}`);\n  const s = () => {\n    Object.entries(e.getState()).forEach(([n, r]) => {\n      r && P(t(n), r);\n    });\n  };\n  return s(), e.on(\"change\", s);\n}\nfunction En(e, t) {\n  t || (t = (p) => `--tg-viewport-${p}`);\n  const [\n    s,\n    n,\n    r\n  ] = [\"height\", \"width\", \"stable-height\"].map((p) => t(p)), i = () => P(s, `${e.height}px`), o = () => P(n, `${e.width}px`), a = () => P(r, `${e.stableHeight}px`), h = [\n    e.on(\"change:height\", i),\n    e.on(\"change:width\", o),\n    e.on(\"change:stableHeight\", a)\n  ];\n  return i(), o(), a(), () => h.forEach((p) => p());\n}\nfunction Ss(e = !0) {\n  const t = [\n    y(\"reload_iframe\", () => {\n      V(\"iframe_will_reload\"), window.location.reload();\n    })\n  ], s = () => t.forEach((n) => n());\n  if (e) {\n    const n = document.createElement(\"style\");\n    n.id = \"telegram-custom-styles\", document.head.appendChild(n), t.push(\n      y(\"set_custom_style\", (r) => {\n        n.innerHTML = r;\n      }),\n      () => document.head.removeChild(n)\n    );\n  }\n  return V(\"iframe_ready\", { reload_supported: !0 }), s;\n}\nfunction Ts() {\n  return typeof window > \"u\";\n}\nasync function Pn() {\n  if (kt(window))\n    return !0;\n  try {\n    return await g({ method: \"web_app_request_theme\", event: \"theme_changed\", timeout: 100 }), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction Rn(e) {\n  const t = typeof e == \"string\" ? lt(e) : e;\n  Jt(t);\n  function s(r) {\n    if (typeof r == \"string\")\n      try {\n        const { eventType: i } = At(r);\n        i === \"web_app_request_theme\" && et(\"theme_changed\", {\n          theme_params: JSON.parse(Kt(t.themeParams))\n        }), i === \"web_app_request_viewport\" && et(\"viewport_changed\", {\n          width: window.innerWidth,\n          height: window.innerHeight,\n          is_state_stable: !0,\n          is_expanded: !0\n        });\n      } catch {\n      }\n  }\n  if (at()) {\n    const r = window.parent.postMessage.bind(window.parent);\n    window.parent.postMessage = (i) => {\n      s(i), r(i);\n    };\n    return;\n  }\n  if (It(window)) {\n    const r = window.external.notify.bind(window.external);\n    window.external.notify = (i) => {\n      s(i), r(i);\n    };\n    return;\n  }\n  const n = window.TelegramWebviewProxy;\n  window.TelegramWebviewProxy = {\n    ...n || {},\n    postEvent(...r) {\n      s(JSON.stringify({ eventType: r[0], eventData: r[1] })), n && n.postEvent(...r);\n    }\n  };\n}\nfunction As(e) {\n  return e instanceof W;\n}\nfunction xn(e, t) {\n  return As(e) && e.type === t;\n}\nfunction J(e, t) {\n  let s, n, r;\n  return typeof e == \"string\" ? s = e : (s = e.pathname === void 0 ? t : e.pathname, n = e.params, r = e.id), Object.freeze({\n    id: r || (Math.random() * 2 ** 14 | 0).toString(16),\n    pathname: s,\n    params: n\n  });\n}\nclass Is {\n  constructor(t, s, n = V) {\n    if (c(this, \"history\"), c(this, \"ee\", new D()), c(this, \"attached\", !1), c(this, \"back\", () => this.go(-1)), c(this, \"on\", this.ee.on.bind(this.ee)), c(this, \"off\", this.ee.off.bind(this.ee)), this._index = s, this.postEvent = n, t.length === 0)\n      throw m(be, \"History should not be empty.\");\n    if (s < 0 || s >= t.length)\n      throw m(\n        ve,\n        \"Index should not be zero and higher or equal than history size.\"\n      );\n    this.history = t.map((r) => J(r, \"\"));\n  }\n  /**\n   * Allows this navigator to control the `BackButton` visibility state. It also tracks the\n   * `BackButton` clicks and calls the `back` method.\n   */\n  attach() {\n    this.attached || (this.attached = !0, this.sync(), y(\"back_button_pressed\", this.back));\n  }\n  /**\n   * Currently active history item.\n   */\n  get current() {\n    return this.history[this.index];\n  }\n  /**\n   * Prevents current navigator from controlling the BackButton visibility state.\n   */\n  detach() {\n    this.attached = !1, z(\"back_button_pressed\", this.back);\n  }\n  /**\n   * Goes to the next history item.\n   */\n  forward() {\n    this.go(1);\n  }\n  /**\n   * Changes currently active history item index by the specified delta. This method doesn't\n   * change index in case, the updated index points to the non-existing history item. This behavior\n   * is preserved until the `fit` argument is specified.\n   * @param delta - index delta.\n   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.\n   */\n  go(t, s) {\n    const n = this.index + t, r = Math.min(\n      Math.max(0, n),\n      this.history.length - 1\n    );\n    (n === r || s) && this.replaceAndMove(r, this.history[r]);\n  }\n  /**\n   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.\n   *\n   * If \"fit\" option was specified and index is out of bounds, it will be cut to the nearest\n   * bound.\n   * @param index - target index.\n   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.\n   */\n  goTo(t, s) {\n    this.go(t - this.index, s);\n  }\n  /**\n   * True if navigator has items before the current item.\n   */\n  get hasPrev() {\n    return this.index > 0;\n  }\n  /**\n   * True if navigator has items after the current item.\n   */\n  get hasNext() {\n    return this.index !== this.history.length - 1;\n  }\n  /**\n   * Currently active history item index.\n   */\n  get index() {\n    return this._index;\n  }\n  /**\n   * Adds a new history item removing all after the current one.\n   * @param item - item to add.\n   */\n  push(t) {\n    this.hasNext && this.history.splice(this.index + 1), this.replaceAndMove(this.index + 1, J(t, this.current.pathname));\n  }\n  /**\n   * Replaces the current history item.\n   * @param item - item to replace the current item with.\n   */\n  replace(t) {\n    this.replaceAndMove(this.index, J(t, this.current.pathname));\n  }\n  /**\n   * Sets history item by the specified index.\n   * @param index - history item index to replace.\n   * @param historyItem - history item to set.\n   */\n  replaceAndMove(t, s) {\n    const n = t - this.index;\n    if (!n && this.current === s)\n      return;\n    const r = this.current;\n    if (this.index !== t) {\n      const i = this._index;\n      this._index = t, this.attached && i > 0 != t > 0 && this.sync();\n    }\n    this.history[t] = s, this.ee.emit(\"change\", {\n      navigator: this,\n      from: r,\n      to: this.current,\n      delta: n\n    });\n  }\n  /**\n   * Actualizes the `BackButton` visibility state.\n   */\n  sync() {\n    this.postEvent(\"web_app_setup_back_button\", { is_visible: !!this.index });\n  }\n}\nfunction F({\n  params: e,\n  ...t\n}) {\n  return { ...e || { hash: \"\", search: \"\" }, ...t };\n}\nfunction U(e) {\n  const t = typeof e == \"string\" ? e.startsWith(\"/\") : !!(e.pathname && e.pathname.startsWith(\"/\")), s = M(e);\n  return `${t ? s.pathname : s.pathname.slice(1)}${s.search}${s.hash}`;\n}\nfunction Q(e, t, s) {\n  let n, r;\n  typeof e == \"string\" ? n = e : (n = U(e), s = e.state, r = e.id);\n  const { pathname: i, search: o, hash: a } = new URL(n, `http://a${B(t, \"/\")}`);\n  return { id: r, pathname: i, params: { hash: a, search: o, state: s } };\n}\nasync function N(e) {\n  return e === 0 ? !0 : Promise.race([\n    new Promise((t) => {\n      const s = tt(\"popstate\", () => {\n        s(), t(!0);\n      });\n      window.history.go(e);\n    }),\n    // Usually, it takes about 1ms to emit this event, but we use some buffer.\n    new Promise((t) => {\n      setTimeout(t, 50, !1);\n    })\n  ]);\n}\nasync function ks() {\n  if (window.history.length <= 1 || (window.history.pushState(null, \"\"), await N(1 - window.history.length)))\n    return;\n  let e = await N(-1);\n  for (; e; )\n    e = await N(-1);\n}\nfunction te(e) {\n  return M(e).pathname;\n}\nconst Et = 0, Y = 1, Z = 2;\nclass ee {\n  constructor(t, s, { postEvent: n, hashMode: r = \"classic\", base: i } = {}) {\n    c(this, \"navigator\"), c(this, \"ee\", new D()), c(this, \"hashMode\"), c(this, \"base\"), c(this, \"attached\", !1), c(this, \"onPopState\", ({ state: o }) => {\n      if (o === null)\n        return this.push(this.parsePath(window.location.href));\n      o === Et ? window.history.forward() : o === Y && this.back(), o === Z && this.forward();\n    }), c(this, \"onNavigatorChange\", async ({\n      to: o,\n      from: a,\n      delta: h\n    }) => {\n      this.attached && await this.syncHistory(), this.ee.emit(\"change\", {\n        delta: h,\n        from: F(a),\n        to: F(o),\n        navigator: this\n      });\n    }), c(this, \"on\", this.ee.on.bind(this.ee)), c(this, \"off\", this.ee.off.bind(this.ee)), this.navigator = new Is(\n      t.map((o) => Q(o, \"/\")),\n      s,\n      n\n    ), this.navigator.on(\"change\", (o) => {\n      this.onNavigatorChange(o);\n    }), this.hashMode = r, this.base = te(i || \"\");\n  }\n  /**\n   * Attaches current navigator to the browser history allowing navigator to manipulate it.\n   */\n  async attach() {\n    this.attached || (this.attached = !0, this.navigator.attach(), window.addEventListener(\"popstate\", this.onPopState), await this.syncHistory());\n  }\n  /**\n   * Goes back in history by 1.\n   */\n  back() {\n    this.navigator.back();\n  }\n  /**\n   * Detaches current navigator from the browser history.\n   */\n  detach() {\n    this.attached = !1, this.navigator.detach(), window.removeEventListener(\"popstate\", this.onPopState);\n  }\n  /**\n   * Goes forward in history.\n   */\n  forward() {\n    return this.navigator.forward();\n  }\n  /**\n   * Current history cursor.\n   */\n  get index() {\n    return this.navigator.index;\n  }\n  /**\n   * Current history item identifier.\n   */\n  get id() {\n    return this.navigator.current.id;\n  }\n  /**\n   * Changes currently active history item index by the specified delta. This method doesn't\n   * change index in case, the updated index points to the non-existing history item. This behavior\n   * is preserved until the `fit` argument is specified.\n   * @param delta - index delta.\n   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.\n   */\n  go(t, s) {\n    return this.navigator.go(t, s);\n  }\n  /**\n   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.\n   *\n   * If \"fit\" option was specified and index is out of bounds, it will be cut to the nearest\n   * bound.\n   * @param index - target index.\n   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.\n   */\n  goTo(t, s) {\n    this.navigator.goTo(t, s);\n  }\n  /**\n   * Current history item hash.\n   * @see URL.hash\n   * @example\n   * \"\", \"#my-hash\"\n   */\n  get hash() {\n    return (this.navigator.current.params || {}).hash || \"\";\n  }\n  /**\n   * True if navigator has items before the current item.\n   */\n  get hasPrev() {\n    return this.navigator.hasPrev;\n  }\n  /**\n   * True if navigator has items after the current item.\n   */\n  get hasNext() {\n    return this.navigator.hasNext;\n  }\n  /**\n   * Navigation history.\n   */\n  get history() {\n    return this.navigator.history.map(F);\n  }\n  /**\n   * Path, including pathname, search and hash.\n   * @example Pathname only.\n   * \"/pathname\"\n   * @example Pathname + search.\n   * \"/pathname?search\"\n   * @example Pathname + hash.\n   * \"/pathname#hash\"\n   * @example Pathname + search + hash.\n   * \"/pathname?search#hash\"\n   */\n  get path() {\n    return U(this);\n  }\n  /**\n   * Current pathname. Always starts with the slash.\n   * @see URL.pathname\n   * @example\n   * \"/\", \"/abc\"\n   */\n  get pathname() {\n    return this.navigator.current.pathname;\n  }\n  /**\n   * Depending on the current navigation type, parses incoming path and returns it presented as\n   * an object. In other words, this method parses the passed path and returns object, describing\n   * how the navigator \"sees\" it.\n   *\n   * @example Hash mode is omitted.\n   * parsePath('/abc?a=1#hash');\n   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }\n   * parsePath('http://example.com/abc?a=1#hash');\n   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }\n   *\n   * @example Hash mode is enabled.\n   * parsePath('/abc?a=1#tma?is=cool#yeah');\n   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }\n   * parsePath('http://example.com/abc?a=1#tma?is=cool#yeah');\n   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }\n   */\n  parsePath(t) {\n    let s = M(t);\n    return this.hashMode && (s = M(s.hash.slice(1))), {\n      pathname: s.pathname,\n      search: s.search,\n      hash: s.hash\n    };\n  }\n  push(t, s) {\n    const n = Q(t, this.path), { state: r = s } = n.params;\n    this.navigator.push({ ...n, params: { ...n.params, state: r } });\n  }\n  replace(t, s) {\n    const n = Q(t, this.path), { state: r = s } = n.params;\n    this.navigator.replace({ ...n, params: { ...n.params, state: r } });\n  }\n  /**\n   * Combines the navigator `base` property with the passed path data applying the navigator\n   * navigation mode.\n   * @param value - path presented as string or URLLike.\n   */\n  renderPath(t) {\n    const s = (this.base.length === 1 ? \"\" : this.base) + B(U(t), \"/\");\n    return this.hashMode ? B(s.slice(1), this.hashMode === \"classic\" ? \"#\" : \"#/\") : s;\n  }\n  /**\n   * Synchronizes current navigator state with browser history.\n   */\n  async syncHistory() {\n    window.removeEventListener(\"popstate\", this.onPopState);\n    const { state: t } = this, s = this.renderPath(this);\n    await ks(), this.hasPrev && this.hasNext ? (window.history.replaceState(Y, \"\"), window.history.pushState(t, \"\", s), window.history.pushState(Z, \"\"), await N(-1)) : this.hasPrev ? (window.history.replaceState(Y, \"\"), window.history.pushState(t, \"\", s)) : this.hasNext ? (window.history.replaceState(t, s), window.history.pushState(Z, \"\"), await N(-1)) : (window.history.replaceState(Et, \"\"), window.history.pushState(t, \"\", s)), window.addEventListener(\"popstate\", this.onPopState);\n  }\n  /**\n   * Current query parameters.\n   * @see URL.search\n   * @example\n   * \"\", \"?\", \"?a=1\"\n   */\n  get search() {\n    return (this.navigator.current.params || {}).search || \"\";\n  }\n  /**\n   * Current history item state.\n   */\n  get state() {\n    return (this.navigator.current.params || {}).state;\n  }\n}\nfunction Os(e) {\n  e || (e = {});\n  const { href: t, hash: s } = window.location;\n  let n = U(\n    e.hashMode === null ? t : s.includes(\"?\") ? s.slice(1) : `?${s.slice(1)}`\n  );\n  const r = e.base ? te(e.base) : void 0;\n  if (r) {\n    if (!n.startsWith(r))\n      throw m(\n        ye,\n        `Path \"${n}\" expected to be starting with \"${r}\"`\n      );\n    n = n.slice(r.length);\n  }\n  return new ee([n], 0, e);\n}\nfunction Cn(e) {\n  const t = e.match(/#(.+)/);\n  return t ? t[1] : null;\n}\nfunction qs(e, t) {\n  if (Ft()) {\n    const s = sessionStorage.getItem(e);\n    if (s)\n      try {\n        const { index: n, history: r } = JSON.parse(s);\n        return new ee(\n          r,\n          n,\n          t\n        );\n      } catch (n) {\n        console.error(\"Unable to restore hash navigator state.\", n);\n      }\n  }\n  return Os(t);\n}\nfunction Sn(e, t) {\n  const s = qs(e, t), n = () => sessionStorage.setItem(e, JSON.stringify({\n    index: s.index,\n    history: s.history\n  }));\n  return s.on(\"change\", n), n(), s;\n}\nfunction d(e, t) {\n  function s(n) {\n    return function(i, o, a) {\n      return (h) => {\n        const p = {\n          ...h,\n          [i]: n(o)\n        };\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(a, { ...p });\n      };\n    };\n  }\n  return [s(e), s(t)];\n}\nconst se = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(void 0);\nfunction Ns() {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(se);\n  if (!e)\n    throw new Error(\"useSDK was used outside the SDKProvider.\");\n  return e;\n}\nfunction _(e) {\n  function t(n) {\n    const r = Ns(), [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\n      n ? void 0 : () => {\n        if (Ts())\n          throw new Error(\"Using hooks on the server side, you must explicitly specify ssr = true option\");\n        return r.use(e);\n      }\n    );\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      o(r.use(e));\n    }, [r]), i;\n  }\n  function s(n) {\n    const r = t(n);\n    if (r) {\n      if (\"error\" in r)\n        throw r.error;\n      return r.result;\n    }\n  }\n  return [t, s];\n}\nconst [Ds, Vs] = _(je), [Tn, An] = d(\n  Ds,\n  Vs\n), [Bs, Ms] = _(Je), [In, kn] = d(\n  Bs,\n  Ms\n), [Ls, $s] = _(Qe), [On, qn] = d(\n  Ls,\n  $s\n), [Hs, Us] = _(es), [Nn, Dn] = d(\n  Hs,\n  Us\n), [Ws, Gs] = _(ns), [Vn, Bn] = d(\n  Ws,\n  Gs\n), [js, zs] = _(is), [Mn, Ln] = d(js, zs), [Ks, Js] = _(as), [$n, Hn] = d(Ks, Js), [Fs, Qs] = _(hs), [Un, Wn] = d(Fs, Qs), [Ys, Zs] = _(ds), [Gn, jn] = d(Ys, Zs), [Xs, tn] = _(ws), [zn, Kn] = d(Xs, tn), [en, sn] = _(ms), [Jn, Fn] = d(en, sn), [nn, rn] = _(vs), [Qn, Yn] = d(\n  nn,\n  rn\n), [on, an] = _(Es), [Zn, Xn] = d(on, an);\nfunction tr(e) {\n  const [t, s] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => e ? void 0 : nt());\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    e && s(nt());\n  }, []), t;\n}\nconst [cn, hn] = _(Rs), [er, sr] = d(cn, hn), [pn, un] = _(Cs), [nr, rr] = d(pn, un);\nfunction ir({ children: e, acceptCustomStyles: t, debug: s }) {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(!0), [r, i] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(/* @__PURE__ */ new Map()), o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(r), a = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (p) => {\n      n.current && i((S) => (p && p(S), new Map(S)));\n    },\n    []\n  ), h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n    use(p, ...S) {\n      const gt = r.get(p);\n      if (gt)\n        return gt;\n      let b, K;\n      try {\n        b = p(...S);\n      } catch (w) {\n        K = w;\n      }\n      function H(w) {\n        return r.set(p, w), w;\n      }\n      if (K)\n        return H({ error: K });\n      let I;\n      if (Array.isArray(b) && (I = b[1], b = b[0]), !b)\n        return H({ result: b, cleanup: I });\n      function wt(w) {\n        if (\"on\" in w) {\n          const k = w.on(\"change\", () => a()), ft = I;\n          I = () => {\n            ft && ft(), k();\n          };\n        }\n        return { result: w, cleanup: I };\n      }\n      return b instanceof Promise ? (b.then(\n        (w) => a((k) => k.set(p, wt(w))),\n        (w) => a((k) => k.set(p, { error: w }))\n      ), H({})) : H(wt(b));\n    }\n  }), [r]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => (n.current = !0, () => {\n    n.current = !1;\n  }), []), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (at())\n      return Ss(t);\n  }, [t]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    ue(s || !1);\n  }, [s]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    o.current = r;\n  }, [r]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => () => {\n    o.current.forEach((p) => {\n      \"cleanup\" in p && p.cleanup && p.cleanup();\n    });\n  }, []), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(se.Provider, { value: h, children: e });\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdG1hLmpzL3Nkay1yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ2dHO0FBQzlJLHNFQUFzRSwwREFBMEQ7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxlQUFlLDJCQUEyQix1Q0FBdUMsZUFBZTtBQUNyRztBQUNBLFdBQVcsRUFBRSxTQUFTLFdBQVc7QUFDakMsU0FBUyxHQUFHLDRCQUE0QjtBQUN4QztBQUNBLFNBQVMsR0FBRyxFQUFFLGFBQWEsR0FBRyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsT0FBTztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQyxrQ0FBa0Msc0JBQXNCLElBQUksU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFL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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMEJBQTBCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsV0FBVyxVQUFVLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQyxFQUFFLFNBQVMsRUFBRSxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0Msd0JBQXdCLFVBQVU7QUFDOUUsV0FBVyw4QkFBOEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBaUQsSUFBSTtBQUMzRSwwSUFBMEksVUFBVTtBQUNwSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRCwwQkFBMEIsZ0JBQWdCLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQsNkJBQTZCLGdCQUFnQix5QkFBeUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBLGlFQUFpRSxXQUFXO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixFQUFFLGtDQUFrQyxFQUFFO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNEQUFFLE1BQU0sTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBRTtBQUNiO0FBQ0EsWUFBWSxpREFBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQ0FBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdEQUFDO0FBQ1o7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQUU7QUFDbkIsU0FBUyxnREFBQztBQUNWO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLDhDQUE4QztBQUM1RCxZQUFZLDZDQUFFLGVBQWUsK0NBQUUsaUNBQWlDLDZDQUFFLFNBQVMsa0RBQUU7QUFDN0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFNBQVMsOENBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QyxhQUFhO0FBQ2I7QUFDQSxHQUFHO0FBQ0gsU0FBUyxnREFBQztBQUNWO0FBQ0EsR0FBRyxRQUFRLGdEQUFDO0FBQ1o7QUFDQTtBQUNBLEdBQUcsUUFBUSxnREFBQztBQUNaO0FBQ0EsR0FBRyxRQUFRLGdEQUFDO0FBQ1o7QUFDQSxHQUFHLFFBQVEsZ0RBQUM7QUFDWjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsdUJBQXVCLHNEQUFFLGdCQUFnQix1QkFBdUI7QUFDbkU7QUF1S0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRtYS5qcy9zZGstcmVhY3QvZGlzdC9pbmRleC5qcz82YjI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCBhcyBQdCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBuZSwgdXNlQ29udGV4dCBhcyByZSwgdXNlU3RhdGUgYXMgcnQsIHVzZUVmZmVjdCBhcyBSLCB1c2VSZWYgYXMgbXQsIHVzZUNhbGxiYWNrIGFzIGllLCB1c2VNZW1vIGFzIG9lIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgYWUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGNlID0gKGUsIHQsIHMpID0+IHQgaW4gZSA/IGFlKGUsIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHMgfSkgOiBlW3RdID0gcywgYyA9IChlLCB0LCBzKSA9PiBjZShlLCB0eXBlb2YgdCAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBzKTtcbmZ1bmN0aW9uIFJ0KGUsIHQpIHtcbiAgbGV0IHM7XG4gIGNvbnN0IG4gPSAoKSA9PiB7XG4gICAgcyAhPT0gdm9pZCAwICYmIHQgJiYgdChzKSwgcyA9IHZvaWQgMDtcbiAgfTtcbiAgcmV0dXJuIFsoKSA9PiBzID09PSB2b2lkIDAgPyBzID0gZShuKSA6IHMsIG5dO1xufVxuZnVuY3Rpb24geHQoZSkge1xuICBjb25zdCB0ID0gaigpLCB7IGNvdW50OiBzIH0gPSB0O1xuICB0LnVuc3Vic2NyaWJlKGUpLCBzICYmICF0LmNvdW50ICYmIFNlKCk7XG59XG5mdW5jdGlvbiBoZShlKSB7XG4gIHJldHVybiBqKCkuc3Vic2NyaWJlKGUpLCAoKSA9PiB4dChlKTtcbn1cbmNsYXNzIHBlIHtcbiAgY29uc3RydWN0b3IodCwgcyA9IHt9KSB7XG4gICAgdGhpcy5zY29wZSA9IHQsIHRoaXMub3B0aW9ucyA9IHM7XG4gIH1cbiAgLyoqXG4gICAqIFByaW50cyBtZXNzYWdlIGludG8gYSBjb25zb2xlIGluIGNhc2UsIGxvZ2dlciBpcyBjdXJyZW50bHkgZW5hYmxlZC5cbiAgICogQHBhcmFtIGxldmVsIC0gbG9nIGxldmVsLlxuICAgKiBAcGFyYW0gYXJncyAtIGFyZ3VtZW50cy5cbiAgICovXG4gIHByaW50KHQsIC4uLnMpIHtcbiAgICBjb25zdCBuID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHIgPSBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tR0JcIiwge1xuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgc2Vjb25kOiBcIjItZGlnaXRcIixcbiAgICAgIGZyYWN0aW9uYWxTZWNvbmREaWdpdHM6IDMsXG4gICAgICB0aW1lWm9uZTogXCJVVENcIlxuICAgIH0pLmZvcm1hdChuKSwgeyB0ZXh0Q29sb3I6IGksIGJnQ29sb3I6IG8gfSA9IHRoaXMub3B0aW9ucywgYSA9IFwiZm9udC13ZWlnaHQ6IGJvbGQ7cGFkZGluZzogMCA1cHg7Ym9yZGVyLXJhZGl1czo1cHhcIjtcbiAgICBjb25zb2xlW3RdKFxuICAgICAgYCVjJHtyfSVjIC8gJWMke3RoaXMuc2NvcGV9YCxcbiAgICAgIGAke2F9O2JhY2tncm91bmQtY29sb3I6IGxpZ2h0Ymx1ZTtjb2xvcjpibGFja2AsXG4gICAgICBcIlwiLFxuICAgICAgYCR7YX07JHtpID8gYGNvbG9yOiR7aX07YCA6IFwiXCJ9JHtvID8gYGJhY2tncm91bmQtY29sb3I6JHtvfWAgOiBcIlwifWAsXG4gICAgICAuLi5zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUHJpbnRzIGVycm9yIG1lc3NhZ2UgaW50byBhIGNvbnNvbGUuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICBlcnJvciguLi50KSB7XG4gICAgdGhpcy5wcmludChcImVycm9yXCIsIC4uLnQpO1xuICB9XG4gIC8qKlxuICAgKiBQcmludHMgbG9nIG1lc3NhZ2UgaW50byBhIGNvbnNvbGUuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICBsb2coLi4udCkge1xuICAgIHRoaXMucHJpbnQoXCJsb2dcIiwgLi4udCk7XG4gIH1cbn1cbmNvbnN0IGl0ID0gbmV3IHBlKFwiU0RLXCIsIHtcbiAgYmdDb2xvcjogXCJmb3Jlc3RncmVlblwiLFxuICB0ZXh0Q29sb3I6IFwid2hpdGVcIlxufSk7XG5sZXQgWCA9ICExO1xuY29uc3QgYnQgPSAoeyBuYW1lOiBlLCBwYXlsb2FkOiB0IH0pID0+IHtcbiAgaXQubG9nKFwiRXZlbnQgcmVjZWl2ZWQ6XCIsIHQgPyB7IG5hbWU6IGUsIHBheWxvYWQ6IHQgfSA6IHsgbmFtZTogZSB9KTtcbn07XG5mdW5jdGlvbiB1ZShlKSB7XG4gIFggIT09IGUgJiYgKFggPSBlLCBlID8gaGUoYnQpIDogeHQoYnQpKTtcbn1cbmZ1bmN0aW9uIGxlKC4uLmUpIHtcbiAgWCAmJiBpdC5sb2coLi4uZSk7XG59XG5jbGFzcyBEIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgYyh0aGlzLCBcImxpc3RlbmVyc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSwgYyh0aGlzLCBcImxpc3RlbmVyc0NvdW50XCIsIDApLCBjKHRoaXMsIFwic3Vic2NyaWJlTGlzdGVuZXJzXCIsIFtdKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKSwgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjb3VudCBvZiBib3VuZCBsaXN0ZW5lcnMuXG4gICAqL1xuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzQ291bnQgKyB0aGlzLnN1YnNjcmliZUxpc3RlbmVycy5sZW5ndGg7XG4gIH1cbiAgZW1pdCh0LCAuLi5zKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMuZm9yRWFjaCgobikgPT4gbih7XG4gICAgICBldmVudDogdCxcbiAgICAgIGFyZ3M6IHNcbiAgICB9KSksICh0aGlzLmxpc3RlbmVycy5nZXQodCkgfHwgW10pLmZvckVhY2goKFtuLCByXSkgPT4ge1xuICAgICAgbiguLi5zKSwgciAmJiB0aGlzLm9mZih0LCBuKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBuZXcgZXZlbnQgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gb25jZSAtIHNob3VsZCBsaXN0ZW5lciBiZSBjYWxsZWQgb25seSBvbmNlLlxuICAgKiBAcmV0dXJucyBGdW5jdGlvbiB0byByZW1vdmUgYm91bmQgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBvbih0LCBzLCBuKSB7XG4gICAgbGV0IHIgPSB0aGlzLmxpc3RlbmVycy5nZXQodCk7XG4gICAgcmV0dXJuIHIgfHwgdGhpcy5saXN0ZW5lcnMuc2V0KHQsIHIgPSBbXSksIHIucHVzaChbcywgbl0pLCB0aGlzLmxpc3RlbmVyc0NvdW50ICs9IDEsICgpID0+IHRoaXMub2ZmKHQsIHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVyLiBJbiBjYXNlLCBzcGVjaWZpZWQgbGlzdGVuZXIgd2FzIGJvdW5kIHNldmVyYWwgdGltZXMsIGl0IHJlbW92ZXNcbiAgICogb25seSBhIHNpbmdsZSBvbmUuXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgb2ZmKHQsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy5saXN0ZW5lcnMuZ2V0KHQpIHx8IFtdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgbi5sZW5ndGg7IHIgKz0gMSlcbiAgICAgIGlmIChzID09PSBuW3JdWzBdKSB7XG4gICAgICAgIG4uc3BsaWNlKHIsIDEpLCB0aGlzLmxpc3RlbmVyc0NvdW50IC09IDE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBldmVudCBsaXN0ZW5lciBmb3IgYWxsIGV2ZW50cy5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gZXZlbnQgbGlzdGVuZXIuXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIHN1YnNjcmliZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlTGlzdGVuZXJzLnB1c2godCksICgpID0+IHRoaXMudW5zdWJzY3JpYmUodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZ2xvYmFsIGV2ZW50IGxpc3RlbmVyLiBJbiBjYXNlLCBzcGVjaWZpZWQgbGlzdGVuZXIgd2FzIGJvdW5kIHNldmVyYWwgdGltZXMsIGl0IHJlbW92ZXNcbiAgICogb25seSBhIHNpbmdsZSBvbmUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgdW5zdWJzY3JpYmUodCkge1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMubGVuZ3RoOyBzICs9IDEpXG4gICAgICBpZiAodGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnNbc10gPT09IHQpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMuc3BsaWNlKHMsIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHR0KGUsIHQsIHMpIHtcbiAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGUsIHQsIHMpLCAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCB0LCBzKTtcbn1cbmZ1bmN0aW9uIG90KC4uLmUpIHtcbiAgbGV0IHQgPSAhMTtcbiAgY29uc3QgcyA9IGUuZmxhdCgxKTtcbiAgcmV0dXJuIFtcbiAgICAobikgPT4gIXQgJiYgcy5wdXNoKG4pLFxuICAgICgpID0+IHtcbiAgICAgIHQgfHwgKHQgPSAhMCwgcy5mb3JFYWNoKChuKSA9PiBuKCkpKTtcbiAgICB9LFxuICAgIHRcbiAgXTtcbn1cbmNsYXNzIFcgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcihzLCB7IGNhdXNlOiBuIH0pLCB0aGlzLnR5cGUgPSB0LCBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVy5wcm90b3R5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBtKGUsIHQsIHMpIHtcbiAgcmV0dXJuIG5ldyBXKGUsIHQsIHMpO1xufVxuY29uc3QgZGUgPSBcIkVSUl9NRVRIT0RfVU5TVVBQT1JURURcIiwgX2UgPSBcIkVSUl9NRVRIT0RfUEFSQU1FVEVSX1VOU1VQUE9SVEVEXCIsIGdlID0gXCJFUlJfVU5LTk9XTl9FTlZcIiwgd2UgPSBcIkVSUl9JTlZPS0VfQ1VTVE9NX01FVEhPRF9SRVNQT05TRVwiLCBmZSA9IFwiRVJSX1RJTUVEX09VVFwiLCBtZSA9IFwiRVJSX1VORVhQRUNURURfVFlQRVwiLCBDdCA9IFwiRVJSX1BBUlNFXCIsIGJlID0gXCJFUlJfTkFWSUdBVElPTl9MSVNUX0VNUFRZXCIsIHZlID0gXCJFUlJfTkFWSUdBVElPTl9DVVJTT1JfSU5WQUxJRFwiLCBfbiA9IFwiRVJSX05BVklHQVRJT05fSVRFTV9JTlZBTElEXCIsIGduID0gXCJFUlJfU1NSX0lOSVRcIiwgeWUgPSBcIkVSUl9JTlZBTElEX1BBVEhfQkFTRVwiO1xuZnVuY3Rpb24gVCgpIHtcbiAgcmV0dXJuIG0obWUsIFwiVmFsdWUgaGFzIHVuZXhwZWN0ZWQgdHlwZVwiKTtcbn1cbmNsYXNzIEcge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgdGhpcy5wYXJzZXIgPSB0LCB0aGlzLmlzT3B0aW9uYWwgPSBzLCB0aGlzLnR5cGUgPSBuO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBwYXJzZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gcGFyc2UuXG4gICAqIEB0aHJvd3Mge1NES0Vycm9yfSBFUlJfUEFSU0VcbiAgICogQHNlZSBFUlJfUEFSU0VcbiAgICovXG4gIHBhcnNlKHQpIHtcbiAgICBpZiAoISh0aGlzLmlzT3B0aW9uYWwgJiYgdCA9PT0gdm9pZCAwKSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlcih0KTtcbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgdGhyb3cgbShcbiAgICAgICAgICBDdCxcbiAgICAgICAgICBgVW5hYmxlIHRvIHBhcnNlIHZhbHVlJHt0aGlzLnR5cGUgPyBgIGFzICR7dGhpcy50eXBlfWAgOiBcIlwifWAsXG4gICAgICAgICAgc1xuICAgICAgICApO1xuICAgICAgfVxuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3B0aW9uYWwgPSAhMCwgdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gQShlLCB0KSB7XG4gIHJldHVybiAoKSA9PiBuZXcgRyhlLCAhMSwgdCk7XG59XG5jb25zdCBFID0gQSgoZSkgPT4ge1xuICBpZiAodHlwZW9mIGUgPT0gXCJib29sZWFuXCIpXG4gICAgcmV0dXJuIGU7XG4gIGNvbnN0IHQgPSBTdHJpbmcoZSk7XG4gIGlmICh0ID09PSBcIjFcIiB8fCB0ID09PSBcInRydWVcIilcbiAgICByZXR1cm4gITA7XG4gIGlmICh0ID09PSBcIjBcIiB8fCB0ID09PSBcImZhbHNlXCIpXG4gICAgcmV0dXJuICExO1xuICB0aHJvdyBUKCk7XG59LCBcImJvb2xlYW5cIik7XG5mdW5jdGlvbiBTdChlLCB0KSB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChjb25zdCBuIGluIGUpIHtcbiAgICBjb25zdCByID0gZVtuXTtcbiAgICBpZiAoIXIpXG4gICAgICBjb250aW51ZTtcbiAgICBsZXQgaSwgbztcbiAgICBpZiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiIHx8IFwicGFyc2VcIiBpbiByKVxuICAgICAgaSA9IG4sIG8gPSB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByIDogci5wYXJzZS5iaW5kKHIpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgeyB0eXBlOiBhIH0gPSByO1xuICAgICAgaSA9IHIuZnJvbSB8fCBuLCBvID0gdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiID8gYSA6IGEucGFyc2UuYmluZChhKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGEgPSBvKHQoaSkpO1xuICAgICAgYSAhPT0gdm9pZCAwICYmIChzW25dID0gYSk7XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgdGhyb3cgbShDdCwgYFVuYWJsZSB0byBwYXJzZSBmaWVsZCBcIiR7bn1cImAsIGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIFR0KGUpIHtcbiAgbGV0IHQgPSBlO1xuICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IEpTT04ucGFyc2UodCkpLCB0eXBlb2YgdCAhPSBcIm9iamVjdFwiIHx8IHQgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBUKCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gdihlLCB0KSB7XG4gIHJldHVybiBuZXcgRygocykgPT4ge1xuICAgIGNvbnN0IG4gPSBUdChzKTtcbiAgICByZXR1cm4gU3QoZSwgKHIpID0+IG5bcl0pO1xuICB9LCAhMSwgdCk7XG59XG5jb25zdCB4ID0gQSgoZSkgPT4ge1xuICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZTtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCB0ID0gTnVtYmVyKGUpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHQpKVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgdGhyb3cgVCgpO1xufSwgXCJudW1iZXJcIiksIHUgPSBBKChlKSA9PiB7XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGUudG9TdHJpbmcoKTtcbiAgdGhyb3cgVCgpO1xufSwgXCJzdHJpbmdcIik7XG5mdW5jdGlvbiBBdChlKSB7XG4gIHJldHVybiB2KHtcbiAgICBldmVudFR5cGU6IHUoKSxcbiAgICBldmVudERhdGE6ICh0KSA9PiB0XG4gIH0pLnBhcnNlKGUpO1xufVxuZnVuY3Rpb24gRWUoKSB7XG4gIFtcIlRlbGVncmFtR2FtZVByb3h5X3JlY2VpdmVFdmVudFwiLCBcIlRlbGVncmFtR2FtZVByb3h5XCIsIFwiVGVsZWdyYW1cIl0uZm9yRWFjaCgoZSkgPT4ge1xuICAgIGRlbGV0ZSB3aW5kb3dbZV07XG4gIH0pO1xufVxuZnVuY3Rpb24gZXQoZSwgdCkge1xuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCB7XG4gICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IGUsIGV2ZW50RGF0YTogdCB9KSxcbiAgICAvLyBXZSBzcGVjaWZ5IHdpbmRvdy5wYXJlbnQgdG8gaW1pdGF0ZSB0aGUgY2FzZSwgdGhlIHBhcmVudCBpZnJhbWUgc2VudCB1cyB0aGlzIGV2ZW50LlxuICAgIHNvdXJjZTogd2luZG93LnBhcmVudFxuICB9KSk7XG59XG5mdW5jdGlvbiBQZSgpIHtcbiAgW1xuICAgIFtcIlRlbGVncmFtR2FtZVByb3h5X3JlY2VpdmVFdmVudFwiXSxcbiAgICAvLyBXaW5kb3dzIFBob25lLlxuICAgIFtcIlRlbGVncmFtR2FtZVByb3h5XCIsIFwicmVjZWl2ZUV2ZW50XCJdLFxuICAgIC8vIERlc2t0b3AuXG4gICAgW1wiVGVsZWdyYW1cIiwgXCJXZWJWaWV3XCIsIFwicmVjZWl2ZUV2ZW50XCJdXG4gICAgLy8gQW5kcm9pZCBhbmQgaU9TLlxuICBdLmZvckVhY2goKGUpID0+IHtcbiAgICBsZXQgdCA9IHdpbmRvdztcbiAgICBlLmZvckVhY2goKHMsIG4sIHIpID0+IHtcbiAgICAgIGlmIChuID09PSByLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdFtzXSA9IGV0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzIGluIHQgfHwgKHRbc10gPSB7fSksIHQgPSB0W3NdO1xuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IFJlID0ge1xuICBjbGlwYm9hcmRfdGV4dF9yZWNlaXZlZDogdih7XG4gICAgcmVxX2lkOiB1KCksXG4gICAgZGF0YTogKGUpID0+IGUgPT09IG51bGwgPyBlIDogdSgpLm9wdGlvbmFsKCkucGFyc2UoZSlcbiAgfSksXG4gIGN1c3RvbV9tZXRob2RfaW52b2tlZDogdih7XG4gICAgcmVxX2lkOiB1KCksXG4gICAgcmVzdWx0OiAoZSkgPT4gZSxcbiAgICBlcnJvcjogdSgpLm9wdGlvbmFsKClcbiAgfSksXG4gIHBvcHVwX2Nsb3NlZDoge1xuICAgIHBhcnNlKGUpIHtcbiAgICAgIHJldHVybiB2KHtcbiAgICAgICAgYnV0dG9uX2lkOiAodCkgPT4gdCA9PSBudWxsID8gdm9pZCAwIDogdSgpLnBhcnNlKHQpXG4gICAgICB9KS5wYXJzZShlID8/IHt9KTtcbiAgICB9XG4gIH0sXG4gIHZpZXdwb3J0X2NoYW5nZWQ6IHYoe1xuICAgIGhlaWdodDogeCgpLFxuICAgIHdpZHRoOiAoZSkgPT4gZSA9PSBudWxsID8gd2luZG93LmlubmVyV2lkdGggOiB4KCkucGFyc2UoZSksXG4gICAgaXNfc3RhdGVfc3RhYmxlOiBFKCksXG4gICAgaXNfZXhwYW5kZWQ6IEUoKVxuICB9KVxufTtcbmZ1bmN0aW9uIHhlKCkge1xuICBjb25zdCBlID0gbmV3IEQoKSwgdCA9IG5ldyBEKCk7XG4gIHQuc3Vic2NyaWJlKChuKSA9PiB7XG4gICAgZS5lbWl0KFwiZXZlbnRcIiwgeyBuYW1lOiBuLmV2ZW50LCBwYXlsb2FkOiBuLmFyZ3NbMF0gfSk7XG4gIH0pLCBQZSgpO1xuICBjb25zdCBbLCBzXSA9IG90KFxuICAgIC8vIERvbid0IGZvcmdldCB0byByZW1vdmUgY3JlYXRlZCBoYW5kbGVycy5cbiAgICBFZSxcbiAgICAvLyBBZGQgXCJyZXNpemVcIiBldmVudCBsaXN0ZW5lciB0byBtYWtlIHN1cmUsIHdlIGFsd2F5cyBoYXZlIGZyZXNoIHZpZXdwb3J0IGluZm9ybWF0aW9uLlxuICAgIC8vIERlc2t0b3AgdmVyc2lvbiBvZiBUZWxlZ3JhbSBpcyBzb21ldGltZXMgbm90IHNlbmRpbmcgdGhlIHZpZXdwb3J0X2NoYW5nZWRcbiAgICAvLyBldmVudC4gRm9yIGV4YW1wbGUsIHdoZW4gdGhlIE1haW5CdXR0b24gaXMgc2hvd24uIFRoYXQncyB3aHkgd2Ugc2hvdWxkXG4gICAgLy8gYWRkIG91ciBvd24gbGlzdGVuZXIgdG8gbWFrZSBzdXJlLCB2aWV3cG9ydCBpbmZvcm1hdGlvbiBpcyBhbHdheXMgZnJlc2guXG4gICAgLy8gSXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvdG1hLmpzL2lzc3Vlcy8xMFxuICAgIHR0KFwicmVzaXplXCIsICgpID0+IHtcbiAgICAgIHQuZW1pdChcInZpZXdwb3J0X2NoYW5nZWRcIiwge1xuICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICBpc19zdGF0ZV9zdGFibGU6ICEwLFxuICAgICAgICBpc19leHBhbmRlZDogITBcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIC8vIEFkZCBsaXN0ZW5lciwgd2hpY2ggaGFuZGxlcyBldmVudHMgc2VudCBmcm9tIHRoZSBUZWxlZ3JhbSB3ZWIgYXBwbGljYXRpb24gYW5kIGFsc28gZXZlbnRzXG4gICAgLy8gZ2VuZXJhdGVkIGJ5IHRoZSBsb2NhbCBlbWl0RXZlbnQgZnVuY3Rpb24uXG4gICAgdHQoXCJtZXNzYWdlXCIsIChuKSA9PiB7XG4gICAgICBpZiAobi5zb3VyY2UgIT09IHdpbmRvdy5wYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCByO1xuICAgICAgdHJ5IHtcbiAgICAgICAgciA9IEF0KG4uZGF0YSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBldmVudFR5cGU6IGksIGV2ZW50RGF0YTogbyB9ID0gciwgYSA9IFJlW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaCA9IGEgPyBhLnBhcnNlKG8pIDogbztcbiAgICAgICAgdC5lbWl0KC4uLmggPyBbaSwgaF0gOiBbaV0pO1xuICAgICAgfSBjYXRjaCAoaCkge1xuICAgICAgICBpdC5lcnJvcihcbiAgICAgICAgICBgQW4gZXJyb3Igb2NjdXJyZWQgcHJvY2Vzc2luZyB0aGUgXCIke2l9XCIgZXZlbnQgZnJvbSB0aGUgVGVsZWdyYW0gYXBwbGljYXRpb24uXG5QbGVhc2UsIGZpbGUgYW4gaXNzdWUgaGVyZTpcbmh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvdG1hLmpzL2lzc3Vlcy9uZXcvY2hvb3NlYCxcbiAgICAgICAgICByLFxuICAgICAgICAgIGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICAvLyBDbGVhciBlbWl0dGVycy5cbiAgICAoKSA9PiBlLmNsZWFyKCksXG4gICAgKCkgPT4gdC5jbGVhcigpXG4gICk7XG4gIHJldHVybiBbe1xuICAgIG9uOiB0Lm9uLmJpbmQodCksXG4gICAgb2ZmOiB0Lm9mZi5iaW5kKHQpLFxuICAgIHN1YnNjcmliZShuKSB7XG4gICAgICByZXR1cm4gZS5vbihcImV2ZW50XCIsIG4pO1xuICAgIH0sXG4gICAgdW5zdWJzY3JpYmUobikge1xuICAgICAgZS5vZmYoXCJldmVudFwiLCBuKTtcbiAgICB9LFxuICAgIGdldCBjb3VudCgpIHtcbiAgICAgIHJldHVybiB0LmNvdW50ICsgZS5jb3VudDtcbiAgICB9XG4gIH0sIHNdO1xufVxuY29uc3QgW0NlLCBTZV0gPSBSdChcbiAgKGUpID0+IHtcbiAgICBjb25zdCBbdCwgc10gPSB4ZSgpLCBuID0gdC5vZmYuYmluZCh0KTtcbiAgICByZXR1cm4gdC5vZmYgPSAociwgaSkgPT4ge1xuICAgICAgY29uc3QgeyBjb3VudDogbyB9ID0gdDtcbiAgICAgIG4ociwgaSksIG8gJiYgIXQuY291bnQgJiYgZSgpO1xuICAgIH0sIFt0LCBzXTtcbiAgfSxcbiAgKFssIGVdKSA9PiBlKClcbik7XG5mdW5jdGlvbiBqKCkge1xuICByZXR1cm4gQ2UoKVswXTtcbn1cbmZ1bmN0aW9uIHooZSwgdCkge1xuICBqKCkub2ZmKGUsIHQpO1xufVxuZnVuY3Rpb24geShlLCB0LCBzKSB7XG4gIHJldHVybiBqKCkub24oZSwgdCwgcyk7XG59XG5mdW5jdGlvbiBMKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShlKTtcbn1cbmZ1bmN0aW9uIFRlKGUsIHQpIHtcbiAgY29uc3QgcyA9IGUuc3BsaXQoXCIuXCIpLCBuID0gdC5zcGxpdChcIi5cIiksIHIgPSBNYXRoLm1heChzLmxlbmd0aCwgbi5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHI7IGkgKz0gMSkge1xuICAgIGNvbnN0IG8gPSBwYXJzZUludChzW2ldIHx8IFwiMFwiLCAxMCksIGEgPSBwYXJzZUludChuW2ldIHx8IFwiMFwiLCAxMCk7XG4gICAgaWYgKG8gIT09IGEpXG4gICAgICByZXR1cm4gbyA+IGEgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBmKGUsIHQpIHtcbiAgcmV0dXJuIFRlKGUsIHQpIDw9IDA7XG59XG5mdW5jdGlvbiBDKGUsIHQsIHMpIHtcbiAgaWYgKHR5cGVvZiBzID09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoZSA9PT0gXCJ3ZWJfYXBwX29wZW5fbGlua1wiKSB7XG4gICAgICBpZiAodCA9PT0gXCJ0cnlfaW5zdGFudF92aWV3XCIpXG4gICAgICAgIHJldHVybiBmKFwiNi40XCIsIHMpO1xuICAgICAgaWYgKHQgPT09IFwidHJ5X2Jyb3dzZXJcIilcbiAgICAgICAgcmV0dXJuIGYoXCI3LjZcIiwgcyk7XG4gICAgfVxuICAgIGlmIChlID09PSBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiICYmIHQgPT09IFwiY29sb3JcIilcbiAgICAgIHJldHVybiBmKFwiNi45XCIsIHMpO1xuICAgIGlmIChlID09PSBcIndlYl9hcHBfY2xvc2VcIiAmJiB0ID09PSBcInJldHVybl9iYWNrXCIpXG4gICAgICByZXR1cm4gZihcIjcuNlwiLCBzKTtcbiAgfVxuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX3RnX2xpbmtcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX2ludm9pY2VcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9zZXR1cF9iYWNrX2J1dHRvblwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3NldF9iYWNrZ3JvdW5kX2NvbG9yXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCI6XG4gICAgICByZXR1cm4gZihcIjYuMVwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX3BvcHVwXCI6XG4gICAgICByZXR1cm4gZihcIjYuMlwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9jbG9zZV9zY2FuX3FyX3BvcHVwXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfb3Blbl9zY2FuX3FyX3BvcHVwXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfcmVhZF90ZXh0X2Zyb21fY2xpcGJvYXJkXCI6XG4gICAgICByZXR1cm4gZihcIjYuNFwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9zd2l0Y2hfaW5saW5lX3F1ZXJ5XCI6XG4gICAgICByZXR1cm4gZihcIjYuN1wiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9pbnZva2VfY3VzdG9tX21ldGhvZFwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3JlcXVlc3Rfd3JpdGVfYWNjZXNzXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfcmVxdWVzdF9waG9uZVwiOlxuICAgICAgcmV0dXJuIGYoXCI2LjlcIiwgdCk7XG4gICAgY2FzZSBcIndlYl9hcHBfc2V0dXBfc2V0dGluZ3NfYnV0dG9uXCI6XG4gICAgICByZXR1cm4gZihcIjYuMTBcIiwgdCk7XG4gICAgY2FzZSBcIndlYl9hcHBfYmlvbWV0cnlfZ2V0X2luZm9cIjpcbiAgICBjYXNlIFwid2ViX2FwcF9iaW9tZXRyeV9vcGVuX3NldHRpbmdzXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfYmlvbWV0cnlfcmVxdWVzdF9hY2Nlc3NcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2F1dGhcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9iaW9tZXRyeV91cGRhdGVfdG9rZW5cIjpcbiAgICAgIHJldHVybiBmKFwiNy4yXCIsIHQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW1xuICAgICAgICBcImlmcmFtZV9yZWFkeVwiLFxuICAgICAgICBcImlmcmFtZV93aWxsX3JlbG9hZFwiLFxuICAgICAgICBcIndlYl9hcHBfY2xvc2VcIixcbiAgICAgICAgXCJ3ZWJfYXBwX2RhdGFfc2VuZFwiLFxuICAgICAgICBcIndlYl9hcHBfZXhwYW5kXCIsXG4gICAgICAgIFwid2ViX2FwcF9vcGVuX2xpbmtcIixcbiAgICAgICAgXCJ3ZWJfYXBwX3JlYWR5XCIsXG4gICAgICAgIFwid2ViX2FwcF9yZXF1ZXN0X3RoZW1lXCIsXG4gICAgICAgIFwid2ViX2FwcF9yZXF1ZXN0X3ZpZXdwb3J0XCIsXG4gICAgICAgIFwid2ViX2FwcF9zZXR1cF9tYWluX2J1dHRvblwiLFxuICAgICAgICBcIndlYl9hcHBfc2V0dXBfY2xvc2luZ19iZWhhdmlvclwiXG4gICAgICBdLmluY2x1ZGVzKGUpO1xuICB9XG59XG5mdW5jdGlvbiBJdChlKSB7XG4gIHJldHVybiBcImV4dGVybmFsXCIgaW4gZSAmJiBMKGUuZXh0ZXJuYWwpICYmIFwibm90aWZ5XCIgaW4gZS5leHRlcm5hbCAmJiB0eXBlb2YgZS5leHRlcm5hbC5ub3RpZnkgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24ga3QoZSkge1xuICByZXR1cm4gXCJUZWxlZ3JhbVdlYnZpZXdQcm94eVwiIGluIGUgJiYgTChlLlRlbGVncmFtV2Vidmlld1Byb3h5KSAmJiBcInBvc3RFdmVudFwiIGluIGUuVGVsZWdyYW1XZWJ2aWV3UHJveHkgJiYgdHlwZW9mIGUuVGVsZWdyYW1XZWJ2aWV3UHJveHkucG9zdEV2ZW50ID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGF0KCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5jb25zdCBBZSA9IFwiaHR0cHM6Ly93ZWIudGVsZWdyYW0ub3JnXCI7XG5sZXQgT3QgPSBBZTtcbmZ1bmN0aW9uIHduKGUpIHtcbiAgT3QgPSBlO1xufVxuZnVuY3Rpb24gSWUoKSB7XG4gIHJldHVybiBPdDtcbn1cbmZ1bmN0aW9uIFYoZSwgdCwgcykge1xuICBsZXQgbiA9IHt9LCByO1xuICBpZiAoIXQgJiYgIXMgPyBuID0ge30gOiB0ICYmIHMgPyAobiA9IHMsIHIgPSB0KSA6IHQgJiYgKFwidGFyZ2V0T3JpZ2luXCIgaW4gdCA/IG4gPSB0IDogciA9IHQpLCBsZShcIlBvc3RpbmcgZXZlbnQ6XCIsIHIgPyB7IGV2ZW50OiBlLCBkYXRhOiByIH0gOiB7IGV2ZW50OiBlIH0pLCBhdCgpKVxuICAgIHJldHVybiB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IGUsIGV2ZW50RGF0YTogciB9KSxcbiAgICAgIG4udGFyZ2V0T3JpZ2luIHx8IEllKClcbiAgICApO1xuICBpZiAoSXQod2luZG93KSkge1xuICAgIHdpbmRvdy5leHRlcm5hbC5ub3RpZnkoSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IGUsIGV2ZW50RGF0YTogciB9KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChrdCh3aW5kb3cpKSB7XG4gICAgd2luZG93LlRlbGVncmFtV2Vidmlld1Byb3h5LnBvc3RFdmVudChlLCBKU09OLnN0cmluZ2lmeShyKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG0oXG4gICAgZ2UsXG4gICAgXCJVbmFibGUgdG8gZGV0ZXJtaW5lIGN1cnJlbnQgZW52aXJvbm1lbnQgYW5kIHBvc3NpYmxlIHdheSB0byBzZW5kIGV2ZW50LiBZb3UgYXJlIHByb2JhYmx5IHRyeWluZyB0byB1c2UgTWluaSBBcHBzIG1ldGhvZCBvdXRzaWRlIHRoZSBUZWxlZ3JhbSBhcHBsaWNhdGlvbiBlbnZpcm9ubWVudC5cIlxuICApO1xufVxuZnVuY3Rpb24ga2UoZSkge1xuICByZXR1cm4gKHQsIHMpID0+IHtcbiAgICBpZiAoIUModCwgZSkpXG4gICAgICB0aHJvdyBtKGRlLCBgTWV0aG9kIFwiJHt0fVwiIGlzIHVuc3VwcG9ydGVkIGluIE1pbmkgQXBwcyB2ZXJzaW9uICR7ZX1gKTtcbiAgICBpZiAoTChzKSAmJiB0ID09PSBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiICYmIFwiY29sb3JcIiBpbiBzICYmICFDKHQsIFwiY29sb3JcIiwgZSkpXG4gICAgICB0aHJvdyBtKFxuICAgICAgICBfZSxcbiAgICAgICAgYFBhcmFtZXRlciBcImNvbG9yXCIgb2YgXCIke3R9XCIgbWV0aG9kIGlzIHVuc3VwcG9ydGVkIGluIE1pbmkgQXBwcyB2ZXJzaW9uICR7ZX1gXG4gICAgICApO1xuICAgIHJldHVybiBWKHQsIHMpO1xuICB9O1xufVxuZnVuY3Rpb24gcXQoZSkge1xuICByZXR1cm4gKHsgcmVxX2lkOiB0IH0pID0+IHQgPT09IGU7XG59XG5mdW5jdGlvbiBOdChlKSB7XG4gIHJldHVybiBtKGZlLCBgVGltZW91dCByZWFjaGVkOiAke2V9bXNgKTtcbn1cbmZ1bmN0aW9uIER0KGUsIHQpIHtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSgpIDogZSxcbiAgICBuZXcgUHJvbWlzZSgocywgbikgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4oTnQodCkpO1xuICAgICAgfSwgdCk7XG4gICAgfSlcbiAgXSk7XG59XG5hc3luYyBmdW5jdGlvbiBnKGUpIHtcbiAgbGV0IHQ7XG4gIGNvbnN0IHMgPSBuZXcgUHJvbWlzZSgoYSkgPT4gdCA9IGEpLCB7IGV2ZW50OiBuLCBjYXB0dXJlOiByLCB0aW1lb3V0OiBpIH0gPSBlLCBbLCBvXSA9IG90KFxuICAgIC8vIFdlIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIGFsbCB0cmFja2VkIGV2ZW50cywgYW5kIGNyZWF0ZSB0aGVpciBldmVudCBsaXN0ZW5lcnMuXG4gICAgKEFycmF5LmlzQXJyYXkobikgPyBuIDogW25dKS5tYXAoKGEpID0+IHkoYSwgKGgpID0+IHtcbiAgICAgICghciB8fCAoQXJyYXkuaXNBcnJheShuKSA/IHIoe1xuICAgICAgICBldmVudDogYSxcbiAgICAgICAgcGF5bG9hZDogaFxuICAgICAgfSkgOiByKGgpKSkgJiYgdChoKTtcbiAgICB9KSlcbiAgKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKGUucG9zdEV2ZW50IHx8IFYpKGUubWV0aG9kLCBlLnBhcmFtcyksIGF3YWl0IChpID8gRHQocywgaSkgOiBzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBvKCk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHEoZSwgdCwgcywgbiA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICByZXN1bHQ6IHIsXG4gICAgZXJyb3I6IGlcbiAgfSA9IGF3YWl0IGcoe1xuICAgIC4uLm4sXG4gICAgbWV0aG9kOiBcIndlYl9hcHBfaW52b2tlX2N1c3RvbV9tZXRob2RcIixcbiAgICBldmVudDogXCJjdXN0b21fbWV0aG9kX2ludm9rZWRcIixcbiAgICBwYXJhbXM6IHtcbiAgICAgIG1ldGhvZDogZSxcbiAgICAgIHBhcmFtczogdCxcbiAgICAgIHJlcV9pZDogc1xuICAgIH0sXG4gICAgY2FwdHVyZTogcXQocylcbiAgfSk7XG4gIGlmIChpKVxuICAgIHRocm93IG0od2UsIGkpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHN0KC4uLmUpIHtcbiAgcmV0dXJuIGUubWFwKCh0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdDtcbiAgICBpZiAoTCh0KSlcbiAgICAgIHJldHVybiBzdChPYmplY3QuZW50cmllcyh0KS5tYXAoKHMpID0+IHNbMV0gJiYgc1swXSkpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHQpKVxuICAgICAgcmV0dXJuIHN0KC4uLnQpO1xuICB9KS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiBmbiguLi5lKSB7XG4gIHJldHVybiBlLnJlZHVjZSgodCwgcykgPT4gKEwocykgJiYgT2JqZWN0LmVudHJpZXMocykuZm9yRWFjaCgoW24sIHJdKSA9PiB7XG4gICAgY29uc3QgaSA9IHN0KHRbbl0sIHIpO1xuICAgIGkubGVuZ3RoICYmICh0W25dID0gaSk7XG4gIH0pLCB0KSwge30pO1xufVxuZnVuY3Rpb24gY3QoZSkge1xuICByZXR1cm4gL14jW1xcZGEtZl17Nn0kL2kudGVzdChlKTtcbn1cbmZ1bmN0aW9uIE9lKGUpIHtcbiAgcmV0dXJuIC9eI1tcXGRhLWZdezN9JC9pLnRlc3QoZSk7XG59XG5mdW5jdGlvbiBWdChlKSB7XG4gIGNvbnN0IHQgPSBlLnJlcGxhY2UoL1xccy9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoY3QodCkpXG4gICAgcmV0dXJuIHQ7XG4gIGlmIChPZSh0KSkge1xuICAgIGxldCBuID0gXCIjXCI7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCAzOyByICs9IDEpXG4gICAgICBuICs9IHRbMSArIHJdLnJlcGVhdCgyKTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBjb25zdCBzID0gdC5tYXRjaCgvXnJnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpJC8pIHx8IHQubWF0Y2goL15yZ2JhXFwoKFxcZHsxLDN9KSwoXFxkezEsM30pLChcXGR7MSwzfSksXFxkezEsM31cXCkkLyk7XG4gIGlmICghcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIFwiJHtlfVwiIGRvZXMgbm90IHNhdGlzZnkgYW55IG9mIGtub3duIFJHQiBmb3JtYXRzLmApO1xuICByZXR1cm4gcy5zbGljZSgxKS5yZWR1Y2UoKG4sIHIpID0+IHtcbiAgICBjb25zdCBpID0gcGFyc2VJbnQociwgMTApLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gbiArIChpLmxlbmd0aCA9PT0gMSA/IFwiMFwiIDogXCJcIikgKyBpO1xuICB9LCBcIiNcIik7XG59XG5mdW5jdGlvbiBCdChlKSB7XG4gIGNvbnN0IHQgPSBWdChlKTtcbiAgcmV0dXJuIE1hdGguc3FydChcbiAgICBbMC4yOTksIDAuNTg3LCAwLjExNF0ucmVkdWNlKChzLCBuLCByKSA9PiB7XG4gICAgICBjb25zdCBpID0gcGFyc2VJbnQodC5zbGljZSgxICsgciAqIDIsIDEgKyAociArIDEpICogMiksIDE2KTtcbiAgICAgIHJldHVybiBzICsgaSAqIGkgKiBuO1xuICAgIH0sIDApXG4gICkgPCAxMjA7XG59XG5jbGFzcyBxZSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBjKHRoaXMsIFwiZWVcIiwgbmV3IEQoKSksIGModGhpcywgXCJvblwiLCB0aGlzLmVlLm9uLmJpbmQodGhpcy5lZSkpLCBjKHRoaXMsIFwib2ZmXCIsIHRoaXMuZWUub2ZmLmJpbmQodGhpcy5lZSkpLCB0aGlzLnN0YXRlID0gdDtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIGN1cnJlbnQgc3RhdGUgYW5kIHJldHVybnMgaXRzIGNvcHkuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLnN0YXRlIH07XG4gIH1cbiAgc2V0KHQsIHMpIHtcbiAgICBPYmplY3QuZW50cmllcyh0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8geyBbdF06IHMgfSA6IHQpLnJlZHVjZSgobiwgW3IsIGldKSA9PiB0aGlzLnN0YXRlW3JdID09PSBpIHx8IGkgPT09IHZvaWQgMCA/IG4gOiAodGhpcy5zdGF0ZVtyXSA9IGksIHRoaXMuZWUuZW1pdChgY2hhbmdlOiR7cn1gLCBpKSwgITApLCAhMSkgJiYgdGhpcy5lZS5lbWl0KFwiY2hhbmdlXCIsIHRoaXMuc3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHZhbHVlIGJ5IHNwZWNpZmllZCBrZXkuXG4gICAqIEBwYXJhbSBrZXkgLSBzdGF0ZSBrZXkuXG4gICAqL1xuICBnZXQodCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlW3RdO1xuICB9XG59XG5jbGFzcyBodCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBjKHRoaXMsIFwic3RhdGVcIiksIGModGhpcywgXCJnZXRcIiksIGModGhpcywgXCJzZXRcIiksIGModGhpcywgXCJjbG9uZVwiKSwgdGhpcy5zdGF0ZSA9IG5ldyBxZSh0KSwgdGhpcy5zZXQgPSB0aGlzLnN0YXRlLnNldC5iaW5kKHRoaXMuc3RhdGUpLCB0aGlzLmdldCA9IHRoaXMuc3RhdGUuZ2V0LmJpbmQodGhpcy5zdGF0ZSksIHRoaXMuY2xvbmUgPSB0aGlzLnN0YXRlLmNsb25lLmJpbmQodGhpcy5zdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIE10KGUsIHQpIHtcbiAgcmV0dXJuIChzKSA9PiBDKHRbc10sIGUpO1xufVxuY2xhc3MgcHQgZXh0ZW5kcyBodCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih0KSwgYyh0aGlzLCBcInN1cHBvcnRzXCIpLCB0aGlzLnN1cHBvcnRzID0gTXQocywgbik7XG4gIH1cbn1cbmNsYXNzIE5lIGV4dGVuZHMgcHQge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgc3VwZXIoeyBpc1Zpc2libGU6IHQgfSwgcywge1xuICAgICAgc2hvdzogXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCIsXG4gICAgICBoaWRlOiBcIndlYl9hcHBfc2V0dXBfYmFja19idXR0b25cIlxuICAgIH0pLCBjKHRoaXMsIFwib25cIiwgKHIsIGkpID0+IHIgPT09IFwiY2xpY2tcIiA/IHkoXCJiYWNrX2J1dHRvbl9wcmVzc2VkXCIsIGkpIDogdGhpcy5zdGF0ZS5vbihyLCBpKSksIGModGhpcywgXCJvZmZcIiwgKHIsIGkpID0+IHIgPT09IFwiY2xpY2tcIiA/IHooXCJiYWNrX2J1dHRvbl9wcmVzc2VkXCIsIGkpIDogdGhpcy5zdGF0ZS5vZmYociwgaSkpLCB0aGlzLnBvc3RFdmVudCA9IG47XG4gIH1cbiAgc2V0IGlzVmlzaWJsZSh0KSB7XG4gICAgdGhpcy5zZXQoXCJpc1Zpc2libGVcIiwgdCksIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXR1cF9iYWNrX2J1dHRvblwiLCB7IGlzX3Zpc2libGU6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgQmFja0J1dHRvbiBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICovXG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaXNWaXNpYmxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgQmFja0J1dHRvbi5cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5pc1Zpc2libGUgPSAhMTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgdGhlIEJhY2tCdXR0b24uXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMuaXNWaXNpYmxlID0gITA7XG4gIH1cbn1cbmNvbnN0IEx0ID0gQSgoZSkgPT4gZSBpbnN0YW5jZW9mIERhdGUgPyBlIDogbmV3IERhdGUoeCgpLnBhcnNlKGUpICogMWUzKSwgXCJEYXRlXCIpO1xuZnVuY3Rpb24gdXQoZSwgdCkge1xuICByZXR1cm4gbmV3IEcoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT0gXCJzdHJpbmdcIiAmJiAhKHMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpKVxuICAgICAgdGhyb3cgVCgpO1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gbmV3IFVSTFNlYXJjaFBhcmFtcyhzKSA6IHM7XG4gICAgcmV0dXJuIFN0KGUsIChyKSA9PiB7XG4gICAgICBjb25zdCBpID0gbi5nZXQocik7XG4gICAgICByZXR1cm4gaSA9PT0gbnVsbCA/IHZvaWQgMCA6IGk7XG4gICAgfSk7XG4gIH0sICExLCB0KTtcbn1cbmNvbnN0IERlID0gdih7XG4gIGlkOiB4KCksXG4gIHR5cGU6IHUoKSxcbiAgdGl0bGU6IHUoKSxcbiAgcGhvdG9Vcmw6IHtcbiAgICB0eXBlOiB1KCkub3B0aW9uYWwoKSxcbiAgICBmcm9tOiBcInBob3RvX3VybFwiXG4gIH0sXG4gIHVzZXJuYW1lOiB1KCkub3B0aW9uYWwoKVxufSwgXCJDaGF0XCIpLm9wdGlvbmFsKCksIHZ0ID0gdih7XG4gIGFkZGVkVG9BdHRhY2htZW50TWVudToge1xuICAgIHR5cGU6IEUoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwiYWRkZWRfdG9fYXR0YWNobWVudF9tZW51XCJcbiAgfSxcbiAgYWxsb3dzV3JpdGVUb1BtOiB7XG4gICAgdHlwZTogRSgpLm9wdGlvbmFsKCksXG4gICAgZnJvbTogXCJhbGxvd3Nfd3JpdGVfdG9fcG1cIlxuICB9LFxuICBmaXJzdE5hbWU6IHtcbiAgICB0eXBlOiB1KCksXG4gICAgZnJvbTogXCJmaXJzdF9uYW1lXCJcbiAgfSxcbiAgaWQ6IHgoKSxcbiAgaXNCb3Q6IHtcbiAgICB0eXBlOiBFKCkub3B0aW9uYWwoKSxcbiAgICBmcm9tOiBcImlzX2JvdFwiXG4gIH0sXG4gIGlzUHJlbWl1bToge1xuICAgIHR5cGU6IEUoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwiaXNfcHJlbWl1bVwiXG4gIH0sXG4gIGxhbmd1YWdlQ29kZToge1xuICAgIHR5cGU6IHUoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwibGFuZ3VhZ2VfY29kZVwiXG4gIH0sXG4gIGxhc3ROYW1lOiB7XG4gICAgdHlwZTogdSgpLm9wdGlvbmFsKCksXG4gICAgZnJvbTogXCJsYXN0X25hbWVcIlxuICB9LFxuICBwaG90b1VybDoge1xuICAgIHR5cGU6IHUoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwicGhvdG9fdXJsXCJcbiAgfSxcbiAgdXNlcm5hbWU6IHUoKS5vcHRpb25hbCgpXG59LCBcIlVzZXJcIikub3B0aW9uYWwoKTtcbmZ1bmN0aW9uICR0KCkge1xuICByZXR1cm4gdXQoe1xuICAgIGF1dGhEYXRlOiB7XG4gICAgICB0eXBlOiBMdCgpLFxuICAgICAgZnJvbTogXCJhdXRoX2RhdGVcIlxuICAgIH0sXG4gICAgY2FuU2VuZEFmdGVyOiB7XG4gICAgICB0eXBlOiB4KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwiY2FuX3NlbmRfYWZ0ZXJcIlxuICAgIH0sXG4gICAgY2hhdDogRGUsXG4gICAgY2hhdEluc3RhbmNlOiB7XG4gICAgICB0eXBlOiB1KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwiY2hhdF9pbnN0YW5jZVwiXG4gICAgfSxcbiAgICBjaGF0VHlwZToge1xuICAgICAgdHlwZTogdSgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcImNoYXRfdHlwZVwiXG4gICAgfSxcbiAgICBoYXNoOiB1KCksXG4gICAgcXVlcnlJZDoge1xuICAgICAgdHlwZTogdSgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInF1ZXJ5X2lkXCJcbiAgICB9LFxuICAgIHJlY2VpdmVyOiB2dCxcbiAgICBzdGFydFBhcmFtOiB7XG4gICAgICB0eXBlOiB1KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwic3RhcnRfcGFyYW1cIlxuICAgIH0sXG4gICAgdXNlcjogdnRcbiAgfSwgXCJJbml0RGF0YVwiKTtcbn1cbmNvbnN0IFZlID0gQSgoZSkgPT4gVnQodSgpLnBhcnNlKGUpKSwgXCJyZ2JcIik7XG5mdW5jdGlvbiBCZShlKSB7XG4gIHJldHVybiBlLnJlcGxhY2UoL19bYS16XS9nLCAodCkgPT4gdFsxXS50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIE1lKGUpIHtcbiAgcmV0dXJuIGUucmVwbGFjZSgvW0EtWl0vZywgKHQpID0+IGBfJHt0LnRvTG93ZXJDYXNlKCl9YCk7XG59XG5jb25zdCBIdCA9IEEoXG4gIChlKSA9PiB7XG4gICAgY29uc3QgdCA9IFZlKCkub3B0aW9uYWwoKTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoVHQoZSkpLnJlZHVjZSgocywgW24sIHJdKSA9PiAoc1tCZShuKV0gPSB0LnBhcnNlKHIpLCBzKSwge30pO1xuICB9LFxuICBcIlRoZW1lUGFyYW1zXCJcbik7XG5mdW5jdGlvbiBsdChlKSB7XG4gIHJldHVybiB1dCh7XG4gICAgYm90SW5saW5lOiB7XG4gICAgICB0eXBlOiBFKCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBCb3RJbmxpbmVcIlxuICAgIH0sXG4gICAgaW5pdERhdGE6IHtcbiAgICAgIHR5cGU6ICR0KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBEYXRhXCJcbiAgICB9LFxuICAgIGluaXREYXRhUmF3OiB7XG4gICAgICB0eXBlOiB1KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBEYXRhXCJcbiAgICB9LFxuICAgIHBsYXRmb3JtOiB7XG4gICAgICB0eXBlOiB1KCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwUGxhdGZvcm1cIlxuICAgIH0sXG4gICAgc2hvd1NldHRpbmdzOiB7XG4gICAgICB0eXBlOiBFKCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBTaG93U2V0dGluZ3NcIlxuICAgIH0sXG4gICAgc3RhcnRQYXJhbToge1xuICAgICAgdHlwZTogdSgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwU3RhcnRQYXJhbVwiXG4gICAgfSxcbiAgICB0aGVtZVBhcmFtczoge1xuICAgICAgdHlwZTogSHQoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBUaGVtZVBhcmFtc1wiXG4gICAgfSxcbiAgICB2ZXJzaW9uOiB7XG4gICAgICB0eXBlOiB1KCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwVmVyc2lvblwiXG4gICAgfVxuICB9KS5wYXJzZShlKTtcbn1cbmZ1bmN0aW9uIFV0KGUpIHtcbiAgcmV0dXJuIGx0KFxuICAgIGUucmVwbGFjZSgvXltePyNdKls/I10vLCBcIlwiKS5yZXBsYWNlKC9bPyNdL2csIFwiJlwiKVxuICApO1xufVxuZnVuY3Rpb24gTGUoKSB7XG4gIHJldHVybiBVdCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG59XG5mdW5jdGlvbiBXdCgpIHtcbiAgcmV0dXJuIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoXCJuYXZpZ2F0aW9uXCIpWzBdO1xufVxuZnVuY3Rpb24gJGUoKSB7XG4gIGNvbnN0IGUgPSBXdCgpO1xuICBpZiAoIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdldCBmaXJzdCBuYXZpZ2F0aW9uIGVudHJ5LlwiKTtcbiAgcmV0dXJuIFV0KGUubmFtZSk7XG59XG5mdW5jdGlvbiBHdChlKSB7XG4gIHJldHVybiBgdG1hLmpzLyR7ZS5yZXBsYWNlKC9bQS1aXS9nLCAodCkgPT4gYC0ke3QudG9Mb3dlckNhc2UoKX1gKX1gO1xufVxuZnVuY3Rpb24ganQoZSwgdCkge1xuICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKEd0KGUpLCBKU09OLnN0cmluZ2lmeSh0KSk7XG59XG5mdW5jdGlvbiB6dChlKSB7XG4gIGNvbnN0IHQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKEd0KGUpKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdCA/IEpTT04ucGFyc2UodCkgOiB2b2lkIDA7XG4gIH0gY2F0Y2gge1xuICB9XG59XG5mdW5jdGlvbiBIZSgpIHtcbiAgcmV0dXJuIGx0KHp0KFwibGF1bmNoUGFyYW1zXCIpIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gS3QoZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMoZSkubWFwKChbdCwgc10pID0+IFtNZSh0KSwgc10pXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gVWUoZSkge1xuICBjb25zdCB7XG4gICAgaW5pdERhdGFSYXc6IHQsXG4gICAgdGhlbWVQYXJhbXM6IHMsXG4gICAgcGxhdGZvcm06IG4sXG4gICAgdmVyc2lvbjogcixcbiAgICBzaG93U2V0dGluZ3M6IGksXG4gICAgc3RhcnRQYXJhbTogbyxcbiAgICBib3RJbmxpbmU6IGFcbiAgfSA9IGUsIGggPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIHJldHVybiBoLnNldChcInRnV2ViQXBwUGxhdGZvcm1cIiwgbiksIGguc2V0KFwidGdXZWJBcHBUaGVtZVBhcmFtc1wiLCBLdChzKSksIGguc2V0KFwidGdXZWJBcHBWZXJzaW9uXCIsIHIpLCB0ICYmIGguc2V0KFwidGdXZWJBcHBEYXRhXCIsIHQpLCBvICYmIGguc2V0KFwidGdXZWJBcHBTdGFydFBhcmFtXCIsIG8pLCB0eXBlb2YgaSA9PSBcImJvb2xlYW5cIiAmJiBoLnNldChcInRnV2ViQXBwU2hvd1NldHRpbmdzXCIsIGkgPyBcIjFcIiA6IFwiMFwiKSwgdHlwZW9mIGEgPT0gXCJib29sZWFuXCIgJiYgaC5zZXQoXCJ0Z1dlYkFwcEJvdElubGluZVwiLCBhID8gXCIxXCIgOiBcIjBcIiksIGgudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIEp0KGUpIHtcbiAganQoXCJsYXVuY2hQYXJhbXNcIiwgVWUoZSkpO1xufVxuZnVuY3Rpb24gbnQoKSB7XG4gIGZvciAoY29uc3QgZSBvZiBbXG4gICAgLy8gVHJ5IHRvIHJldHJpZXZlIGxhdW5jaCBwYXJhbWV0ZXJzIGZyb20gdGhlIGN1cnJlbnQgbG9jYXRpb24uIFRoaXMgbWV0aG9kIGNhbiByZXR1cm5cbiAgICAvLyBub3RoaW5nIGluIGNhc2UsIGxvY2F0aW9uIHdhcyBjaGFuZ2VkIGFuZCB0aGVuIHBhZ2Ugd2FzIHJlbG9hZGVkLlxuICAgIExlLFxuICAgIC8vIFRoZW4sIHRyeSB1c2luZyB0aGUgbG93ZXIgbGV2ZWwgQVBJIC0gd2luZG93LnBlcmZvcm1hbmNlLlxuICAgICRlLFxuICAgIC8vIEZpbmFsbHksIHRyeSB0byBleHRyYWN0IGxhdW5jaCBwYXJhbWV0ZXJzIGZyb20gdGhlIHNlc3Npb24gc3RvcmFnZS5cbiAgICBIZVxuICBdKVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ID0gZSgpO1xuICAgICAgcmV0dXJuIEp0KHQpLCB0O1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJldHJpZXZlIGxhdW5jaCBwYXJhbWV0ZXJzIGZyb20gYW55IGtub3duIHNvdXJjZS5cIik7XG59XG5mdW5jdGlvbiBGdCgpIHtcbiAgY29uc3QgZSA9IFd0KCk7XG4gIHJldHVybiAhIShlICYmIGUudHlwZSA9PT0gXCJyZWxvYWRcIik7XG59XG5mdW5jdGlvbiBXZSgpIHtcbiAgbGV0IGUgPSAwO1xuICByZXR1cm4gKCkgPT4gKGUgKz0gMSkudG9TdHJpbmcoKTtcbn1cbmNvbnN0IFtHZV0gPSBSdChXZSk7XG5mdW5jdGlvbiBsKGUsIHQpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBzID0gbnQoKSwgbiA9IHtcbiAgICAgIC4uLnMsXG4gICAgICBwb3N0RXZlbnQ6IGtlKHMudmVyc2lvbiksXG4gICAgICBjcmVhdGVSZXF1ZXN0SWQ6IEdlKClcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gZShuKTtcbiAgICBjb25zdCBbciwgaSwgb10gPSBvdCgpLCBhID0gdCh7XG4gICAgICAuLi5uLFxuICAgICAgLy8gU3RhdGUgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIG9ubHkgaW4gY2FzZSwgY3VycmVudCBwYWdlIHdhcyByZWxvYWRlZC4gSWYgd2UgZG9uJ3QgYWRkXG4gICAgICAvLyB0aGlzIGNoZWNrLCBzdGF0ZSByZXN0b3JhdGlvbiB3aWxsIHdvcmsgaW1wcm9wZXJseSBpbiB0aGUgd2ViIHZlcnNpb24gb2YgVGVsZWdyYW0sXG4gICAgICAvLyB3aGVuIHdlIGFyZSBhbHdheXMgd29ya2luZyBpbiB0aGUgc2FtZSBcInNlc3Npb25cIiAodGFiKS5cbiAgICAgIHN0YXRlOiBGdCgpID8genQoZSkgOiB2b2lkIDAsXG4gICAgICBhZGRDbGVhbnVwOiByXG4gICAgfSksIGggPSAocCkgPT4gKG8gfHwgcihcbiAgICAgIHAub24oXCJjaGFuZ2VcIiwgKFMpID0+IHtcbiAgICAgICAganQoZSwgUyk7XG4gICAgICB9KVxuICAgICksIHApO1xuICAgIHJldHVybiBbXG4gICAgICBhIGluc3RhbmNlb2YgUHJvbWlzZSA/IGEudGhlbihoKSA6IGgoYSksXG4gICAgICBpXG4gICAgXTtcbiAgfTtcbn1cbmNvbnN0IGplID0gbChcImJhY2tCdXR0b25cIiwgKHtcbiAgcG9zdEV2ZW50OiBlLFxuICB2ZXJzaW9uOiB0LFxuICBzdGF0ZTogcyA9IHsgaXNWaXNpYmxlOiAhMSB9XG59KSA9PiBuZXcgTmUocy5pc1Zpc2libGUsIHQsIGUpKTtcbmNsYXNzICQgZXh0ZW5kcyBwdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIGModGhpcywgXCJvblwiLCB0aGlzLnN0YXRlLm9uLmJpbmQodGhpcy5zdGF0ZSkpLCBjKHRoaXMsIFwib2ZmXCIsIHRoaXMuc3RhdGUub2ZmLmJpbmQodGhpcy5zdGF0ZSkpO1xuICB9XG59XG5mdW5jdGlvbiBRdChlKSB7XG4gIGNvbnN0IHQgPSBlLmF2YWlsYWJsZSA/IGUgOiB7XG4gICAgYXZhaWxhYmxlOiAhMSxcbiAgICBkZXZpY2VfaWQ6IFwiXCIsXG4gICAgdG9rZW5fc2F2ZWQ6ICExLFxuICAgIGFjY2Vzc19yZXF1ZXN0ZWQ6ICExLFxuICAgIGFjY2Vzc19ncmFudGVkOiAhMSxcbiAgICB0eXBlOiBcIlwiXG4gIH07XG4gIHJldHVybiB7XG4gICAgYXZhaWxhYmxlOiAhMCxcbiAgICB0eXBlOiB0LnR5cGUsXG4gICAgZGV2aWNlSWQ6IHQuZGV2aWNlX2lkLFxuICAgIHRva2VuU2F2ZWQ6IHQudG9rZW5fc2F2ZWQsXG4gICAgYWNjZXNzUmVxdWVzdGVkOiB0LmFjY2Vzc19yZXF1ZXN0ZWQsXG4gICAgYWNjZXNzR3JhbnRlZDogdC5hY2Nlc3NfZ3JhbnRlZFxuICB9O1xufVxuY2xhc3MgemUgZXh0ZW5kcyAkIHtcbiAgY29uc3RydWN0b3IoeyBwb3N0RXZlbnQ6IHQsIHZlcnNpb246IHMsIC4uLm4gfSkge1xuICAgIHN1cGVyKG4sIHMsIHtcbiAgICAgIGF1dGg6IFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2F1dGhcIixcbiAgICAgIG9wZW5TZXR0aW5nczogXCJ3ZWJfYXBwX2Jpb21ldHJ5X29wZW5fc2V0dGluZ3NcIixcbiAgICAgIHJlcXVlc3RBY2Nlc3M6IFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2FjY2Vzc1wiLFxuICAgICAgdXBkYXRlVG9rZW46IFwid2ViX2FwcF9iaW9tZXRyeV91cGRhdGVfdG9rZW5cIlxuICAgIH0pLCBjKHRoaXMsIFwicG9zdEV2ZW50XCIpLCBjKHRoaXMsIFwiYXV0aFByb21pc2VcIiksIGModGhpcywgXCJhY2Nlc3NQcm9taXNlXCIpLCB0aGlzLnBvc3RFdmVudCA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHdoZXRoZXIgYmlvbWV0cnkgaXMgYXZhaWxhYmxlLlxuICAgKi9cbiAgZ2V0IGF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJhdmFpbGFibGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHdoZXRoZXIgcGVybWlzc2lvbiB0byB1c2UgYmlvbWV0cmljcyBoYXMgYmVlbiBncmFudGVkLlxuICAgKi9cbiAgZ2V0IGFjY2Vzc0dyYW50ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYWNjZXNzR3JhbnRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3Mgd2hldGhlciBpZiBwZXJtaXNzaW9uIHRvIHVzZSBiaW9tZXRyaWNzIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIGdldCBhY2Nlc3NSZXF1ZXN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYWNjZXNzUmVxdWVzdGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGVzIHRoZSB1c2VyIHVzaW5nIGJpb21ldHJpY3MuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gbWV0aG9kIG9wdGlvbnMuXG4gICAqIEBzaW5jZSA3LjJcbiAgICogQHJldHVybnMgVG9rZW4gZnJvbSB0aGUgbG9jYWwgc2VjdXJlIHN0b3JhZ2UsIGlmIGF1dGhlbnRpY2F0aW9uIHdhcyBzdWNjZXNzZnVsLlxuICAgKi9cbiAgYXN5bmMgYXV0aGVudGljYXRlKHtcbiAgICByZWFzb246IHQsXG4gICAgLi4uc1xuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aFByb21pc2UgfHwgKHRoaXMuYXV0aFByb21pc2UgPSBnKHtcbiAgICAgIC4uLnMsXG4gICAgICBtZXRob2Q6IFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2F1dGhcIixcbiAgICAgIGV2ZW50OiBcImJpb21ldHJ5X2F1dGhfcmVxdWVzdGVkXCIsXG4gICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHJlYXNvbiBpcyBlbXB0eSB3b3JrcyBmaW5lLlxuICAgICAgICByZWFzb246ICh0IHx8IFwiXCIpLnRyaW0oKVxuICAgICAgfVxuICAgIH0pLnRoZW4oKHsgdG9rZW46IG4gfSkgPT4gbikuZmluYWxseSgoKSA9PiB0aGlzLmF1dGhQcm9taXNlID0gdm9pZCAwKSksIHRoaXMuYXV0aFByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGRldmljZSBpZGVudGlmaWVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWF0Y2ggdGhlIHRva2VuIHRvIHRoZSBkZXZpY2UuXG4gICAqL1xuICBnZXQgZGV2aWNlSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiZGV2aWNlSWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBiaW9tZXRyaWMgYWNjZXNzIHNldHRpbmdzIGZvciBib3RzLiBVc2VmdWwgd2hlbiB5b3UgbmVlZCB0byByZXF1ZXN0IGJpb21ldHJpY3NcbiAgICogYWNjZXNzIHRvIHVzZXJzIHdobyBoYXZlbid0IGdyYW50ZWQgaXQgeWV0LlxuICAgKlxuICAgKiBfTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgb25seSBpbiByZXNwb25zZSB0byB1c2VyIGludGVyYWN0aW9uIHdpdGggdGhlIE1pbmkgQXBwXG4gICAqIGludGVyZmFjZSAoZS5nLiBhIGNsaWNrIGluc2lkZSB0aGUgTWluaSBBcHAgb3Igb24gdGhlIG1haW4gYnV0dG9uKV8uXG4gICAqIEBzaW5jZSA3LjJcbiAgICovXG4gIG9wZW5TZXR0aW5ncygpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfYmlvbWV0cnlfb3Blbl9zZXR0aW5nc1wiKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgcGVybWlzc2lvbiB0byB1c2UgYmlvbWV0cmljcy5cbiAgICogQHNpbmNlIDcuMlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdHJ1ZSwgaWYgYWNjZXNzIHdhcyBncmFudGVkLlxuICAgKi9cbiAgcmVxdWVzdEFjY2Vzcyh7IHJlYXNvbjogdCwgLi4ucyB9ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5hY2Nlc3NQcm9taXNlIHx8ICh0aGlzLmFjY2Vzc1Byb21pc2UgPSBnKHtcbiAgICAgIC4uLnMsXG4gICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgbWV0aG9kOiBcIndlYl9hcHBfYmlvbWV0cnlfcmVxdWVzdF9hY2Nlc3NcIixcbiAgICAgIGV2ZW50OiBcImJpb21ldHJ5X2luZm9fcmVjZWl2ZWRcIixcbiAgICAgIHBhcmFtczogeyByZWFzb246IHQgfHwgXCJcIiB9XG4gICAgfSkudGhlbigobikgPT4ge1xuICAgICAgY29uc3QgciA9IFF0KG4pO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KHIpLCByLmFjY2Vzc0dyYW50ZWQ7XG4gICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLmFjY2Vzc1Byb21pc2UgPSB2b2lkIDApKSwgdGhpcy5hY2Nlc3NQcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBiaW9tZXRyaWNzIGN1cnJlbnRseSBhdmFpbGFibGUgb24gdGhlIGRldmljZS5cbiAgICovXG4gIGdldCBiaW9tZXRyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYmlvbWV0cnlUeXBlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB3aGV0aGVyIHRva2VuIHdhcyBzYXZlZCBwcmV2aW91c2x5IGluIHRoZSBsb2NhbCBzZWN1cmUgc3RvcmFnZS5cbiAgICovXG4gIGdldCB0b2tlblNhdmVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRva2VuU2F2ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGJpb21ldHJpYyB0b2tlbiBpbiBhIHNlY3VyZSBzdG9yYWdlIG9uIHRoZSBkZXZpY2UuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBgdHJ1ZWAsIGlmIHRva2VuIHdhcyB1cGRhdGVkLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVG9rZW4oeyB0b2tlbjogdCwgLi4ucyB9ID0ge30pIHtcbiAgICByZXR1cm4gW1wicmVtb3ZlZFwiLCBcInVwZGF0ZWRcIl0uaW5jbHVkZXMoXG4gICAgICAoYXdhaXQgZyh7XG4gICAgICAgIC4uLnMsXG4gICAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX2Jpb21ldHJ5X3VwZGF0ZV90b2tlblwiLFxuICAgICAgICBldmVudDogXCJiaW9tZXRyeV90b2tlbl91cGRhdGVkXCIsXG4gICAgICAgIHBhcmFtczogeyB0b2tlbjogdCB8fCBcIlwiIH1cbiAgICAgIH0pKS5zdGF0dXNcbiAgICApO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBLZShlKSB7XG4gIHJldHVybiBRdChcbiAgICBhd2FpdCBnKHtcbiAgICAgIC4uLmUgfHwge30sXG4gICAgICBtZXRob2Q6IFwid2ViX2FwcF9iaW9tZXRyeV9nZXRfaW5mb1wiLFxuICAgICAgZXZlbnQ6IFwiYmlvbWV0cnlfaW5mb19yZWNlaXZlZFwiXG4gICAgfSlcbiAgKTtcbn1cbmNvbnN0IEplID0gbChcbiAgXCJiaW9tZXRyeU1hbmFnZXJcIixcbiAgYXN5bmMgKHsgcG9zdEV2ZW50OiBlLCB2ZXJzaW9uOiB0LCBzdGF0ZTogcyB9KSA9PiBuZXcgemUoe1xuICAgIC4uLnMgfHwgQyhcIndlYl9hcHBfYmlvbWV0cnlfZ2V0X2luZm9cIiwgdCkgPyBzIHx8IGF3YWl0IEtlKHsgdGltZW91dDogMWUzIH0pIDoge1xuICAgICAgYXZhaWxhYmxlOiAhMSxcbiAgICAgIGFjY2Vzc0dyYW50ZWQ6ICExLFxuICAgICAgYWNjZXNzUmVxdWVzdGVkOiAhMSxcbiAgICAgIHRva2VuU2F2ZWQ6ICExLFxuICAgICAgZGV2aWNlSWQ6IFwiXCJcbiAgICB9LFxuICAgIHZlcnNpb246IHQsXG4gICAgcG9zdEV2ZW50OiBlXG4gIH0pXG4pO1xuY2xhc3MgZHQgZXh0ZW5kcyBodCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIGModGhpcywgXCJvblwiLCB0aGlzLnN0YXRlLm9uLmJpbmQodGhpcy5zdGF0ZSkpLCBjKHRoaXMsIFwib2ZmXCIsIHRoaXMuc3RhdGUub2ZmLmJpbmQodGhpcy5zdGF0ZSkpO1xuICB9XG59XG5jbGFzcyBGZSBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IodCwgcykge1xuICAgIHN1cGVyKHsgaXNDb25maXJtYXRpb25OZWVkZWQ6IHQgfSksIHRoaXMucG9zdEV2ZW50ID0gcztcbiAgfVxuICBzZXQgaXNDb25maXJtYXRpb25OZWVkZWQodCkge1xuICAgIHRoaXMuc2V0KFwiaXNDb25maXJtYXRpb25OZWVkZWRcIiwgdCksIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXR1cF9jbG9zaW5nX2JlaGF2aW9yXCIsIHsgbmVlZF9jb25maXJtYXRpb246IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUsIGlmIHRoZSBjb25maXJtYXRpb24gZGlhbG9nIHNob3VsZCBiZSBzaG93biB3aGlsZSB0aGUgdXNlciBpcyB0cnlpbmcgdG8gY2xvc2VcbiAgICogdGhlIE1pbmkgQXBwLlxuICAgKi9cbiAgZ2V0IGlzQ29uZmlybWF0aW9uTmVlZGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzQ29uZmlybWF0aW9uTmVlZGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgY29uZmlybWF0aW9uIGRpYWxvZyB3aGVuIGNsb3NpbmcgdGhlIE1pbmkgQXBwLlxuICAgKi9cbiAgZGlzYWJsZUNvbmZpcm1hdGlvbigpIHtcbiAgICB0aGlzLmlzQ29uZmlybWF0aW9uTmVlZGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIGNvbmZpcm1hdGlvbiBkaWFsb2cgd2hlbiBjbG9zaW5nIHRoZSBNaW5pIEFwcC5cbiAgICovXG4gIGVuYWJsZUNvbmZpcm1hdGlvbigpIHtcbiAgICB0aGlzLmlzQ29uZmlybWF0aW9uTmVlZGVkID0gITA7XG4gIH1cbn1cbmNvbnN0IFFlID0gbChcbiAgXCJjbG9zaW5nQmVoYXZpb3JcIixcbiAgKHtcbiAgICBwb3N0RXZlbnQ6IGUsXG4gICAgc3RhdGU6IHQgPSB7IGlzQ29uZmlybWF0aW9uTmVlZGVkOiAhMSB9XG4gIH0pID0+IG5ldyBGZSh0LmlzQ29uZmlybWF0aW9uTmVlZGVkLCBlKVxuKTtcbmNsYXNzIF90IHtcbiAgY29uc3RydWN0b3IodCwgcykge1xuICAgIGModGhpcywgXCJzdXBwb3J0c1wiKSwgdGhpcy5zdXBwb3J0cyA9IE10KHQsIHMpO1xuICB9XG59XG5mdW5jdGlvbiBZZShlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgIHJldHVybiBlO1xuICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IEpTT04ucGFyc2UoZSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSlcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB0aHJvdyBUKCk7XG59XG5jbGFzcyBaZSBleHRlbmRzIEcge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgc3VwZXIoWWUsIHMsIG4pLCBjKHRoaXMsIFwiaXRlbVBhcnNlclwiKSwgdGhpcy5pdGVtUGFyc2VyID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdCA6IHQucGFyc2UuYmluZCh0KTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcGFyc2UgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIHBhcnNlLlxuICAgKiBAdGhyb3dzIHtTREtFcnJvcn0gRVJSX1BBUlNFXG4gICAqIEBzZWUgRVJSX1BBUlNFXG4gICAqL1xuICBwYXJzZSh0KSB7XG4gICAgY29uc3QgcyA9IHN1cGVyLnBhcnNlKHQpO1xuICAgIHJldHVybiBzID09PSB2b2lkIDAgPyBzIDogcy5tYXAodGhpcy5pdGVtUGFyc2VyKTtcbiAgfVxuICBvZih0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbVBhcnNlciA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQgOiB0LnBhcnNlLmJpbmQodCksIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIFhlKGUpIHtcbiAgcmV0dXJuIG5ldyBaZSgodCkgPT4gdCwgITEsIGUpO1xufVxuZnVuY3Rpb24geXQoZSwgdCkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGUubWFwKChzKSA9PiBbcywgdF0pKTtcbn1cbmNsYXNzIHRzIGV4dGVuZHMgX3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgc3VwZXIodCwge1xuICAgICAgZGVsZXRlOiBcIndlYl9hcHBfaW52b2tlX2N1c3RvbV9tZXRob2RcIixcbiAgICAgIGdldDogXCJ3ZWJfYXBwX2ludm9rZV9jdXN0b21fbWV0aG9kXCIsXG4gICAgICBnZXRLZXlzOiBcIndlYl9hcHBfaW52b2tlX2N1c3RvbV9tZXRob2RcIixcbiAgICAgIHNldDogXCJ3ZWJfYXBwX2ludm9rZV9jdXN0b21fbWV0aG9kXCJcbiAgICB9KSwgdGhpcy5jcmVhdGVSZXF1ZXN0SWQgPSBzLCB0aGlzLnBvc3RFdmVudCA9IG47XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgc3BlY2lmaWVkIGtleSBvciBrZXlzIGZyb20gdGhlIGNsb3VkIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSBrZXlPcktleXMgLSBrZXkgb3Iga2V5cyB0byBkZWxldGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gcmVxdWVzdCBleGVjdXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZSh0LCBzID0ge30pIHtcbiAgICBjb25zdCBuID0gQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbdF07XG4gICAgbi5sZW5ndGggJiYgYXdhaXQgcShcbiAgICAgIFwiZGVsZXRlU3RvcmFnZVZhbHVlc1wiLFxuICAgICAgeyBrZXlzOiBuIH0sXG4gICAgICB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLFxuICAgICAgeyAuLi5zLCBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50IH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgYWxsIGtleXMgcHJlc2VudGVkIGluIHRoZSBjbG91ZCBzdG9yYWdlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHJlcXVlc3QgZXhlY3V0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBnZXRLZXlzKHQgPSB7fSkge1xuICAgIHJldHVybiBYZSgpLm9mKHUoKSkucGFyc2UoXG4gICAgICBhd2FpdCBxKFxuICAgICAgICBcImdldFN0b3JhZ2VLZXlzXCIsXG4gICAgICAgIHt9LFxuICAgICAgICB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLFxuICAgICAgICB7IC4uLnQsIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0KHQsIHMgPSB7fSkge1xuICAgIGNvbnN0IG4gPSBBcnJheS5pc0FycmF5KHQpID8gdCA6IFt0XTtcbiAgICBpZiAoIW4ubGVuZ3RoKVxuICAgICAgcmV0dXJuIHl0KG4sIFwiXCIpO1xuICAgIGNvbnN0IHIgPSBhd2FpdCBxKFxuICAgICAgXCJnZXRTdG9yYWdlVmFsdWVzXCIsXG4gICAgICB7IGtleXM6IG4gfSxcbiAgICAgIHRoaXMuY3JlYXRlUmVxdWVzdElkKCksXG4gICAgICB7IC4uLnMsIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICksIGkgPSB2KHl0KG4sIHUoKSksIFwiQ2xvdWRTdG9yYWdlRGF0YVwiKS5wYXJzZShyKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IGkgOiBpW3RdO1xuICB9XG4gIC8qKlxuICAgKiBTYXZlcyBzcGVjaWZpZWQgdmFsdWUgYnkga2V5LlxuICAgKiBAcGFyYW0ga2V5IC0gc3RvcmFnZSBrZXkuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHN0b3JhZ2UgdmFsdWUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gcmVxdWVzdCBleGVjdXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIHNldCh0LCBzLCBuID0ge30pIHtcbiAgICBhd2FpdCBxKFxuICAgICAgXCJzYXZlU3RvcmFnZVZhbHVlXCIsXG4gICAgICB7IGtleTogdCwgdmFsdWU6IHMgfSxcbiAgICAgIHRoaXMuY3JlYXRlUmVxdWVzdElkKCksXG4gICAgICB7IC4uLm4sIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGVzID0gbChcbiAgKHsgY3JlYXRlUmVxdWVzdElkOiBlLCBwb3N0RXZlbnQ6IHQsIHZlcnNpb246IHMgfSkgPT4gbmV3IHRzKHMsIGUsIHQpXG4pO1xuY2xhc3Mgc3MgZXh0ZW5kcyBfdCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMpIHtcbiAgICBzdXBlcih0LCB7XG4gICAgICBpbXBhY3RPY2N1cnJlZDogXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCIsXG4gICAgICBub3RpZmljYXRpb25PY2N1cnJlZDogXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCIsXG4gICAgICBzZWxlY3Rpb25DaGFuZ2VkOiBcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIlxuICAgIH0pLCB0aGlzLnBvc3RFdmVudCA9IHM7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRlbGxzIHRoYXQgYW4gaW1wYWN0IG9jY3VycmVkLiBUaGUgVGVsZWdyYW0gYXBwIG1heSBwbGF5IHRoZVxuICAgKiBhcHByb3ByaWF0ZSBoYXB0aWNzIGJhc2VkIG9uIHN0eWxlIHZhbHVlIHBhc3NlZC5cbiAgICogQHBhcmFtIHN0eWxlIC0gaW1wYWN0IHN0eWxlLlxuICAgKi9cbiAgaW1wYWN0T2NjdXJyZWQodCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF90cmlnZ2VyX2hhcHRpY19mZWVkYmFja1wiLCB7XG4gICAgICB0eXBlOiBcImltcGFjdFwiLFxuICAgICAgaW1wYWN0X3N0eWxlOiB0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRlbGxzIHRoYXQgYSB0YXNrIG9yIGFjdGlvbiBoYXMgc3VjY2VlZGVkLCBmYWlsZWQsIG9yIHByb2R1Y2VkXG4gICAqIGEgd2FybmluZy4gVGhlIFRlbGVncmFtIGFwcCBtYXkgcGxheSB0aGUgYXBwcm9wcmlhdGUgaGFwdGljcyBiYXNlZCBvblxuICAgKiB0eXBlIHZhbHVlIHBhc3NlZC5cbiAgICogQHBhcmFtIHR5cGUgLSBub3RpZmljYXRpb24gdHlwZS5cbiAgICovXG4gIG5vdGlmaWNhdGlvbk9jY3VycmVkKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIiwge1xuICAgICAgdHlwZTogXCJub3RpZmljYXRpb25cIixcbiAgICAgIG5vdGlmaWNhdGlvbl90eXBlOiB0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRlbGxzIHRoYXQgdGhlIHVzZXIgaGFzIGNoYW5nZWQgYSBzZWxlY3Rpb24uIFRoZSBUZWxlZ3JhbSBhcHBcbiAgICogbWF5IHBsYXkgdGhlIGFwcHJvcHJpYXRlIGhhcHRpY3MuXG4gICAqXG4gICAqIERvIG5vdCB1c2UgdGhpcyBmZWVkYmFjayB3aGVuIHRoZSB1c2VyIG1ha2VzIG9yIGNvbmZpcm1zIGEgc2VsZWN0aW9uO1xuICAgKiB1c2UgaXQgb25seSB3aGVuIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cbiAgICovXG4gIHNlbGVjdGlvbkNoYW5nZWQoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCIsIHsgdHlwZTogXCJzZWxlY3Rpb25fY2hhbmdlXCIgfSk7XG4gIH1cbn1cbmNvbnN0IG5zID0gbChcbiAgKHsgdmVyc2lvbjogZSwgcG9zdEV2ZW50OiB0IH0pID0+IG5ldyBzcyhlLCB0KVxuKTtcbmNsYXNzIHJzIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuaW5pdERhdGEgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmF1dGhEYXRlXG4gICAqL1xuICBnZXQgYXV0aERhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuYXV0aERhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuY2FuU2VuZEFmdGVyXG4gICAqL1xuICBnZXQgY2FuU2VuZEFmdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmNhblNlbmRBZnRlcjtcbiAgfVxuICAvKipcbiAgICogRGF0ZSBhZnRlciB3aGljaCBpdCBpcyBhbGxvd2VkIHRvIGNhbGxcbiAgICogdGhlIFthbnN3ZXJXZWJBcHBRdWVyeV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhbnN3ZXJ3ZWJhcHBxdWVyeSkgbWV0aG9kLlxuICAgKi9cbiAgZ2V0IGNhblNlbmRBZnRlckRhdGUoKSB7XG4gICAgY29uc3QgeyBjYW5TZW5kQWZ0ZXI6IHQgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHQgPyBuZXcgRGF0ZSh0aGlzLmF1dGhEYXRlLmdldFRpbWUoKSArIHQgKiAxZTMpIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmNoYXRcbiAgICovXG4gIGdldCBjaGF0KCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmNoYXQ7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuY2hhdFR5cGVcbiAgICovXG4gIGdldCBjaGF0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5jaGF0VHlwZTtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5jaGF0SW5zdGFuY2VcbiAgICovXG4gIGdldCBjaGF0SW5zdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuY2hhdEluc3RhbmNlO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmhhc2hcbiAgICovXG4gIGdldCBoYXNoKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmhhc2g7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQucXVlcnlJZFxuICAgKi9cbiAgZ2V0IHF1ZXJ5SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEucXVlcnlJZDtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5yZWNlaXZlclxuICAgKi9cbiAgZ2V0IHJlY2VpdmVyKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLnJlY2VpdmVyO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLnN0YXJ0UGFyYW1cbiAgICovXG4gIGdldCBzdGFydFBhcmFtKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLnN0YXJ0UGFyYW07XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQudXNlclxuICAgKi9cbiAgZ2V0IHVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEudXNlcjtcbiAgfVxufVxuY29uc3QgaXMgPSBsKFxuICAoeyBpbml0RGF0YTogZSB9KSA9PiBlID8gbmV3IHJzKGUpIDogdm9pZCAwXG4pO1xuZnVuY3Rpb24gbW4oZSkge1xuICByZXR1cm4gJHQoKS5wYXJzZShlKTtcbn1cbmNsYXNzIG9zIGV4dGVuZHMgJCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih7IGlzT3BlbmVkOiB0IH0sIHMsIHsgb3BlbjogXCJ3ZWJfYXBwX29wZW5faW52b2ljZVwiIH0pLCB0aGlzLnBvc3RFdmVudCA9IG47XG4gIH1cbiAgc2V0IGlzT3BlbmVkKHQpIHtcbiAgICB0aGlzLnNldChcImlzT3BlbmVkXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGludm9pY2UgaXMgY3VycmVudGx5IG9wZW5lZC5cbiAgICovXG4gIGdldCBpc09wZW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc09wZW5lZFwiKTtcbiAgfVxuICBhc3luYyBvcGVuKHQsIHMpIHtcbiAgICBpZiAodGhpcy5pc09wZW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludm9pY2UgaXMgYWxyZWFkeSBvcGVuZWRcIik7XG4gICAgbGV0IG47XG4gICAgaWYgKCFzKVxuICAgICAgbiA9IHQ7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB7IGhvc3RuYW1lOiByLCBwYXRobmFtZTogaSB9ID0gbmV3IFVSTCh0LCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICBpZiAociAhPT0gXCJ0Lm1lXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb3JyZWN0IGhvc3RuYW1lOiAke3J9YCk7XG4gICAgICBjb25zdCBvID0gaS5tYXRjaCgvXlxcLyhcXCR8aW52b2ljZVxcLykoW0EtWmEtejAtOVxcLV89XSspJC8pO1xuICAgICAgaWYgKCFvKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmsgcGF0aG5hbWUgaGFzIGluY29ycmVjdCBmb3JtYXQuIEV4cGVjdGVkIHRvIHJlY2VpdmUgXCIvaW52b2ljZS97c2x1Z31cIiBvciBcIi8ke3NsdWd9XCInKTtcbiAgICAgIFssICwgbl0gPSBvO1xuICAgIH1cbiAgICB0aGlzLmlzT3BlbmVkID0gITA7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoYXdhaXQgZyh7XG4gICAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX29wZW5faW52b2ljZVwiLFxuICAgICAgICBldmVudDogXCJpbnZvaWNlX2Nsb3NlZFwiLFxuICAgICAgICBwYXJhbXM6IHsgc2x1ZzogbiB9LFxuICAgICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgICBjYXB0dXJlKHIpIHtcbiAgICAgICAgICByZXR1cm4gbiA9PT0gci5zbHVnO1xuICAgICAgICB9XG4gICAgICB9KSkuc3RhdHVzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzT3BlbmVkID0gITE7XG4gICAgfVxuICB9XG59XG5jb25zdCBhcyA9IGwoXG4gICh7IHZlcnNpb246IGUsIHBvc3RFdmVudDogdCB9KSA9PiBuZXcgb3MoITEsIGUsIHQpXG4pO1xuY2xhc3MgY3MgZXh0ZW5kcyBodCB7XG4gIGNvbnN0cnVjdG9yKHsgcG9zdEV2ZW50OiB0LCAuLi5zIH0pIHtcbiAgICBzdXBlcihzKSwgYyh0aGlzLCBcInBvc3RFdmVudFwiKSwgYyh0aGlzLCBcIm9uXCIsIChuLCByKSA9PiBuID09PSBcImNsaWNrXCIgPyB5KFwibWFpbl9idXR0b25fcHJlc3NlZFwiLCByKSA6IHRoaXMuc3RhdGUub24obiwgcikpLCBjKHRoaXMsIFwib2ZmXCIsIChuLCByKSA9PiBuID09PSBcImNsaWNrXCIgPyB6KFwibWFpbl9idXR0b25fcHJlc3NlZFwiLCByKSA6IHRoaXMuc3RhdGUub2ZmKG4sIHIpKSwgdGhpcy5wb3N0RXZlbnQgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTWFpbkJ1dHRvbiBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKi9cbiAgZ2V0IGJnQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYmdDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgY3VycmVudCBsb2NhbCBzdGF0ZSB0byB0aGUgVGVsZWdyYW0gYXBwbGljYXRpb24uXG4gICAqL1xuICBjb21taXQoKSB7XG4gICAgdGhpcy50ZXh0ICE9PSBcIlwiICYmIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXR1cF9tYWluX2J1dHRvblwiLCB7XG4gICAgICBpc192aXNpYmxlOiB0aGlzLmlzVmlzaWJsZSxcbiAgICAgIGlzX2FjdGl2ZTogdGhpcy5pc0VuYWJsZWQsXG4gICAgICBpc19wcm9ncmVzc192aXNpYmxlOiB0aGlzLmlzTG9hZGVyVmlzaWJsZSxcbiAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgIGNvbG9yOiB0aGlzLmJnQ29sb3IsXG4gICAgICB0ZXh0X2NvbG9yOiB0aGlzLnRleHRDb2xvclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgTWFpbkJ1dHRvbi5cbiAgICogQHNlZSBEb2VzIG5vdCB3b3JrIG9uIEFuZHJvaWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvaXNzdWVzL2lzc3Vlcy8xXG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCA9ICExLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBNYWluQnV0dG9uLlxuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCA9ICEwLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgTWFpbkJ1dHRvbi5cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWaXNpYmxlID0gITEsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBNYWluQnV0dG9uIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgKi9cbiAgaGlkZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xvYWRlclZpc2libGUgPSAhMSwgdGhpcztcbiAgfVxuICBzZXQgaXNFbmFibGVkKHQpIHtcbiAgICB0aGlzLnNldFBhcmFtcyh7IGlzRW5hYmxlZDogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgTWFpbkJ1dHRvbiBpcyBlbmFibGVkLlxuICAgKi9cbiAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc0VuYWJsZWRcIik7XG4gIH1cbiAgc2V0IGlzTG9hZGVyVmlzaWJsZSh0KSB7XG4gICAgdGhpcy5zZXRQYXJhbXMoeyBpc0xvYWRlclZpc2libGU6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIE1haW5CdXR0b24gbG9hZGVyIGlzIHZpc2libGUuXG4gICAqL1xuICBnZXQgaXNMb2FkZXJWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzTG9hZGVyVmlzaWJsZVwiKTtcbiAgfVxuICBzZXQgaXNWaXNpYmxlKHQpIHtcbiAgICB0aGlzLnNldFBhcmFtcyh7IGlzVmlzaWJsZTogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgTWFpbkJ1dHRvbiBpcyB2aXNpYmxlLlxuICAgKi9cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc1Zpc2libGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBNYWluQnV0dG9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgb3BlbmluZyB0aGUgTWluaSBBcHAgZnJvbSB0aGUgYXR0YWNobWVudCBtZW51IGhpZGVzIHRoZSBtYWluIGJ1dHRvbiB1bnRpbCB0aGVcbiAgICogdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgTWluaSBBcHAgaW50ZXJmYWNlLlxuICAgKi9cbiAgc2hvdygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Zpc2libGUgPSAhMCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU2hvd3MgYSBsb2FkaW5nIGluZGljYXRvciBvbiB0aGUgTWFpbiBCdXR0b24uXG4gICAqL1xuICBzaG93TG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzTG9hZGVyVmlzaWJsZSA9ICEwLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IE1haW5CdXR0b24gdGV4dC4gTWluaW1hbCBsZW5ndGggZm9yIHRoZSB0ZXh0IGlzIDEgc3ltYm9sLCBhbmQgbWF4aW11bSBpcyA2NCBzeW1ib2xzLlxuICAgKiBAcGFyYW0gdGV4dCAtIGEgbmV3IHRleHQuXG4gICAqL1xuICBzZXRUZXh0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRQYXJhbXMoeyB0ZXh0OiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IE1haW4gQnV0dG9uIHRleHQgY29sb3IuXG4gICAqIEBwYXJhbSB0ZXh0Q29sb3IgLSBuZXcgdGV4dCBjb2xvci5cbiAgICovXG4gIHNldFRleHRDb2xvcih0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyYW1zKHsgdGV4dENvbG9yOiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGN1cnJlbnQgTWFpbiBCdXR0b24gY29sb3IuXG4gICAqIEBwYXJhbSBiZ0NvbG9yIC0gY29sb3IgdG8gc2V0LlxuICAgKi9cbiAgc2V0QmdDb2xvcih0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyYW1zKHsgYmdDb2xvcjogdCB9KTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHNldHRpbmcgbXVsdGlwbGUgTWFpbiBCdXR0b24gcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHBhcmFtcyAtIE1haW4gQnV0dG9uIHBhcmFtZXRlcnMuXG4gICAqL1xuICBzZXRQYXJhbXModCkge1xuICAgIHJldHVybiB0aGlzLnNldCh0KSwgdGhpcy5jb21taXQoKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIE1haW5CdXR0b24gdGV4dC5cbiAgICovXG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRleHRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNYWluQnV0dG9uIHRleHQgY29sb3IuXG4gICAqL1xuICBnZXQgdGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRleHRDb2xvclwiKTtcbiAgfVxufVxuY29uc3QgaHMgPSBsKFxuICBcIm1haW5CdXR0b25cIixcbiAgKHtcbiAgICBwb3N0RXZlbnQ6IGUsXG4gICAgdGhlbWVQYXJhbXM6IHQsXG4gICAgc3RhdGU6IHMgPSB7XG4gICAgICBpc1Zpc2libGU6ICExLFxuICAgICAgaXNFbmFibGVkOiAhMSxcbiAgICAgIHRleHQ6IFwiXCIsXG4gICAgICBpc0xvYWRlclZpc2libGU6ICExLFxuICAgICAgdGV4dENvbG9yOiB0LmJ1dHRvblRleHRDb2xvciB8fCBcIiNmZmZmZmZcIixcbiAgICAgIGJnQ29sb3I6IHQuYnV0dG9uQ29sb3IgfHwgXCIjMDAwMDAwXCJcbiAgICB9XG4gIH0pID0+IG5ldyBjcyh7IC4uLnMsIHBvc3RFdmVudDogZSB9KVxuKTtcbmZ1bmN0aW9uIHBzKCkge1xuICByZXR1cm4gdXQoe1xuICAgIGNvbnRhY3Q6IHYoe1xuICAgICAgdXNlcklkOiB7XG4gICAgICAgIHR5cGU6IHgoKSxcbiAgICAgICAgZnJvbTogXCJ1c2VyX2lkXCJcbiAgICAgIH0sXG4gICAgICBwaG9uZU51bWJlcjoge1xuICAgICAgICB0eXBlOiB1KCksXG4gICAgICAgIGZyb206IFwicGhvbmVfbnVtYmVyXCJcbiAgICAgIH0sXG4gICAgICBmaXJzdE5hbWU6IHtcbiAgICAgICAgdHlwZTogdSgpLFxuICAgICAgICBmcm9tOiBcImZpcnN0X25hbWVcIlxuICAgICAgfSxcbiAgICAgIGxhc3ROYW1lOiB7XG4gICAgICAgIHR5cGU6IHUoKS5vcHRpb25hbCgpLFxuICAgICAgICBmcm9tOiBcImxhc3RfbmFtZVwiXG4gICAgICB9XG4gICAgfSksXG4gICAgYXV0aERhdGU6IHtcbiAgICAgIHR5cGU6IEx0KCksXG4gICAgICBmcm9tOiBcImF1dGhfZGF0ZVwiXG4gICAgfSxcbiAgICBoYXNoOiB1KClcbiAgfSwgXCJSZXF1ZXN0ZWRDb250YWN0XCIpO1xufVxuZnVuY3Rpb24gWXQoZSwgdCkge1xuICByZXR1cm4gKHMpID0+IHtcbiAgICBjb25zdCBbbiwgcl0gPSB0W3NdO1xuICAgIHJldHVybiBDKG4sIHIsIGUpO1xuICB9O1xufVxuZnVuY3Rpb24gdXMoZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICBzZXRUaW1lb3V0KHQsIGUpO1xuICB9KTtcbn1cbmNsYXNzIGxzIGV4dGVuZHMgJCB7XG4gIGNvbnN0cnVjdG9yKHsgcG9zdEV2ZW50OiB0LCBjcmVhdGVSZXF1ZXN0SWQ6IHMsIHZlcnNpb246IG4sIGJvdElubGluZTogciwgLi4uaSB9KSB7XG4gICAgc3VwZXIoaSwgbiwge1xuICAgICAgcmVxdWVzdFBob25lQWNjZXNzOiBcIndlYl9hcHBfcmVxdWVzdF9waG9uZVwiLFxuICAgICAgcmVxdWVzdFdyaXRlQWNjZXNzOiBcIndlYl9hcHBfcmVxdWVzdF93cml0ZV9hY2Nlc3NcIixcbiAgICAgIHN3aXRjaElubGluZVF1ZXJ5OiBcIndlYl9hcHBfc3dpdGNoX2lubGluZV9xdWVyeVwiLFxuICAgICAgc2V0SGVhZGVyQ29sb3I6IFwid2ViX2FwcF9zZXRfaGVhZGVyX2NvbG9yXCIsXG4gICAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IFwid2ViX2FwcF9zZXRfYmFja2dyb3VuZF9jb2xvclwiXG4gICAgfSksIGModGhpcywgXCJib3RJbmxpbmVcIiksIGModGhpcywgXCJwb3N0RXZlbnRcIiksIGModGhpcywgXCJjcmVhdGVSZXF1ZXN0SWRcIiksIGModGhpcywgXCJyZXF1ZXN0UGhvbmVBY2Nlc3NQcm9taXNlXCIpLCBjKHRoaXMsIFwicmVxdWVzdFdyaXRlQWNjZXNzUHJvbWlzZVwiKSwgYyh0aGlzLCBcInN1cHBvcnRzUGFyYW1cIiksIHRoaXMuY3JlYXRlUmVxdWVzdElkID0gcywgdGhpcy5wb3N0RXZlbnQgPSB0LCB0aGlzLmJvdElubGluZSA9IHI7XG4gICAgY29uc3QgbyA9IHRoaXMuc3VwcG9ydHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN1cHBvcnRzID0gKGEpID0+IG8oYSkgPyBhICE9PSBcInN3aXRjaElubGluZVF1ZXJ5XCIgfHwgciA6ICExLCB0aGlzLnN1cHBvcnRzUGFyYW0gPSBZdChuLCB7XG4gICAgICBcInNldEhlYWRlckNvbG9yLmNvbG9yXCI6IFtcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiLCBcImNvbG9yXCJdXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGdldCByZXF1ZXN0ZWQgY29udGFjdC5cbiAgICogQHBhcmFtIHRpbWVvdXQgLSByZXF1ZXN0IHRpbWVvdXQuXG4gICAqL1xuICBhc3luYyBnZXRSZXF1ZXN0ZWRDb250YWN0KHtcbiAgICB0aW1lb3V0OiB0ID0gMWU0XG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBwcygpLnBhcnNlKFxuICAgICAgYXdhaXQgcShcbiAgICAgICAgXCJnZXRSZXF1ZXN0ZWRDb250YWN0XCIsXG4gICAgICAgIHt9LFxuICAgICAgICB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLFxuICAgICAgICB7IHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsIHRpbWVvdXQ6IHQgfVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNaW5pIEFwcCBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKiBAZXhhbXBsZSBcIiNmZmFhYmJcIlxuICAgKi9cbiAgZ2V0IGJnQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYmdDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBNaW5pIEFwcC5cbiAgICogQHBhcmFtIHJldHVybkJhY2sgLSBzaG91bGQgdGhlIGFwcGxpY2F0aW9uIGJlIHdyYXBwZWQgaW50byB0aGUgYm90dG9tIGJhci5cbiAgICovXG4gIGNsb3NlKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfY2xvc2VcIiwgeyByZXR1cm5fYmFjazogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIE1pbmkgQXBwIGhlYWRlciBjb2xvci5cbiAgICogQGV4YW1wbGUgXCIjZmZhYWJiXCJcbiAgICogQGV4YW1wbGUgXCJiZ19jb2xvclwiXG4gICAqL1xuICBnZXQgaGVhZGVyQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaGVhZGVyQ29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIE1pbmkgQXBwIGlzIGN1cnJlbnRseSBsYXVuY2hlZCBpbiBib3QgaW5saW5lIG1vZGUuXG4gICAqL1xuICBnZXQgaXNCb3RJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90SW5saW5lO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBjdXJyZW50IE1pbmkgQXBwIGJhY2tncm91bmQgY29sb3IgaXMgcmVjb2duaXplZCBhcyBkYXJrLlxuICAgKi9cbiAgZ2V0IGlzRGFyaygpIHtcbiAgICByZXR1cm4gQnQodGhpcy5iZ0NvbG9yKTtcbiAgfVxuICAvKipcbiAgICogSW5mb3JtcyB0aGUgVGVsZWdyYW0gYXBwIHRoYXQgdGhlIE1pbmkgQXBwIGlzIHJlYWR5IHRvIGJlIGRpc3BsYXllZC5cbiAgICpcbiAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBhcyBlYXJseSBhcyBwb3NzaWJsZSwgYXMgc29vbiBhcyBhbGwgZXNzZW50aWFsXG4gICAqIGludGVyZmFjZSBlbGVtZW50cyBsb2FkZWQuIE9uY2UgdGhpcyBtZXRob2QgY2FsbGVkLCB0aGUgbG9hZGluZyBwbGFjZWhvbGRlciBpcyBoaWRkZW5cbiAgICogYW5kIHRoZSBNaW5pIEFwcCBzaG93bi5cbiAgICpcbiAgICogSWYgdGhlIG1ldGhvZCBub3QgY2FsbGVkLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBiZSBoaWRkZW4gb25seSB3aGVuIHRoZSBwYWdlIGZ1bGx5IGxvYWRlZC5cbiAgICovXG4gIHJlYWR5KCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9yZWFkeVwiKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgY3VycmVudCB1c2VyIGNvbnRhY3QgaW5mb3JtYXRpb24uIEluIGNvbnRyYXJ5IHRvIHJlcXVlc3RQaG9uZUFjY2VzcywgdGhpcyBtZXRob2RcbiAgICogcmV0dXJucyBwcm9taXNlIHdpdGggY29udGFjdCBpbmZvcm1hdGlvbiB0aGF0IHJlamVjdHMgaW4gY2FzZSwgdXNlciBkZW5pZWQgYWNjZXNzLCBvciByZXF1ZXN0XG4gICAqIGZhaWxlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyByZXF1ZXN0Q29udGFjdCh7IHRpbWVvdXQ6IHQgPSA1ZTMgfSA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFJlcXVlc3RlZENvbnRhY3QoKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgaWYgKGF3YWl0IHRoaXMucmVxdWVzdFBob25lQWNjZXNzKCkgIT09IFwic2VudFwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWNjZXNzIGRlbmllZC5cIik7XG4gICAgY29uc3QgcyA9IERhdGUubm93KCkgKyB0O1xuICAgIGxldCBuID0gNTA7XG4gICAgcmV0dXJuIER0KGFzeW5jICgpID0+IHtcbiAgICAgIGZvciAoOyBEYXRlLm5vdygpIDwgczsgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UmVxdWVzdGVkQ29udGFjdCgpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB1cyhuKSwgbiArPSA1MDtcbiAgICAgIH1cbiAgICAgIHRocm93IE50KHQpO1xuICAgIH0sIHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBjdXJyZW50IHVzZXIgcGhvbmUgYWNjZXNzLiBNZXRob2QgcmV0dXJucyBwcm9taXNlLCB3aGljaCByZXNvbHZlc1xuICAgKiBzdGF0dXMgb2YgdGhlIHJlcXVlc3QuIEluIGNhc2UsIHVzZXIgYWNjZXB0ZWQgdGhlIHJlcXVlc3QsIE1pbmkgQXBwIGJvdCB3aWxsIHJlY2VpdmVcbiAgICogdGhlIGFjY29yZGluZyBub3RpZmljYXRpb24uXG4gICAqXG4gICAqIFRvIG9idGFpbiB0aGUgcmV0cmlldmVkIGluZm9ybWF0aW9uIGluc3RlYWQsIHV0aWxpemUgdGhlIGByZXF1ZXN0Q29udGFjdGAgbWV0aG9kLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHNlZSByZXF1ZXN0Q29udGFjdFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdFBob25lQWNjZXNzKHQgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQaG9uZUFjY2Vzc1Byb21pc2UgfHwgKHRoaXMucmVxdWVzdFBob25lQWNjZXNzUHJvbWlzZSA9IGcoe1xuICAgICAgLi4udCxcbiAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX3JlcXVlc3RfcGhvbmVcIixcbiAgICAgIGV2ZW50OiBcInBob25lX3JlcXVlc3RlZFwiLFxuICAgICAgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudFxuICAgIH0pLnRoZW4oKHsgc3RhdHVzOiBzIH0pID0+IHMpLmZpbmFsbHkoKCkgPT4gdGhpcy5yZXF1ZXN0UGhvbmVBY2Nlc3NQcm9taXNlID0gdm9pZCAwKSksIHRoaXMucmVxdWVzdFBob25lQWNjZXNzUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgd3JpdGUgbWVzc2FnZSBhY2Nlc3MgdG8gY3VycmVudCB1c2VyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIHJlcXVlc3RXcml0ZUFjY2Vzcyh0ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0V3JpdGVBY2Nlc3NQcm9taXNlIHx8ICh0aGlzLnJlcXVlc3RXcml0ZUFjY2Vzc1Byb21pc2UgPSBnKHtcbiAgICAgIC4uLnQsXG4gICAgICBtZXRob2Q6IFwid2ViX2FwcF9yZXF1ZXN0X3dyaXRlX2FjY2Vzc1wiLFxuICAgICAgZXZlbnQ6IFwid3JpdGVfYWNjZXNzX3JlcXVlc3RlZFwiLFxuICAgICAgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudFxuICAgIH0pLnRoZW4oKHsgc3RhdHVzOiBzIH0pID0+IHMpLmZpbmFsbHkoKCkgPT4gdGhpcy5yZXF1ZXN0V3JpdGVBY2Nlc3NQcm9taXNlID0gdm9pZCAwKSksIHRoaXMucmVxdWVzdFdyaXRlQWNjZXNzUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdXNlZCB0byBzZW5kIGRhdGEgdG8gdGhlIGJvdC4gV2hlbiB0aGlzIG1ldGhvZCBjYWxsZWQsIGEgc2VydmljZSBtZXNzYWdlIHNlbnQgdG9cbiAgICogdGhlIGJvdCBjb250YWluaW5nIHRoZSBkYXRhIG9mIHRoZSBsZW5ndGggdXAgdG8gNDA5NiBieXRlcywgYW5kIHRoZSBNaW5pIEFwcCBjbG9zZWQuIFNlZSB0aGVcbiAgICogZmllbGQgYHdlYl9hcHBfZGF0YWAgaW4gdGhlIGNsYXNzIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgTWluaSBBcHBzIGxhdW5jaGVkIHZpYSBhIEtleWJvYXJkIGJ1dHRvbi5cbiAgICogQHBhcmFtIGRhdGEgLSBkYXRhIHRvIHNlbmQgdG8gYm90LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gZGF0YSBoYXMgaW5jb3JyZWN0IHNpemUuXG4gICAqL1xuICBzZW5kRGF0YSh0KSB7XG4gICAgY29uc3QgeyBzaXplOiBzIH0gPSBuZXcgQmxvYihbdF0pO1xuICAgIGlmICghcyB8fCBzID4gNDA5NilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGFzc2VkIGRhdGEgaGFzIGluY29ycmVjdCBzaXplOiAke3N9YCk7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX2RhdGFfc2VuZFwiLCB7IGRhdGE6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY3VycmVudCBNaW5pIEFwcCBoZWFkZXIgY29sb3IuXG4gICAqXG4gICAqIEBzZWUgTm8gZWZmZWN0IG9uIGRlc2t0b3A6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvdG1hLmpzL2lzc3Vlcy85XG4gICAqIEBzZWUgV29ya3MgaW5jb3JyZWN0bHkgaW4gQW5kcm9pZDogaHR0cHM6Ly9naXRodWIuY29tL1RlbGVncmFtLU1pbmktQXBwcy90bWEuanMvaXNzdWVzLzhcbiAgICogQHBhcmFtIGNvbG9yIC0gY29sb3Iga2V5IG9yIFJHQiBjb2xvci5cbiAgICovXG4gIHNldEhlYWRlckNvbG9yKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiLCBjdCh0KSA/IHsgY29sb3I6IHQgfSA6IHsgY29sb3Jfa2V5OiB0IH0pLCB0aGlzLnNldChcImhlYWRlckNvbG9yXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGN1cnJlbnQgTWluaSBBcHAgYmFja2dyb3VuZCBjb2xvci5cbiAgICpcbiAgICogQHNlZSBObyBlZmZlY3Qgb24gZGVza3RvcDogaHR0cHM6Ly9naXRodWIuY29tL1RlbGVncmFtLU1pbmktQXBwcy90bWEuanMvaXNzdWVzLzlcbiAgICogQHNlZSBXb3JrcyBpbmNvcnJlY3RseSBpbiBBbmRyb2lkOiBodHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL3RtYS5qcy9pc3N1ZXMvOFxuICAgKiBAcGFyYW0gY29sb3IgLSBSR0IgY29sb3IuXG4gICAqL1xuICBzZXRCZ0NvbG9yKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0X2JhY2tncm91bmRfY29sb3JcIiwgeyBjb2xvcjogdCB9KSwgdGhpcy5zZXQoXCJiZ0NvbG9yXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIHRoZSBib3QncyB1c2VybmFtZSBhbmQgdGhlIHNwZWNpZmllZCBpbmxpbmUgcXVlcnkgaW4gdGhlIGN1cnJlbnQgY2hhdCdzIGlucHV0IGZpZWxkLlxuICAgKiBRdWVyeSBtYXkgYmUgZW1wdHksIGluIHdoaWNoIGNhc2Ugb25seSB0aGUgYm90J3MgdXNlcm5hbWUgd2lsbCBiZSBpbnNlcnRlZC4gVGhlIGNsaWVudCBwcm9tcHRzXG4gICAqIHRoZSB1c2VyIHRvIGNob29zZSBhIHNwZWNpZmljIGNoYXQsIHRoZW4gb3BlbnMgdGhhdCBjaGF0IGFuZCBpbnNlcnRzIHRoZSBib3QncyB1c2VybmFtZSBhbmRcbiAgICogdGhlIHNwZWNpZmllZCBpbmxpbmUgcXVlcnkgaW4gdGhlIGlucHV0IGZpZWxkLlxuICAgKiBAcGFyYW0gdGV4dCAtIHRleHQgd2hpY2ggc2hvdWxkIGJlIGluc2VydGVkIGluIHRoZSBpbnB1dCBhZnRlciB0aGUgY3VycmVudCBib3QgbmFtZS4gTWF4XG4gICAqIGxlbmd0aCBpcyAyNTYgc3ltYm9scy5cbiAgICogQHBhcmFtIGNoYXRUeXBlcyAtIExpc3Qgb2YgY2hhdCB0eXBlcyB3aGljaCBjb3VsZCBiZSBjaG9zZW4gdG8gc2VuZCB0aGUgbWVzc2FnZS4gQ291bGQgYmVcbiAgICogZW1wdHkgbGlzdC5cbiAgICovXG4gIHN3aXRjaElubGluZVF1ZXJ5KHQsIHMgPSBbXSkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0cyhcInN3aXRjaElubGluZVF1ZXJ5XCIpICYmICF0aGlzLmlzQm90SW5saW5lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIGlzIHVuc3VwcG9ydGVkIGJlY2F1c2UgTWluaSBBcHAgc2hvdWxkIGJlIGxhdW5jaGVkIGluIGlubGluZSBtb2RlLlwiKTtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc3dpdGNoX2lubGluZV9xdWVyeVwiLCB7IHF1ZXJ5OiB0LCBjaGF0X3R5cGVzOiBzIH0pO1xuICB9XG59XG5jb25zdCBkcyA9IGwoXG4gIFwibWluaUFwcFwiLFxuICAoe1xuICAgIHRoZW1lUGFyYW1zOiBlLFxuICAgIGJvdElubGluZTogdCA9ICExLFxuICAgIHN0YXRlOiBzID0ge1xuICAgICAgYmdDb2xvcjogZS5iZ0NvbG9yIHx8IFwiI2ZmZmZmZlwiLFxuICAgICAgaGVhZGVyQ29sb3I6IGUuaGVhZGVyQmdDb2xvciB8fCBcIiMwMDAwMDBcIlxuICAgIH0sXG4gICAgLi4ublxuICB9KSA9PiBuZXcgbHMoeyAuLi5uLCAuLi5zLCBib3RJbmxpbmU6IHQgfSlcbik7XG5mdW5jdGlvbiBfcyhlKSB7XG4gIGNvbnN0IHQgPSBlLm1lc3NhZ2UudHJpbSgpLCBzID0gKGUudGl0bGUgfHwgXCJcIikudHJpbSgpLCBuID0gZS5idXR0b25zIHx8IFtdO1xuICBsZXQgcjtcbiAgaWYgKHMubGVuZ3RoID4gNjQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaXRsZSBoYXMgaW5jb3JyZWN0IHNpemU6ICR7cy5sZW5ndGh9YCk7XG4gIGlmICghdC5sZW5ndGggfHwgdC5sZW5ndGggPiAyNTYpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdlIGhhcyBpbmNvcnJlY3Qgc2l6ZTogJHt0Lmxlbmd0aH1gKTtcbiAgaWYgKG4ubGVuZ3RoID4gMylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1dHRvbnMgaGF2ZSBpbmNvcnJlY3Qgc2l6ZTogJHtuLmxlbmd0aH1gKTtcbiAgcmV0dXJuIG4ubGVuZ3RoID8gciA9IG4ubWFwKChpKSA9PiB7XG4gICAgY29uc3QgeyBpZDogbyA9IFwiXCIgfSA9IGk7XG4gICAgaWYgKG8ubGVuZ3RoID4gNjQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1dHRvbiBJRCBoYXMgaW5jb3JyZWN0IHNpemU6ICR7b31gKTtcbiAgICBpZiAoIWkudHlwZSB8fCBpLnR5cGUgPT09IFwiZGVmYXVsdFwiIHx8IGkudHlwZSA9PT0gXCJkZXN0cnVjdGl2ZVwiKSB7XG4gICAgICBjb25zdCBhID0gaS50ZXh0LnRyaW0oKTtcbiAgICAgIGlmICghYS5sZW5ndGggfHwgYS5sZW5ndGggPiA2NCkge1xuICAgICAgICBjb25zdCBoID0gaS50eXBlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1dHRvbiB0ZXh0IHdpdGggdHlwZSBcIiR7aH1cIiBoYXMgaW5jb3JyZWN0IHNpemU6ICR7aS50ZXh0Lmxlbmd0aH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLmksIHRleHQ6IGEsIGlkOiBvIH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmksIGlkOiBvIH07XG4gIH0pIDogciA9IFt7IHR5cGU6IFwiY2xvc2VcIiwgaWQ6IFwiXCIgfV0sIHsgdGl0bGU6IHMsIG1lc3NhZ2U6IHQsIGJ1dHRvbnM6IHIgfTtcbn1cbmNsYXNzIGdzIGV4dGVuZHMgJCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih7IGlzT3BlbmVkOiB0IH0sIHMsIHsgb3BlbjogXCJ3ZWJfYXBwX29wZW5fcG9wdXBcIiB9KSwgdGhpcy5wb3N0RXZlbnQgPSBuO1xuICB9XG4gIHNldCBpc09wZW5lZCh0KSB7XG4gICAgdGhpcy5zZXQoXCJpc09wZW5lZFwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgUG9wdXAgaXMgb3BlbmVkLlxuICAgKi9cbiAgZ2V0IGlzT3BlbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzT3BlbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IHNob3dzIGEgbmF0aXZlIHBvcHVwIGRlc2NyaWJlZCBieSB0aGUgYHBhcmFtc2AgYXJndW1lbnQuXG4gICAqIFByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aGVuIHBvcHVwIGlzIGNsb3NlZC4gUmVzb2x2ZWQgdmFsdWUgd2lsbCBoYXZlXG4gICAqIGFuIGlkZW50aWZpZXIgb2YgcHJlc3NlZCBidXR0b24uXG4gICAqXG4gICAqIEluIGNhc2UsIHVzZXIgY2xpY2tlZCBvdXRzaWRlIHRoZSBwb3B1cCBvciBjbGlja2VkIHRvcCByaWdodCBwb3B1cCBjbG9zZVxuICAgKiBidXR0b24sIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBwb3B1cCBwYXJhbWV0ZXJzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gUG9wdXAgaXMgYWxyZWFkeSBvcGVuZWQuXG4gICAqL1xuICBhc3luYyBvcGVuKHQpIHtcbiAgICBpZiAodGhpcy5pc09wZW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvcHVwIGlzIGFscmVhZHkgb3BlbmVkLlwiKTtcbiAgICB0aGlzLmlzT3BlbmVkID0gITA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgYnV0dG9uX2lkOiBzID0gbnVsbCB9ID0gYXdhaXQgZyh7XG4gICAgICAgIGV2ZW50OiBcInBvcHVwX2Nsb3NlZFwiLFxuICAgICAgICBtZXRob2Q6IFwid2ViX2FwcF9vcGVuX3BvcHVwXCIsXG4gICAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICAgIHBhcmFtczogX3ModClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaXNPcGVuZWQgPSAhMTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHdzID0gbChcbiAgKHsgcG9zdEV2ZW50OiBlLCB2ZXJzaW9uOiB0IH0pID0+IG5ldyBncyghMSwgdCwgZSlcbik7XG5jbGFzcyBmcyBleHRlbmRzICQge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgc3VwZXIoeyBpc09wZW5lZDogdCB9LCBzLCB7XG4gICAgICBjbG9zZTogXCJ3ZWJfYXBwX2Nsb3NlX3NjYW5fcXJfcG9wdXBcIixcbiAgICAgIG9wZW46IFwid2ViX2FwcF9vcGVuX3NjYW5fcXJfcG9wdXBcIlxuICAgIH0pLCB0aGlzLnBvc3RFdmVudCA9IG47XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgc2Nhbm5lci5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9jbG9zZV9zY2FuX3FyX3BvcHVwXCIpLCB0aGlzLmlzT3BlbmVkID0gITE7XG4gIH1cbiAgc2V0IGlzT3BlbmVkKHQpIHtcbiAgICB0aGlzLnNldChcImlzT3BlbmVkXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNjYW5uZXIgaXMgY3VycmVudGx5IG9wZW5lZC5cbiAgICovXG4gIGdldCBpc09wZW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc09wZW5lZFwiKTtcbiAgfVxuICBhc3luYyBvcGVuKHQpIHtcbiAgICBpZiAodGhpcy5pc09wZW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzY2FubmVyIGlzIGFscmVhZHkgb3BlbmVkXCIpO1xuICAgIGNvbnN0IHsgdGV4dDogcywgY2FwdHVyZTogbiB9ID0gKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB7IHRleHQ6IHQgfSA6IHQpIHx8IHt9O1xuICAgIHRoaXMuaXNPcGVuZWQgPSAhMDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgciA9IChhd2FpdCBnKHtcbiAgICAgICAgbWV0aG9kOiBcIndlYl9hcHBfb3Blbl9zY2FuX3FyX3BvcHVwXCIsXG4gICAgICAgIGV2ZW50OiBbXCJxcl90ZXh0X3JlY2VpdmVkXCIsIFwic2Nhbl9xcl9wb3B1cF9jbG9zZWRcIl0sXG4gICAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICAgIHBhcmFtczogeyB0ZXh0OiBzIH0sXG4gICAgICAgIGNhcHR1cmUoaSkge1xuICAgICAgICAgIHJldHVybiBpLmV2ZW50ID09PSBcInNjYW5fcXJfcG9wdXBfY2xvc2VkXCIgfHwgIW4gfHwgbihpLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9KSB8fCB7fSkuZGF0YSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHIgJiYgdGhpcy5jbG9zZSgpLCByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzT3BlbmVkID0gITE7XG4gICAgfVxuICB9XG4gIC8vIFRPRE86IFN0cmVhbWluZyBtb2RlLCBhbGxvd2luZyB0byBzY2FuIHNldmVyYWwgUVJzIHVudGlsIGNsb3NlZC5cbn1cbmNvbnN0IG1zID0gbChcbiAgKHsgdmVyc2lvbjogZSwgcG9zdEV2ZW50OiB0IH0pID0+IG5ldyBmcyghMSwgZSwgdClcbik7XG5jbGFzcyBicyBleHRlbmRzIHB0IHtcbiAgY29uc3RydWN0b3IodCwgcywgbikge1xuICAgIHN1cGVyKHsgaXNWaXNpYmxlOiB0IH0sIHMsIHtcbiAgICAgIHNob3c6IFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIixcbiAgICAgIGhpZGU6IFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIlxuICAgIH0pLCBjKHRoaXMsIFwib25cIiwgKHIsIGkpID0+IHIgPT09IFwiY2xpY2tcIiA/IHkoXCJzZXR0aW5nc19idXR0b25fcHJlc3NlZFwiLCBpKSA6IHRoaXMuc3RhdGUub24ociwgaSkpLCBjKHRoaXMsIFwib2ZmXCIsIChyLCBpKSA9PiByID09PSBcImNsaWNrXCIgPyB6KFwic2V0dGluZ3NfYnV0dG9uX3ByZXNzZWRcIiwgaSkgOiB0aGlzLnN0YXRlLm9mZihyLCBpKSksIHRoaXMucG9zdEV2ZW50ID0gbjtcbiAgfVxuICBzZXQgaXNWaXNpYmxlKHQpIHtcbiAgICB0aGlzLnNldChcImlzVmlzaWJsZVwiLCB0KSwgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldHVwX3NldHRpbmdzX2J1dHRvblwiLCB7IGlzX3Zpc2libGU6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIFNldHRpbmdzQnV0dG9uIGlzIHZpc2libGUuXG4gICAqL1xuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzVmlzaWJsZVwiKTtcbiAgfVxuICAvKipcbiAgICogSGlkZXMgdGhlIFNldHRpbmdzQnV0dG9uLlxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmlzVmlzaWJsZSA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgU2V0dGluZ3NCdXR0b24uXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMuaXNWaXNpYmxlID0gITA7XG4gIH1cbn1cbmNvbnN0IHZzID0gbChcbiAgXCJzZXR0aW5nc0J1dHRvblwiLFxuICAoe1xuICAgIHZlcnNpb246IGUsXG4gICAgcG9zdEV2ZW50OiB0LFxuICAgIHN0YXRlOiBzID0geyBpc1Zpc2libGU6ICExIH1cbiAgfSkgPT4gbmV3IGJzKHMuaXNWaXNpYmxlLCBlLCB0KVxuKTtcbmZ1bmN0aW9uIFp0KGUpIHtcbiAgcmV0dXJuIEh0KCkucGFyc2UoZSk7XG59XG5jbGFzcyB5cyBleHRlbmRzIGR0IHtcbiAgLyoqXG4gICAqIEBzaW5jZSB2Ni4xMFxuICAgKi9cbiAgZ2V0IGFjY2VudFRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJhY2NlbnRUZXh0Q29sb3JcIik7XG4gIH1cbiAgZ2V0IGJnQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYmdDb2xvclwiKTtcbiAgfVxuICBnZXQgYnV0dG9uQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYnV0dG9uQ29sb3JcIik7XG4gIH1cbiAgZ2V0IGJ1dHRvblRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJidXR0b25UZXh0Q29sb3JcIik7XG4gIH1cbiAgZ2V0IGRlc3RydWN0aXZlVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImRlc3RydWN0aXZlVGV4dENvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgY3VycmVudCBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqL1xuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBoZWFkZXJCZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImhlYWRlckJnQ29sb3JcIik7XG4gIH1cbiAgZ2V0IGhpbnRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJoaW50Q29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRydWUgaW4gY2FzZSwgY3VycmVudCBjb2xvciBzY2hlbWUgaXMgcmVjb2duaXplZCBhcyBkYXJrLiBUaGlzXG4gICAqIHZhbHVlIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZW1lIGJnIGNvbG9yLlxuICAgKi9cbiAgZ2V0IGlzRGFyaygpIHtcbiAgICByZXR1cm4gIXRoaXMuYmdDb2xvciB8fCBCdCh0aGlzLmJnQ29sb3IpO1xuICB9XG4gIGdldCBsaW5rQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwibGlua0NvbG9yXCIpO1xuICB9XG4gIGdldCBzZWNvbmRhcnlCZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNlY29uZGFyeUJnQ29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSB2Ni4xMFxuICAgKi9cbiAgZ2V0IHNlY3Rpb25CZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNlY3Rpb25CZ0NvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBzZWN0aW9uSGVhZGVyVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNlY3Rpb25IZWFkZXJUZXh0Q29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSB2Ny42XG4gICAqL1xuICBnZXQgc2VjdGlvblNlcGFyYXRvckNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNlY3Rpb25IZWFkZXJUZXh0Q29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyBsaXN0ZW5pbmcgdG8gdGhlIGV4dGVybmFsIHRoZW1lIGNoYW5nZXMgYW5kIGFwcGxpZXMgdGhlbS5cbiAgICogQHJldHVybnMgRnVuY3Rpb24gdG8gc3RvcCBsaXN0ZW5pbmcuXG4gICAqL1xuICBsaXN0ZW4oKSB7XG4gICAgcmV0dXJuIHkoXCJ0aGVtZV9jaGFuZ2VkXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLnNldChadCh0LnRoZW1lX3BhcmFtcykpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBzdWJ0aXRsZVRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzdWJ0aXRsZVRleHRDb2xvclwiKTtcbiAgfVxuICBnZXQgdGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRleHRDb2xvclwiKTtcbiAgfVxufVxuY29uc3QgRXMgPSBsKFxuICBcInRoZW1lUGFyYW1zXCIsXG4gICh7IHRoZW1lUGFyYW1zOiBlLCBzdGF0ZTogdCA9IGUsIGFkZENsZWFudXA6IHMgfSkgPT4ge1xuICAgIGNvbnN0IG4gPSBuZXcgeXModCk7XG4gICAgcmV0dXJuIHMobi5saXN0ZW4oKSksIG47XG4gIH1cbik7XG5mdW5jdGlvbiBibihlID0ge30pIHtcbiAgcmV0dXJuIGcoe1xuICAgIC4uLmUsXG4gICAgbWV0aG9kOiBcIndlYl9hcHBfcmVxdWVzdF90aGVtZVwiLFxuICAgIGV2ZW50OiBcInRoZW1lX2NoYW5nZWRcIlxuICB9KS50aGVuKFp0KTtcbn1cbmZ1bmN0aW9uIEIoZSwgdCkge1xuICByZXR1cm4gZS5zdGFydHNXaXRoKHQpID8gZSA6IGAke3R9JHtlfWA7XG59XG5mdW5jdGlvbiBNKGUpIHtcbiAgcmV0dXJuIG5ldyBVUkwoXG4gICAgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBgJHtlLnBhdGhuYW1lIHx8IFwiXCJ9JHtCKGUuc2VhcmNoIHx8IFwiXCIsIFwiP1wiKX0ke0IoZS5oYXNoIHx8IFwiXCIsIFwiI1wiKX1gLFxuICAgIFwiaHR0cDovL2FcIlxuICApO1xufVxuY2xhc3MgUHMgZXh0ZW5kcyBfdCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih0LCB7IHJlYWRUZXh0RnJvbUNsaXBib2FyZDogXCJ3ZWJfYXBwX3JlYWRfdGV4dF9mcm9tX2NsaXBib2FyZFwiIH0pLCBjKHRoaXMsIFwic3VwcG9ydHNQYXJhbVwiKSwgdGhpcy52ZXJzaW9uID0gdCwgdGhpcy5jcmVhdGVSZXF1ZXN0SWQgPSBzLCB0aGlzLnBvc3RFdmVudCA9IG4sIHRoaXMuc3VwcG9ydHNQYXJhbSA9IFl0KHQsIHtcbiAgICAgIFwib3BlbkxpbmsudHJ5SW5zdGFudFZpZXdcIjogW1wid2ViX2FwcF9vcGVuX2xpbmtcIiwgXCJ0cnlfaW5zdGFudF92aWV3XCJdXG4gICAgfSk7XG4gIH1cbiAgb3BlbkxpbmsodCwgcykge1xuICAgIGNvbnN0IG4gPSBNKHQpLnRvU3RyaW5nKCk7XG4gICAgaWYgKCFDKFwid2ViX2FwcF9vcGVuX2xpbmtcIiwgdGhpcy52ZXJzaW9uKSkge1xuICAgICAgd2luZG93Lm9wZW4obiwgXCJfYmxhbmtcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHIgPSB0eXBlb2YgcyA9PSBcImJvb2xlYW5cIiA/IHsgdHJ5SW5zdGFudFZpZXc6IHMgfSA6IHMgfHwge307XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX29wZW5fbGlua1wiLCB7XG4gICAgICB1cmw6IG4sXG4gICAgICB0cnlfYnJvd3Nlcjogci50cnlCcm93c2VyLFxuICAgICAgdHJ5X2luc3RhbnRfdmlldzogci50cnlJbnN0YW50Vmlld1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyBhIFRlbGVncmFtIGxpbmsgaW5zaWRlIFRlbGVncmFtIGFwcC4gVGhlIE1pbmkgQXBwIHdpbGwgYmUgY2xvc2VkLiBJdCBleHBlY3RzIHBhc3NpbmdcbiAgICogbGluayBpbiBmdWxsIGZvcm1hdCwgd2l0aCBob3N0bmFtZSBcInQubWVcIi5cbiAgICogQHBhcmFtIHVybCAtIFVSTCB0byBiZSBvcGVuZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBVUkwgaGFzIG5vdCBhbGxvd2VkIGhvc3RuYW1lLlxuICAgKi9cbiAgb3BlblRlbGVncmFtTGluayh0KSB7XG4gICAgY29uc3QgeyBob3N0bmFtZTogcywgcGF0aG5hbWU6IG4sIHNlYXJjaDogciB9ID0gbmV3IFVSTCh0LCBcImh0dHBzOi8vdC5tZVwiKTtcbiAgICBpZiAocyAhPT0gXCJ0Lm1lXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVSTCBoYXMgbm90IGFsbG93ZWQgaG9zdG5hbWU6ICR7c30uIE9ubHkgXCJ0Lm1lXCIgaXMgYWxsb3dlZGApO1xuICAgIGlmICghQyhcIndlYl9hcHBfb3Blbl90Z19saW5rXCIsIHRoaXMudmVyc2lvbikpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX29wZW5fdGdfbGlua1wiLCB7IHBhdGhfZnVsbDogbiArIHIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIHRleHQgZnJvbSBjbGlwYm9hcmQgYW5kIHJldHVybnMgc3RyaW5nIG9yIG51bGwuIG51bGwgaXMgcmV0dXJuZWRcbiAgICogaW4gY2FzZXM6XG4gICAqIC0gVmFsdWUgaW4gY2xpcGJvYXJkIGlzIG5vdCB0ZXh0XG4gICAqIC0gQWNjZXNzIHRvIGNsaXBib2FyZCBpcyBub3QgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgcmVhZFRleHRGcm9tQ2xpcGJvYXJkKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLCB7XG4gICAgICBkYXRhOiBzID0gbnVsbFxuICAgIH0gPSBhd2FpdCBnKHtcbiAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX3JlYWRfdGV4dF9mcm9tX2NsaXBib2FyZFwiLFxuICAgICAgZXZlbnQ6IFwiY2xpcGJvYXJkX3RleHRfcmVjZWl2ZWRcIixcbiAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICBwYXJhbXM6IHsgcmVxX2lkOiB0IH0sXG4gICAgICBjYXB0dXJlOiBxdCh0KVxuICAgIH0pO1xuICAgIHJldHVybiBzO1xuICB9XG4gIC8qKlxuICAgKiBTaGFyZXMgc3BlY2lmaWVkIFVSTCB3aXRoIHRoZSBwYXNzZWQgdG8gdGhlIGNoYXRzLCBzZWxlY3RlZCBieSB1c2VyLiBBZnRlciBiZWluZyBjYWxsZWQsXG4gICAqIGl0IGNsb3NlcyB0aGUgbWluaSBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgdXNlcyBUZWxlZ3JhbSdzIFNoYXJlIExpbmtzLlxuICAgKiBAcGFyYW0gdXJsIC0gVVJMIHRvIHNoYXJlLlxuICAgKiBAcGFyYW0gdGV4dCAtIHRleHQgdG8gYXBwZW5kIGFmdGVyIHRoZSBVUkwuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9hcGkvbGlua3Mjc2hhcmUtbGlua3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL3dpZGdldHMvc2hhcmUjY3VzdG9tLWJ1dHRvbnNcbiAgICovXG4gIHNoYXJlVVJMKHQsIHMpIHtcbiAgICB0aGlzLm9wZW5UZWxlZ3JhbUxpbmsoXG4gICAgICBcImh0dHBzOi8vdC5tZS9zaGFyZS91cmw/XCIgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgdXJsOiB0LCB0ZXh0OiBzIHx8IFwiXCIgfSkudG9TdHJpbmcoKS5yZXBsYWNlKC9cXCsvZywgXCIlMjBcIilcbiAgICApO1xuICB9XG59XG5jb25zdCBScyA9IGwoXG4gICh7IHZlcnNpb246IGUsIHBvc3RFdmVudDogdCwgY3JlYXRlUmVxdWVzdElkOiBzIH0pID0+IG5ldyBQcyhlLCBzLCB0KVxuKTtcbmFzeW5jIGZ1bmN0aW9uIFh0KGUgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaXNfZXhwYW5kZWQ6IHQsXG4gICAgaXNfc3RhdGVfc3RhYmxlOiBzLFxuICAgIC4uLm5cbiAgfSA9IGF3YWl0IGcoe1xuICAgIC4uLmUsXG4gICAgbWV0aG9kOiBcIndlYl9hcHBfcmVxdWVzdF92aWV3cG9ydFwiLFxuICAgIGV2ZW50OiBcInZpZXdwb3J0X2NoYW5nZWRcIlxuICB9KTtcbiAgcmV0dXJuIHsgLi4ubiwgaXNFeHBhbmRlZDogdCwgaXNTdGF0ZVN0YWJsZTogcyB9O1xufVxuZnVuY3Rpb24gTyhlKSB7XG4gIHJldHVybiBlIDwgMCA/IDAgOiBlO1xufVxuY2xhc3MgeHMgZXh0ZW5kcyBkdCB7XG4gIGNvbnN0cnVjdG9yKHsgcG9zdEV2ZW50OiB0LCBzdGFibGVIZWlnaHQ6IHMsIGhlaWdodDogbiwgd2lkdGg6IHIsIGlzRXhwYW5kZWQ6IGkgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGhlaWdodDogTyhuKSxcbiAgICAgIGlzRXhwYW5kZWQ6IGksXG4gICAgICBzdGFibGVIZWlnaHQ6IE8ocyksXG4gICAgICB3aWR0aDogTyhyKVxuICAgIH0pLCBjKHRoaXMsIFwicG9zdEV2ZW50XCIpLCB0aGlzLnBvc3RFdmVudCA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHZpZXdwb3J0IGluZm9ybWF0aW9uIGZyb20gdGhlIFRlbGVncmFtIGFwcGxpY2F0aW9uIGFuZCB1cGRhdGVzIGN1cnJlbnQgVmlld3BvcnRcbiAgICogaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyB0byByZXF1ZXN0IGZyZXNoIGRhdGEuXG4gICAqL1xuICBhc3luYyBzeW5jKHQpIHtcbiAgICBjb25zdCB7IGlzU3RhdGVTdGFibGU6IHMsIC4uLm4gfSA9IGF3YWl0IFh0KHQpO1xuICAgIHRoaXMuc2V0KHtcbiAgICAgIC4uLm4sXG4gICAgICBzdGFibGVIZWlnaHQ6IHMgPyBuLmhlaWdodCA6IHRoaXMuZ2V0KFwic3RhYmxlSGVpZ2h0XCIpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgKip2aXNpYmxlIGFyZWEqKiBvZiB0aGUgTWluaSBBcHAuXG4gICAqXG4gICAqIFRoZSBhcHBsaWNhdGlvbiBjYW4gZGlzcGxheSBqdXN0IHRoZSB0b3AgcGFydCBvZiB0aGUgTWluaSBBcHAsIHdpdGggaXRzIGxvd2VyIHBhcnQgcmVtYWluaW5nXG4gICAqIG91dHNpZGUgdGhlIHNjcmVlbiBhcmVhLiBGcm9tIHRoaXMgcG9zaXRpb24sIHRoZSB1c2VyIGNhbiBcInB1bGxcIiB0aGUgTWluaSBBcHAgdG8gaXRzXG4gICAqIG1heGltdW0gaGVpZ2h0LCB3aGlsZSB0aGUgYm90IGNhbiBkbyB0aGUgc2FtZSBieSBjYWxsaW5nIGBleHBhbmRgIG1ldGhvZC4gQXMgdGhlIHBvc2l0aW9uIG9mXG4gICAqIHRoZSBNaW5pIEFwcCBjaGFuZ2VzLCB0aGUgY3VycmVudCBoZWlnaHQgdmFsdWUgb2YgdGhlIHZpc2libGUgYXJlYSB3aWxsIGJlIHVwZGF0ZWQgIGluIHJlYWxcbiAgICogdGltZS5cbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGUgcmVmcmVzaCByYXRlIG9mIHRoaXMgdmFsdWUgaXMgbm90IHN1ZmZpY2llbnQgdG8gc21vb3RobHkgZm9sbG93IHRoZVxuICAgKiBsb3dlciBib3JkZXIgb2YgdGhlIHdpbmRvdy4gSXQgc2hvdWxkIG5vdCBiZSB1c2VkIHRvIHBpbiBpbnRlcmZhY2UgZWxlbWVudHMgdG8gdGhlIGJvdHRvbVxuICAgKiBvZiB0aGUgdmlzaWJsZSBhcmVhLiBJdCdzIG1vcmUgYXBwcm9wcmlhdGUgdG8gdXNlIHRoZSB2YWx1ZSBvZiB0aGUgYHN0YWJsZUhlaWdodGBcbiAgICogZmllbGQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICpcbiAgICogQHNlZSBzdGFibGVIZWlnaHRcbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaGVpZ2h0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSB2aXNpYmxlIGFyZWEgb2YgdGhlIE1pbmkgQXBwIGluIGl0cyBsYXN0IHN0YWJsZSBzdGF0ZS5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIGNhbiBkaXNwbGF5IGp1c3QgdGhlIHRvcCBwYXJ0IG9mIHRoZSBNaW5pIEFwcCwgd2l0aCBpdHMgbG93ZXIgcGFydCByZW1haW5pbmdcbiAgICogb3V0c2lkZSB0aGUgc2NyZWVuIGFyZWEuIEZyb20gdGhpcyBwb3NpdGlvbiwgdGhlIHVzZXIgY2FuIFwicHVsbFwiIHRoZSBNaW5pIEFwcCB0byBpdHNcbiAgICogbWF4aW11bSBoZWlnaHQsIHdoaWxlIHRoZSBhcHBsaWNhdGlvbiBjYW4gZG8gdGhlIHNhbWUgYnkgY2FsbGluZyBgZXhwYW5kYCBtZXRob2QuXG4gICAqXG4gICAqIFVubGlrZSB0aGUgdmFsdWUgb2YgYGhlaWdodGAsIHRoZSB2YWx1ZSBvZiBgc3RhYmxlSGVpZ2h0YCBkb2VzIG5vdCBjaGFuZ2UgYXMgdGhlIHBvc2l0aW9uXG4gICAqIG9mIHRoZSBNaW5pIEFwcCBjaGFuZ2VzIHdpdGggdXNlciBnZXN0dXJlcyBvciBkdXJpbmcgYW5pbWF0aW9ucy4gVGhlIHZhbHVlIG9mIGBzdGFibGVIZWlnaHRgXG4gICAqIHdpbGwgYmUgdXBkYXRlZCBhZnRlciBhbGwgZ2VzdHVyZXMgYW5kIGFuaW1hdGlvbnMgYXJlIGNvbXBsZXRlZCBhbmRcbiAgICogdGhlIE1pbmkgQXBwIHJlYWNoZXMgaXRzIGZpbmFsIHNpemUuXG4gICAqXG4gICAqIEBzZWUgaGVpZ2h0XG4gICAqL1xuICBnZXQgc3RhYmxlSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInN0YWJsZUhlaWdodFwiKTtcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIGxpc3RlbmluZyB0byB2aWV3cG9ydCBjaGFuZ2VzIGFuZCBhcHBsaWVzIHRoZW0uXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRvIHN0b3AgbGlzdGVuaW5nLlxuICAgKi9cbiAgbGlzdGVuKCkge1xuICAgIHJldHVybiB5KFwidmlld3BvcnRfY2hhbmdlZFwiLCAodCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBoZWlnaHQ6IHMsXG4gICAgICAgIHdpZHRoOiBuLFxuICAgICAgICBpc19leHBhbmRlZDogcixcbiAgICAgICAgaXNfc3RhdGVfc3RhYmxlOiBpXG4gICAgICB9ID0gdCwgbyA9IE8ocyk7XG4gICAgICB0aGlzLnNldCh7XG4gICAgICAgIGhlaWdodDogbyxcbiAgICAgICAgaXNFeHBhbmRlZDogcixcbiAgICAgICAgd2lkdGg6IE8obiksXG4gICAgICAgIC4uLmkgPyB7IHN0YWJsZUhlaWdodDogbyB9IDoge31cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBNaW5pIEFwcCBpcyBleHBhbmRlZCB0byB0aGUgbWF4aW11bSBhdmFpbGFibGUgaGVpZ2h0LiBPdGhlcndpc2UsIGlmXG4gICAqIHRoZSBNaW5pIEFwcCBvY2N1cGllcyBwYXJ0IG9mIHRoZSBzY3JlZW4gYW5kIGNhbiBiZSBleHBhbmRlZCB0byB0aGUgZnVsbCBoZWlnaHQgdXNpbmdcbiAgICogYGV4cGFuZGAgbWV0aG9kLlxuICAgKiBAc2VlIGV4cGFuZFxuICAgKi9cbiAgZ2V0IGlzRXhwYW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaXNFeHBhbmRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCB2aXNpYmxlIGFyZWEgd2lkdGguXG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwid2lkdGhcIik7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRoYXQgZXhwYW5kcyB0aGUgTWluaSBBcHAgdG8gdGhlIG1heGltdW0gYXZhaWxhYmxlIGhlaWdodC4gVG8gZmluZCBvdXQgaWYgdGhlIE1pbmlcbiAgICogQXBwIGlzIGV4cGFuZGVkIHRvIHRoZSBtYXhpbXVtIGhlaWdodCwgcmVmZXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBgaXNFeHBhbmRlZGAuXG4gICAqIEBzZWUgaXNFeHBhbmRlZFxuICAgKi9cbiAgZXhwYW5kKCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9leHBhbmRcIiksIHRoaXMuc2V0KFwiaXNFeHBhbmRlZFwiLCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIGN1cnJlbnQgdmlld3BvcnQgaGVpZ2h0IGlzIHN0YWJsZSBhbmQgaXMgbm90IGdvaW5nIHRvIGNoYW5nZSBpbiB0aGUgbmV4dCBtb21lbnQuXG4gICAqL1xuICBnZXQgaXNTdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhYmxlSGVpZ2h0ID09PSB0aGlzLmhlaWdodDtcbiAgfVxufVxuY29uc3QgQ3MgPSBsKFxuICBcInZpZXdwb3J0XCIsXG4gIGFzeW5jICh7IHN0YXRlOiBlLCBwbGF0Zm9ybTogdCwgcG9zdEV2ZW50OiBzLCBhZGRDbGVhbnVwOiBuIH0pID0+IHtcbiAgICBsZXQgciA9ICExLCBpID0gMCwgbyA9IDAsIGEgPSAwO1xuICAgIGlmIChlKVxuICAgICAgciA9IGUuaXNFeHBhbmRlZCwgaSA9IGUuaGVpZ2h0LCBvID0gZS53aWR0aCwgYSA9IGUuc3RhYmxlSGVpZ2h0O1xuICAgIGVsc2UgaWYgKFtcIm1hY29zXCIsIFwidGRlc2t0b3BcIiwgXCJ1bmlncmFtXCIsIFwid2Via1wiLCBcIndlYmFcIiwgXCJ3ZWJcIl0uaW5jbHVkZXModCkpXG4gICAgICByID0gITAsIGkgPSB3aW5kb3cuaW5uZXJIZWlnaHQsIG8gPSB3aW5kb3cuaW5uZXJXaWR0aCwgYSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHAgPSBhd2FpdCBYdCh7IHRpbWVvdXQ6IDFlMywgcG9zdEV2ZW50OiBzIH0pO1xuICAgICAgciA9IHAuaXNFeHBhbmRlZCwgaSA9IHAuaGVpZ2h0LCBvID0gcC53aWR0aCwgYSA9IHAuaXNTdGF0ZVN0YWJsZSA/IGkgOiAwO1xuICAgIH1cbiAgICBjb25zdCBoID0gbmV3IHhzKHtcbiAgICAgIHBvc3RFdmVudDogcyxcbiAgICAgIGhlaWdodDogaSxcbiAgICAgIHdpZHRoOiBvLFxuICAgICAgc3RhYmxlSGVpZ2h0OiBhLFxuICAgICAgaXNFeHBhbmRlZDogclxuICAgIH0pO1xuICAgIHJldHVybiBuKGgubGlzdGVuKCkpLCBoO1xuICB9XG4pO1xuZnVuY3Rpb24gUChlLCB0KSB7XG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShlLCB0KTtcbn1cbmZ1bmN0aW9uIHZuKGUsIHQsIHMpIHtcbiAgcyB8fCAocyA9IChhKSA9PiBgLS10Zy0ke2F9LWNvbG9yYCk7XG4gIGNvbnN0IG4gPSBzKFwiaGVhZGVyXCIpLCByID0gcyhcImJnXCIpLCBpID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgaGVhZGVyQ29sb3I6IGEgfSA9IGU7XG4gICAgaWYgKGN0KGEpKVxuICAgICAgUChuLCBhKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHsgYmdDb2xvcjogaCwgc2Vjb25kYXJ5QmdDb2xvcjogcCB9ID0gdDtcbiAgICAgIGEgPT09IFwiYmdfY29sb3JcIiAmJiBoID8gUChuLCBoKSA6IGEgPT09IFwic2Vjb25kYXJ5X2JnX2NvbG9yXCIgJiYgcCAmJiBQKG4sIHApO1xuICAgIH1cbiAgICBQKHIsIGUuYmdDb2xvcik7XG4gIH0sIG8gPSBbXG4gICAgdC5vbihcImNoYW5nZVwiLCBpKSxcbiAgICBlLm9uKFwiY2hhbmdlXCIsIGkpXG4gIF07XG4gIHJldHVybiBpKCksICgpID0+IG8uZm9yRWFjaCgoYSkgPT4gYSgpKTtcbn1cbmZ1bmN0aW9uIHluKGUsIHQpIHtcbiAgdCB8fCAodCA9IChuKSA9PiBgLS10Zy10aGVtZS0ke24ucmVwbGFjZSgvW0EtWl0vZywgKHIpID0+IGAtJHtyLnRvTG93ZXJDYXNlKCl9YCl9YCk7XG4gIGNvbnN0IHMgPSAoKSA9PiB7XG4gICAgT2JqZWN0LmVudHJpZXMoZS5nZXRTdGF0ZSgpKS5mb3JFYWNoKChbbiwgcl0pID0+IHtcbiAgICAgIHIgJiYgUCh0KG4pLCByKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHMoKSwgZS5vbihcImNoYW5nZVwiLCBzKTtcbn1cbmZ1bmN0aW9uIEVuKGUsIHQpIHtcbiAgdCB8fCAodCA9IChwKSA9PiBgLS10Zy12aWV3cG9ydC0ke3B9YCk7XG4gIGNvbnN0IFtcbiAgICBzLFxuICAgIG4sXG4gICAgclxuICBdID0gW1wiaGVpZ2h0XCIsIFwid2lkdGhcIiwgXCJzdGFibGUtaGVpZ2h0XCJdLm1hcCgocCkgPT4gdChwKSksIGkgPSAoKSA9PiBQKHMsIGAke2UuaGVpZ2h0fXB4YCksIG8gPSAoKSA9PiBQKG4sIGAke2Uud2lkdGh9cHhgKSwgYSA9ICgpID0+IFAociwgYCR7ZS5zdGFibGVIZWlnaHR9cHhgKSwgaCA9IFtcbiAgICBlLm9uKFwiY2hhbmdlOmhlaWdodFwiLCBpKSxcbiAgICBlLm9uKFwiY2hhbmdlOndpZHRoXCIsIG8pLFxuICAgIGUub24oXCJjaGFuZ2U6c3RhYmxlSGVpZ2h0XCIsIGEpXG4gIF07XG4gIHJldHVybiBpKCksIG8oKSwgYSgpLCAoKSA9PiBoLmZvckVhY2goKHApID0+IHAoKSk7XG59XG5mdW5jdGlvbiBTcyhlID0gITApIHtcbiAgY29uc3QgdCA9IFtcbiAgICB5KFwicmVsb2FkX2lmcmFtZVwiLCAoKSA9PiB7XG4gICAgICBWKFwiaWZyYW1lX3dpbGxfcmVsb2FkXCIpLCB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfSlcbiAgXSwgcyA9ICgpID0+IHQuZm9yRWFjaCgobikgPT4gbigpKTtcbiAgaWYgKGUpIHtcbiAgICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIG4uaWQgPSBcInRlbGVncmFtLWN1c3RvbS1zdHlsZXNcIiwgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChuKSwgdC5wdXNoKFxuICAgICAgeShcInNldF9jdXN0b21fc3R5bGVcIiwgKHIpID0+IHtcbiAgICAgICAgbi5pbm5lckhUTUwgPSByO1xuICAgICAgfSksXG4gICAgICAoKSA9PiBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKG4pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gVihcImlmcmFtZV9yZWFkeVwiLCB7IHJlbG9hZF9zdXBwb3J0ZWQ6ICEwIH0pLCBzO1xufVxuZnVuY3Rpb24gVHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID4gXCJ1XCI7XG59XG5hc3luYyBmdW5jdGlvbiBQbigpIHtcbiAgaWYgKGt0KHdpbmRvdykpXG4gICAgcmV0dXJuICEwO1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBnKHsgbWV0aG9kOiBcIndlYl9hcHBfcmVxdWVzdF90aGVtZVwiLCBldmVudDogXCJ0aGVtZV9jaGFuZ2VkXCIsIHRpbWVvdXQ6IDEwMCB9KSwgITA7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gUm4oZSkge1xuICBjb25zdCB0ID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGx0KGUpIDogZTtcbiAgSnQodCk7XG4gIGZ1bmN0aW9uIHMocikge1xuICAgIGlmICh0eXBlb2YgciA9PSBcInN0cmluZ1wiKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBldmVudFR5cGU6IGkgfSA9IEF0KHIpO1xuICAgICAgICBpID09PSBcIndlYl9hcHBfcmVxdWVzdF90aGVtZVwiICYmIGV0KFwidGhlbWVfY2hhbmdlZFwiLCB7XG4gICAgICAgICAgdGhlbWVfcGFyYW1zOiBKU09OLnBhcnNlKEt0KHQudGhlbWVQYXJhbXMpKVxuICAgICAgICB9KSwgaSA9PT0gXCJ3ZWJfYXBwX3JlcXVlc3Rfdmlld3BvcnRcIiAmJiBldChcInZpZXdwb3J0X2NoYW5nZWRcIiwge1xuICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICBpc19zdGF0ZV9zdGFibGU6ICEwLFxuICAgICAgICAgIGlzX2V4cGFuZGVkOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICB9XG4gIGlmIChhdCgpKSB7XG4gICAgY29uc3QgciA9IHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UuYmluZCh3aW5kb3cucGFyZW50KTtcbiAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlID0gKGkpID0+IHtcbiAgICAgIHMoaSksIHIoaSk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEl0KHdpbmRvdykpIHtcbiAgICBjb25zdCByID0gd2luZG93LmV4dGVybmFsLm5vdGlmeS5iaW5kKHdpbmRvdy5leHRlcm5hbCk7XG4gICAgd2luZG93LmV4dGVybmFsLm5vdGlmeSA9IChpKSA9PiB7XG4gICAgICBzKGkpLCByKGkpO1xuICAgIH07XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG4gPSB3aW5kb3cuVGVsZWdyYW1XZWJ2aWV3UHJveHk7XG4gIHdpbmRvdy5UZWxlZ3JhbVdlYnZpZXdQcm94eSA9IHtcbiAgICAuLi5uIHx8IHt9LFxuICAgIHBvc3RFdmVudCguLi5yKSB7XG4gICAgICBzKEpTT04uc3RyaW5naWZ5KHsgZXZlbnRUeXBlOiByWzBdLCBldmVudERhdGE6IHJbMV0gfSkpLCBuICYmIG4ucG9zdEV2ZW50KC4uLnIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIEFzKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBXO1xufVxuZnVuY3Rpb24geG4oZSwgdCkge1xuICByZXR1cm4gQXMoZSkgJiYgZS50eXBlID09PSB0O1xufVxuZnVuY3Rpb24gSihlLCB0KSB7XG4gIGxldCBzLCBuLCByO1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHMgPSBlIDogKHMgPSBlLnBhdGhuYW1lID09PSB2b2lkIDAgPyB0IDogZS5wYXRobmFtZSwgbiA9IGUucGFyYW1zLCByID0gZS5pZCksIE9iamVjdC5mcmVlemUoe1xuICAgIGlkOiByIHx8IChNYXRoLnJhbmRvbSgpICogMiAqKiAxNCB8IDApLnRvU3RyaW5nKDE2KSxcbiAgICBwYXRobmFtZTogcyxcbiAgICBwYXJhbXM6IG5cbiAgfSk7XG59XG5jbGFzcyBJcyB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4gPSBWKSB7XG4gICAgaWYgKGModGhpcywgXCJoaXN0b3J5XCIpLCBjKHRoaXMsIFwiZWVcIiwgbmV3IEQoKSksIGModGhpcywgXCJhdHRhY2hlZFwiLCAhMSksIGModGhpcywgXCJiYWNrXCIsICgpID0+IHRoaXMuZ28oLTEpKSwgYyh0aGlzLCBcIm9uXCIsIHRoaXMuZWUub24uYmluZCh0aGlzLmVlKSksIGModGhpcywgXCJvZmZcIiwgdGhpcy5lZS5vZmYuYmluZCh0aGlzLmVlKSksIHRoaXMuX2luZGV4ID0gcywgdGhpcy5wb3N0RXZlbnQgPSBuLCB0Lmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG0oYmUsIFwiSGlzdG9yeSBzaG91bGQgbm90IGJlIGVtcHR5LlwiKTtcbiAgICBpZiAocyA8IDAgfHwgcyA+PSB0Lmxlbmd0aClcbiAgICAgIHRocm93IG0oXG4gICAgICAgIHZlLFxuICAgICAgICBcIkluZGV4IHNob3VsZCBub3QgYmUgemVybyBhbmQgaGlnaGVyIG9yIGVxdWFsIHRoYW4gaGlzdG9yeSBzaXplLlwiXG4gICAgICApO1xuICAgIHRoaXMuaGlzdG9yeSA9IHQubWFwKChyKSA9PiBKKHIsIFwiXCIpKTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHRoaXMgbmF2aWdhdG9yIHRvIGNvbnRyb2wgdGhlIGBCYWNrQnV0dG9uYCB2aXNpYmlsaXR5IHN0YXRlLiBJdCBhbHNvIHRyYWNrcyB0aGVcbiAgICogYEJhY2tCdXR0b25gIGNsaWNrcyBhbmQgY2FsbHMgdGhlIGBiYWNrYCBtZXRob2QuXG4gICAqL1xuICBhdHRhY2goKSB7XG4gICAgdGhpcy5hdHRhY2hlZCB8fCAodGhpcy5hdHRhY2hlZCA9ICEwLCB0aGlzLnN5bmMoKSwgeShcImJhY2tfYnV0dG9uX3ByZXNzZWRcIiwgdGhpcy5iYWNrKSk7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnRseSBhY3RpdmUgaGlzdG9yeSBpdGVtLlxuICAgKi9cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeVt0aGlzLmluZGV4XTtcbiAgfVxuICAvKipcbiAgICogUHJldmVudHMgY3VycmVudCBuYXZpZ2F0b3IgZnJvbSBjb250cm9sbGluZyB0aGUgQmFja0J1dHRvbiB2aXNpYmlsaXR5IHN0YXRlLlxuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuYXR0YWNoZWQgPSAhMSwgeihcImJhY2tfYnV0dG9uX3ByZXNzZWRcIiwgdGhpcy5iYWNrKTtcbiAgfVxuICAvKipcbiAgICogR29lcyB0byB0aGUgbmV4dCBoaXN0b3J5IGl0ZW0uXG4gICAqL1xuICBmb3J3YXJkKCkge1xuICAgIHRoaXMuZ28oMSk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgY3VycmVudGx5IGFjdGl2ZSBoaXN0b3J5IGl0ZW0gaW5kZXggYnkgdGhlIHNwZWNpZmllZCBkZWx0YS4gVGhpcyBtZXRob2QgZG9lc24ndFxuICAgKiBjaGFuZ2UgaW5kZXggaW4gY2FzZSwgdGhlIHVwZGF0ZWQgaW5kZXggcG9pbnRzIHRvIHRoZSBub24tZXhpc3RpbmcgaGlzdG9yeSBpdGVtLiBUaGlzIGJlaGF2aW9yXG4gICAqIGlzIHByZXNlcnZlZCB1bnRpbCB0aGUgYGZpdGAgYXJndW1lbnQgaXMgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0gZGVsdGEgLSBpbmRleCBkZWx0YS5cbiAgICogQHBhcmFtIGZpdCAtIGN1dHMgdGhlIGRlbHRhIGFyZ3VtZW50IHRvIGZpdCB0aGUgYm91bmRzIGBbMCwgaGlzdG9yeS5sZW5ndGggLSAxXWAuXG4gICAqL1xuICBnbyh0LCBzKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuaW5kZXggKyB0LCByID0gTWF0aC5taW4oXG4gICAgICBNYXRoLm1heCgwLCBuKSxcbiAgICAgIHRoaXMuaGlzdG9yeS5sZW5ndGggLSAxXG4gICAgKTtcbiAgICAobiA9PT0gciB8fCBzKSAmJiB0aGlzLnJlcGxhY2VBbmRNb3ZlKHIsIHRoaXMuaGlzdG9yeVtyXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdvZXMgdG8gdGhlIHNwZWNpZmllZCBpbmRleC4gTWV0aG9kIGRvZXMgbm90aGluZyBpbiBjYXNlLCBwYXNzZWQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICpcbiAgICogSWYgXCJmaXRcIiBvcHRpb24gd2FzIHNwZWNpZmllZCBhbmQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcywgaXQgd2lsbCBiZSBjdXQgdG8gdGhlIG5lYXJlc3RcbiAgICogYm91bmQuXG4gICAqIEBwYXJhbSBpbmRleCAtIHRhcmdldCBpbmRleC5cbiAgICogQHBhcmFtIGZpdCAtIGN1dHMgdGhlIGluZGV4IGFyZ3VtZW50IHRvIGZpdCB0aGUgYm91bmRzIGBbMCwgaGlzdG9yeS5sZW5ndGggLSAxXWAuXG4gICAqL1xuICBnb1RvKHQsIHMpIHtcbiAgICB0aGlzLmdvKHQgLSB0aGlzLmluZGV4LCBzKTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBuYXZpZ2F0b3IgaGFzIGl0ZW1zIGJlZm9yZSB0aGUgY3VycmVudCBpdGVtLlxuICAgKi9cbiAgZ2V0IGhhc1ByZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggPiAwO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIG5hdmlnYXRvciBoYXMgaXRlbXMgYWZ0ZXIgdGhlIGN1cnJlbnQgaXRlbS5cbiAgICovXG4gIGdldCBoYXNOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ICE9PSB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudGx5IGFjdGl2ZSBoaXN0b3J5IGl0ZW0gaW5kZXguXG4gICAqL1xuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGhpc3RvcnkgaXRlbSByZW1vdmluZyBhbGwgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gYWRkLlxuICAgKi9cbiAgcHVzaCh0KSB7XG4gICAgdGhpcy5oYXNOZXh0ICYmIHRoaXMuaGlzdG9yeS5zcGxpY2UodGhpcy5pbmRleCArIDEpLCB0aGlzLnJlcGxhY2VBbmRNb3ZlKHRoaXMuaW5kZXggKyAxLCBKKHQsIHRoaXMuY3VycmVudC5wYXRobmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBoaXN0b3J5IGl0ZW0uXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byByZXBsYWNlIHRoZSBjdXJyZW50IGl0ZW0gd2l0aC5cbiAgICovXG4gIHJlcGxhY2UodCkge1xuICAgIHRoaXMucmVwbGFjZUFuZE1vdmUodGhpcy5pbmRleCwgSih0LCB0aGlzLmN1cnJlbnQucGF0aG5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBoaXN0b3J5IGl0ZW0gYnkgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IC0gaGlzdG9yeSBpdGVtIGluZGV4IHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSBoaXN0b3J5SXRlbSAtIGhpc3RvcnkgaXRlbSB0byBzZXQuXG4gICAqL1xuICByZXBsYWNlQW5kTW92ZSh0LCBzKSB7XG4gICAgY29uc3QgbiA9IHQgLSB0aGlzLmluZGV4O1xuICAgIGlmICghbiAmJiB0aGlzLmN1cnJlbnQgPT09IHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gdCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2luZGV4O1xuICAgICAgdGhpcy5faW5kZXggPSB0LCB0aGlzLmF0dGFjaGVkICYmIGkgPiAwICE9IHQgPiAwICYmIHRoaXMuc3luYygpO1xuICAgIH1cbiAgICB0aGlzLmhpc3RvcnlbdF0gPSBzLCB0aGlzLmVlLmVtaXQoXCJjaGFuZ2VcIiwge1xuICAgICAgbmF2aWdhdG9yOiB0aGlzLFxuICAgICAgZnJvbTogcixcbiAgICAgIHRvOiB0aGlzLmN1cnJlbnQsXG4gICAgICBkZWx0YTogblxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBY3R1YWxpemVzIHRoZSBgQmFja0J1dHRvbmAgdmlzaWJpbGl0eSBzdGF0ZS5cbiAgICovXG4gIHN5bmMoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCIsIHsgaXNfdmlzaWJsZTogISF0aGlzLmluZGV4IH0pO1xuICB9XG59XG5mdW5jdGlvbiBGKHtcbiAgcGFyYW1zOiBlLFxuICAuLi50XG59KSB7XG4gIHJldHVybiB7IC4uLmUgfHwgeyBoYXNoOiBcIlwiLCBzZWFyY2g6IFwiXCIgfSwgLi4udCB9O1xufVxuZnVuY3Rpb24gVShlKSB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZS5zdGFydHNXaXRoKFwiL1wiKSA6ICEhKGUucGF0aG5hbWUgJiYgZS5wYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSksIHMgPSBNKGUpO1xuICByZXR1cm4gYCR7dCA/IHMucGF0aG5hbWUgOiBzLnBhdGhuYW1lLnNsaWNlKDEpfSR7cy5zZWFyY2h9JHtzLmhhc2h9YDtcbn1cbmZ1bmN0aW9uIFEoZSwgdCwgcykge1xuICBsZXQgbiwgcjtcbiAgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IG4gPSBlIDogKG4gPSBVKGUpLCBzID0gZS5zdGF0ZSwgciA9IGUuaWQpO1xuICBjb25zdCB7IHBhdGhuYW1lOiBpLCBzZWFyY2g6IG8sIGhhc2g6IGEgfSA9IG5ldyBVUkwobiwgYGh0dHA6Ly9hJHtCKHQsIFwiL1wiKX1gKTtcbiAgcmV0dXJuIHsgaWQ6IHIsIHBhdGhuYW1lOiBpLCBwYXJhbXM6IHsgaGFzaDogYSwgc2VhcmNoOiBvLCBzdGF0ZTogcyB9IH07XG59XG5hc3luYyBmdW5jdGlvbiBOKGUpIHtcbiAgcmV0dXJuIGUgPT09IDAgPyAhMCA6IFByb21pc2UucmFjZShbXG4gICAgbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0dChcInBvcHN0YXRlXCIsICgpID0+IHtcbiAgICAgICAgcygpLCB0KCEwKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93Lmhpc3RvcnkuZ28oZSk7XG4gICAgfSksXG4gICAgLy8gVXN1YWxseSwgaXQgdGFrZXMgYWJvdXQgMW1zIHRvIGVtaXQgdGhpcyBldmVudCwgYnV0IHdlIHVzZSBzb21lIGJ1ZmZlci5cbiAgICBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgc2V0VGltZW91dCh0LCA1MCwgITEpO1xuICAgIH0pXG4gIF0pO1xufVxuYXN5bmMgZnVuY3Rpb24ga3MoKSB7XG4gIGlmICh3aW5kb3cuaGlzdG9yeS5sZW5ndGggPD0gMSB8fCAod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIFwiXCIpLCBhd2FpdCBOKDEgLSB3aW5kb3cuaGlzdG9yeS5sZW5ndGgpKSlcbiAgICByZXR1cm47XG4gIGxldCBlID0gYXdhaXQgTigtMSk7XG4gIGZvciAoOyBlOyApXG4gICAgZSA9IGF3YWl0IE4oLTEpO1xufVxuZnVuY3Rpb24gdGUoZSkge1xuICByZXR1cm4gTShlKS5wYXRobmFtZTtcbn1cbmNvbnN0IEV0ID0gMCwgWSA9IDEsIFogPSAyO1xuY2xhc3MgZWUge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCB7IHBvc3RFdmVudDogbiwgaGFzaE1vZGU6IHIgPSBcImNsYXNzaWNcIiwgYmFzZTogaSB9ID0ge30pIHtcbiAgICBjKHRoaXMsIFwibmF2aWdhdG9yXCIpLCBjKHRoaXMsIFwiZWVcIiwgbmV3IEQoKSksIGModGhpcywgXCJoYXNoTW9kZVwiKSwgYyh0aGlzLCBcImJhc2VcIiksIGModGhpcywgXCJhdHRhY2hlZFwiLCAhMSksIGModGhpcywgXCJvblBvcFN0YXRlXCIsICh7IHN0YXRlOiBvIH0pID0+IHtcbiAgICAgIGlmIChvID09PSBudWxsKVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKHRoaXMucGFyc2VQYXRoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSk7XG4gICAgICBvID09PSBFdCA/IHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKSA6IG8gPT09IFkgJiYgdGhpcy5iYWNrKCksIG8gPT09IFogJiYgdGhpcy5mb3J3YXJkKCk7XG4gICAgfSksIGModGhpcywgXCJvbk5hdmlnYXRvckNoYW5nZVwiLCBhc3luYyAoe1xuICAgICAgdG86IG8sXG4gICAgICBmcm9tOiBhLFxuICAgICAgZGVsdGE6IGhcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkICYmIGF3YWl0IHRoaXMuc3luY0hpc3RvcnkoKSwgdGhpcy5lZS5lbWl0KFwiY2hhbmdlXCIsIHtcbiAgICAgICAgZGVsdGE6IGgsXG4gICAgICAgIGZyb206IEYoYSksXG4gICAgICAgIHRvOiBGKG8pLFxuICAgICAgICBuYXZpZ2F0b3I6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0pLCBjKHRoaXMsIFwib25cIiwgdGhpcy5lZS5vbi5iaW5kKHRoaXMuZWUpKSwgYyh0aGlzLCBcIm9mZlwiLCB0aGlzLmVlLm9mZi5iaW5kKHRoaXMuZWUpKSwgdGhpcy5uYXZpZ2F0b3IgPSBuZXcgSXMoXG4gICAgICB0Lm1hcCgobykgPT4gUShvLCBcIi9cIikpLFxuICAgICAgcyxcbiAgICAgIG5cbiAgICApLCB0aGlzLm5hdmlnYXRvci5vbihcImNoYW5nZVwiLCAobykgPT4ge1xuICAgICAgdGhpcy5vbk5hdmlnYXRvckNoYW5nZShvKTtcbiAgICB9KSwgdGhpcy5oYXNoTW9kZSA9IHIsIHRoaXMuYmFzZSA9IHRlKGkgfHwgXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGN1cnJlbnQgbmF2aWdhdG9yIHRvIHRoZSBicm93c2VyIGhpc3RvcnkgYWxsb3dpbmcgbmF2aWdhdG9yIHRvIG1hbmlwdWxhdGUgaXQuXG4gICAqL1xuICBhc3luYyBhdHRhY2goKSB7XG4gICAgdGhpcy5hdHRhY2hlZCB8fCAodGhpcy5hdHRhY2hlZCA9ICEwLCB0aGlzLm5hdmlnYXRvci5hdHRhY2goKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpLCBhd2FpdCB0aGlzLnN5bmNIaXN0b3J5KCkpO1xuICB9XG4gIC8qKlxuICAgKiBHb2VzIGJhY2sgaW4gaGlzdG9yeSBieSAxLlxuICAgKi9cbiAgYmFjaygpIHtcbiAgICB0aGlzLm5hdmlnYXRvci5iYWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaGVzIGN1cnJlbnQgbmF2aWdhdG9yIGZyb20gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmF0dGFjaGVkID0gITEsIHRoaXMubmF2aWdhdG9yLmRldGFjaCgpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdvZXMgZm9yd2FyZCBpbiBoaXN0b3J5LlxuICAgKi9cbiAgZm9yd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuZm9yd2FyZCgpO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IGhpc3RvcnkgY3Vyc29yLlxuICAgKi9cbiAgZ2V0IGluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5pbmRleDtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBoaXN0b3J5IGl0ZW0gaWRlbnRpZmllci5cbiAgICovXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuY3VycmVudC5pZDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBjdXJyZW50bHkgYWN0aXZlIGhpc3RvcnkgaXRlbSBpbmRleCBieSB0aGUgc3BlY2lmaWVkIGRlbHRhLiBUaGlzIG1ldGhvZCBkb2Vzbid0XG4gICAqIGNoYW5nZSBpbmRleCBpbiBjYXNlLCB0aGUgdXBkYXRlZCBpbmRleCBwb2ludHMgdG8gdGhlIG5vbi1leGlzdGluZyBoaXN0b3J5IGl0ZW0uIFRoaXMgYmVoYXZpb3JcbiAgICogaXMgcHJlc2VydmVkIHVudGlsIHRoZSBgZml0YCBhcmd1bWVudCBpcyBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSBkZWx0YSAtIGluZGV4IGRlbHRhLlxuICAgKiBAcGFyYW0gZml0IC0gY3V0cyB0aGUgZGVsdGEgYXJndW1lbnQgdG8gZml0IHRoZSBib3VuZHMgYFswLCBoaXN0b3J5Lmxlbmd0aCAtIDFdYC5cbiAgICovXG4gIGdvKHQsIHMpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuZ28odCwgcyk7XG4gIH1cbiAgLyoqXG4gICAqIEdvZXMgdG8gdGhlIHNwZWNpZmllZCBpbmRleC4gTWV0aG9kIGRvZXMgbm90aGluZyBpbiBjYXNlLCBwYXNzZWQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICpcbiAgICogSWYgXCJmaXRcIiBvcHRpb24gd2FzIHNwZWNpZmllZCBhbmQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcywgaXQgd2lsbCBiZSBjdXQgdG8gdGhlIG5lYXJlc3RcbiAgICogYm91bmQuXG4gICAqIEBwYXJhbSBpbmRleCAtIHRhcmdldCBpbmRleC5cbiAgICogQHBhcmFtIGZpdCAtIGN1dHMgdGhlIGluZGV4IGFyZ3VtZW50IHRvIGZpdCB0aGUgYm91bmRzIGBbMCwgaGlzdG9yeS5sZW5ndGggLSAxXWAuXG4gICAqL1xuICBnb1RvKHQsIHMpIHtcbiAgICB0aGlzLm5hdmlnYXRvci5nb1RvKHQsIHMpO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IGhpc3RvcnkgaXRlbSBoYXNoLlxuICAgKiBAc2VlIFVSTC5oYXNoXG4gICAqIEBleGFtcGxlXG4gICAqIFwiXCIsIFwiI215LWhhc2hcIlxuICAgKi9cbiAgZ2V0IGhhc2goKSB7XG4gICAgcmV0dXJuICh0aGlzLm5hdmlnYXRvci5jdXJyZW50LnBhcmFtcyB8fCB7fSkuaGFzaCB8fCBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIG5hdmlnYXRvciBoYXMgaXRlbXMgYmVmb3JlIHRoZSBjdXJyZW50IGl0ZW0uXG4gICAqL1xuICBnZXQgaGFzUHJldigpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuaGFzUHJldjtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBuYXZpZ2F0b3IgaGFzIGl0ZW1zIGFmdGVyIHRoZSBjdXJyZW50IGl0ZW0uXG4gICAqL1xuICBnZXQgaGFzTmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuaGFzTmV4dDtcbiAgfVxuICAvKipcbiAgICogTmF2aWdhdGlvbiBoaXN0b3J5LlxuICAgKi9cbiAgZ2V0IGhpc3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmhpc3RvcnkubWFwKEYpO1xuICB9XG4gIC8qKlxuICAgKiBQYXRoLCBpbmNsdWRpbmcgcGF0aG5hbWUsIHNlYXJjaCBhbmQgaGFzaC5cbiAgICogQGV4YW1wbGUgUGF0aG5hbWUgb25seS5cbiAgICogXCIvcGF0aG5hbWVcIlxuICAgKiBAZXhhbXBsZSBQYXRobmFtZSArIHNlYXJjaC5cbiAgICogXCIvcGF0aG5hbWU/c2VhcmNoXCJcbiAgICogQGV4YW1wbGUgUGF0aG5hbWUgKyBoYXNoLlxuICAgKiBcIi9wYXRobmFtZSNoYXNoXCJcbiAgICogQGV4YW1wbGUgUGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoLlxuICAgKiBcIi9wYXRobmFtZT9zZWFyY2gjaGFzaFwiXG4gICAqL1xuICBnZXQgcGF0aCgpIHtcbiAgICByZXR1cm4gVSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBwYXRobmFtZS4gQWx3YXlzIHN0YXJ0cyB3aXRoIHRoZSBzbGFzaC5cbiAgICogQHNlZSBVUkwucGF0aG5hbWVcbiAgICogQGV4YW1wbGVcbiAgICogXCIvXCIsIFwiL2FiY1wiXG4gICAqL1xuICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmN1cnJlbnQucGF0aG5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIERlcGVuZGluZyBvbiB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIHR5cGUsIHBhcnNlcyBpbmNvbWluZyBwYXRoIGFuZCByZXR1cm5zIGl0IHByZXNlbnRlZCBhc1xuICAgKiBhbiBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG1ldGhvZCBwYXJzZXMgdGhlIHBhc3NlZCBwYXRoIGFuZCByZXR1cm5zIG9iamVjdCwgZGVzY3JpYmluZ1xuICAgKiBob3cgdGhlIG5hdmlnYXRvciBcInNlZXNcIiBpdC5cbiAgICpcbiAgICogQGV4YW1wbGUgSGFzaCBtb2RlIGlzIG9taXR0ZWQuXG4gICAqIHBhcnNlUGF0aCgnL2FiYz9hPTEjaGFzaCcpO1xuICAgKiAvLyB7IHBhdGhuYW1lOiAnL2FiYycsIHNlYXJjaDogJz9hPTEnLCBoYXNoOiAnI2hhc2gnIH1cbiAgICogcGFyc2VQYXRoKCdodHRwOi8vZXhhbXBsZS5jb20vYWJjP2E9MSNoYXNoJyk7XG4gICAqIC8vIHsgcGF0aG5hbWU6ICcvYWJjJywgc2VhcmNoOiAnP2E9MScsIGhhc2g6ICcjaGFzaCcgfVxuICAgKlxuICAgKiBAZXhhbXBsZSBIYXNoIG1vZGUgaXMgZW5hYmxlZC5cbiAgICogcGFyc2VQYXRoKCcvYWJjP2E9MSN0bWE/aXM9Y29vbCN5ZWFoJyk7XG4gICAqIC8vIHsgcGF0aG5hbWU6ICcvdG1hJywgc2VhcmNoOiAnP2lzPWNvb2wnLCBoYXNoOiAnI3llYWgnIH1cbiAgICogcGFyc2VQYXRoKCdodHRwOi8vZXhhbXBsZS5jb20vYWJjP2E9MSN0bWE/aXM9Y29vbCN5ZWFoJyk7XG4gICAqIC8vIHsgcGF0aG5hbWU6ICcvdG1hJywgc2VhcmNoOiAnP2lzPWNvb2wnLCBoYXNoOiAnI3llYWgnIH1cbiAgICovXG4gIHBhcnNlUGF0aCh0KSB7XG4gICAgbGV0IHMgPSBNKHQpO1xuICAgIHJldHVybiB0aGlzLmhhc2hNb2RlICYmIChzID0gTShzLmhhc2guc2xpY2UoMSkpKSwge1xuICAgICAgcGF0aG5hbWU6IHMucGF0aG5hbWUsXG4gICAgICBzZWFyY2g6IHMuc2VhcmNoLFxuICAgICAgaGFzaDogcy5oYXNoXG4gICAgfTtcbiAgfVxuICBwdXNoKHQsIHMpIHtcbiAgICBjb25zdCBuID0gUSh0LCB0aGlzLnBhdGgpLCB7IHN0YXRlOiByID0gcyB9ID0gbi5wYXJhbXM7XG4gICAgdGhpcy5uYXZpZ2F0b3IucHVzaCh7IC4uLm4sIHBhcmFtczogeyAuLi5uLnBhcmFtcywgc3RhdGU6IHIgfSB9KTtcbiAgfVxuICByZXBsYWNlKHQsIHMpIHtcbiAgICBjb25zdCBuID0gUSh0LCB0aGlzLnBhdGgpLCB7IHN0YXRlOiByID0gcyB9ID0gbi5wYXJhbXM7XG4gICAgdGhpcy5uYXZpZ2F0b3IucmVwbGFjZSh7IC4uLm4sIHBhcmFtczogeyAuLi5uLnBhcmFtcywgc3RhdGU6IHIgfSB9KTtcbiAgfVxuICAvKipcbiAgICogQ29tYmluZXMgdGhlIG5hdmlnYXRvciBgYmFzZWAgcHJvcGVydHkgd2l0aCB0aGUgcGFzc2VkIHBhdGggZGF0YSBhcHBseWluZyB0aGUgbmF2aWdhdG9yXG4gICAqIG5hdmlnYXRpb24gbW9kZS5cbiAgICogQHBhcmFtIHZhbHVlIC0gcGF0aCBwcmVzZW50ZWQgYXMgc3RyaW5nIG9yIFVSTExpa2UuXG4gICAqL1xuICByZW5kZXJQYXRoKHQpIHtcbiAgICBjb25zdCBzID0gKHRoaXMuYmFzZS5sZW5ndGggPT09IDEgPyBcIlwiIDogdGhpcy5iYXNlKSArIEIoVSh0KSwgXCIvXCIpO1xuICAgIHJldHVybiB0aGlzLmhhc2hNb2RlID8gQihzLnNsaWNlKDEpLCB0aGlzLmhhc2hNb2RlID09PSBcImNsYXNzaWNcIiA/IFwiI1wiIDogXCIjL1wiKSA6IHM7XG4gIH1cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyBjdXJyZW50IG5hdmlnYXRvciBzdGF0ZSB3aXRoIGJyb3dzZXIgaGlzdG9yeS5cbiAgICovXG4gIGFzeW5jIHN5bmNIaXN0b3J5KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKTtcbiAgICBjb25zdCB7IHN0YXRlOiB0IH0gPSB0aGlzLCBzID0gdGhpcy5yZW5kZXJQYXRoKHRoaXMpO1xuICAgIGF3YWl0IGtzKCksIHRoaXMuaGFzUHJldiAmJiB0aGlzLmhhc05leHQgPyAod2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFksIFwiXCIpLCB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUodCwgXCJcIiwgcyksIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShaLCBcIlwiKSwgYXdhaXQgTigtMSkpIDogdGhpcy5oYXNQcmV2ID8gKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShZLCBcIlwiKSwgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHQsIFwiXCIsIHMpKSA6IHRoaXMuaGFzTmV4dCA/ICh3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUodCwgcyksIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShaLCBcIlwiKSwgYXdhaXQgTigtMSkpIDogKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShFdCwgXCJcIiksIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh0LCBcIlwiLCBzKSksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgKiBAc2VlIFVSTC5zZWFyY2hcbiAgICogQGV4YW1wbGVcbiAgICogXCJcIiwgXCI/XCIsIFwiP2E9MVwiXG4gICAqL1xuICBnZXQgc2VhcmNoKCkge1xuICAgIHJldHVybiAodGhpcy5uYXZpZ2F0b3IuY3VycmVudC5wYXJhbXMgfHwge30pLnNlYXJjaCB8fCBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IGhpc3RvcnkgaXRlbSBzdGF0ZS5cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gKHRoaXMubmF2aWdhdG9yLmN1cnJlbnQucGFyYW1zIHx8IHt9KS5zdGF0ZTtcbiAgfVxufVxuZnVuY3Rpb24gT3MoZSkge1xuICBlIHx8IChlID0ge30pO1xuICBjb25zdCB7IGhyZWY6IHQsIGhhc2g6IHMgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgbGV0IG4gPSBVKFxuICAgIGUuaGFzaE1vZGUgPT09IG51bGwgPyB0IDogcy5pbmNsdWRlcyhcIj9cIikgPyBzLnNsaWNlKDEpIDogYD8ke3Muc2xpY2UoMSl9YFxuICApO1xuICBjb25zdCByID0gZS5iYXNlID8gdGUoZS5iYXNlKSA6IHZvaWQgMDtcbiAgaWYgKHIpIHtcbiAgICBpZiAoIW4uc3RhcnRzV2l0aChyKSlcbiAgICAgIHRocm93IG0oXG4gICAgICAgIHllLFxuICAgICAgICBgUGF0aCBcIiR7bn1cIiBleHBlY3RlZCB0byBiZSBzdGFydGluZyB3aXRoIFwiJHtyfVwiYFxuICAgICAgKTtcbiAgICBuID0gbi5zbGljZShyLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBlZShbbl0sIDAsIGUpO1xufVxuZnVuY3Rpb24gQ24oZSkge1xuICBjb25zdCB0ID0gZS5tYXRjaCgvIyguKykvKTtcbiAgcmV0dXJuIHQgPyB0WzFdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHFzKGUsIHQpIHtcbiAgaWYgKEZ0KCkpIHtcbiAgICBjb25zdCBzID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShlKTtcbiAgICBpZiAocylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgaW5kZXg6IG4sIGhpc3Rvcnk6IHIgfSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgIHJldHVybiBuZXcgZWUoXG4gICAgICAgICAgcixcbiAgICAgICAgICBuLFxuICAgICAgICAgIHRcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byByZXN0b3JlIGhhc2ggbmF2aWdhdG9yIHN0YXRlLlwiLCBuKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gT3ModCk7XG59XG5mdW5jdGlvbiBTbihlLCB0KSB7XG4gIGNvbnN0IHMgPSBxcyhlLCB0KSwgbiA9ICgpID0+IHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oZSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgIGluZGV4OiBzLmluZGV4LFxuICAgIGhpc3Rvcnk6IHMuaGlzdG9yeVxuICB9KSk7XG4gIHJldHVybiBzLm9uKFwiY2hhbmdlXCIsIG4pLCBuKCksIHM7XG59XG5mdW5jdGlvbiBkKGUsIHQpIHtcbiAgZnVuY3Rpb24gcyhuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGksIG8sIGEpIHtcbiAgICAgIHJldHVybiAoaCkgPT4ge1xuICAgICAgICBjb25zdCBwID0ge1xuICAgICAgICAgIC4uLmgsXG4gICAgICAgICAgW2ldOiBuKG8pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUHQoYSwgeyAuLi5wIH0pO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBbcyhlKSwgcyh0KV07XG59XG5jb25zdCBzZSA9IG5lKHZvaWQgMCk7XG5mdW5jdGlvbiBOcygpIHtcbiAgY29uc3QgZSA9IHJlKHNlKTtcbiAgaWYgKCFlKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZVNESyB3YXMgdXNlZCBvdXRzaWRlIHRoZSBTREtQcm92aWRlci5cIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gXyhlKSB7XG4gIGZ1bmN0aW9uIHQobikge1xuICAgIGNvbnN0IHIgPSBOcygpLCBbaSwgb10gPSBydChcbiAgICAgIG4gPyB2b2lkIDAgOiAoKSA9PiB7XG4gICAgICAgIGlmIChUcygpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzaW5nIGhvb2tzIG9uIHRoZSBzZXJ2ZXIgc2lkZSwgeW91IG11c3QgZXhwbGljaXRseSBzcGVjaWZ5IHNzciA9IHRydWUgb3B0aW9uXCIpO1xuICAgICAgICByZXR1cm4gci51c2UoZSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gUigoKSA9PiB7XG4gICAgICBvKHIudXNlKGUpKTtcbiAgICB9LCBbcl0pLCBpO1xuICB9XG4gIGZ1bmN0aW9uIHMobikge1xuICAgIGNvbnN0IHIgPSB0KG4pO1xuICAgIGlmIChyKSB7XG4gICAgICBpZiAoXCJlcnJvclwiIGluIHIpXG4gICAgICAgIHRocm93IHIuZXJyb3I7XG4gICAgICByZXR1cm4gci5yZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBbdCwgc107XG59XG5jb25zdCBbRHMsIFZzXSA9IF8oamUpLCBbVG4sIEFuXSA9IGQoXG4gIERzLFxuICBWc1xuKSwgW0JzLCBNc10gPSBfKEplKSwgW0luLCBrbl0gPSBkKFxuICBCcyxcbiAgTXNcbiksIFtMcywgJHNdID0gXyhRZSksIFtPbiwgcW5dID0gZChcbiAgTHMsXG4gICRzXG4pLCBbSHMsIFVzXSA9IF8oZXMpLCBbTm4sIERuXSA9IGQoXG4gIEhzLFxuICBVc1xuKSwgW1dzLCBHc10gPSBfKG5zKSwgW1ZuLCBCbl0gPSBkKFxuICBXcyxcbiAgR3NcbiksIFtqcywgenNdID0gXyhpcyksIFtNbiwgTG5dID0gZChqcywgenMpLCBbS3MsIEpzXSA9IF8oYXMpLCBbJG4sIEhuXSA9IGQoS3MsIEpzKSwgW0ZzLCBRc10gPSBfKGhzKSwgW1VuLCBXbl0gPSBkKEZzLCBRcyksIFtZcywgWnNdID0gXyhkcyksIFtHbiwgam5dID0gZChZcywgWnMpLCBbWHMsIHRuXSA9IF8od3MpLCBbem4sIEtuXSA9IGQoWHMsIHRuKSwgW2VuLCBzbl0gPSBfKG1zKSwgW0puLCBGbl0gPSBkKGVuLCBzbiksIFtubiwgcm5dID0gXyh2cyksIFtRbiwgWW5dID0gZChcbiAgbm4sXG4gIHJuXG4pLCBbb24sIGFuXSA9IF8oRXMpLCBbWm4sIFhuXSA9IGQob24sIGFuKTtcbmZ1bmN0aW9uIHRyKGUpIHtcbiAgY29uc3QgW3QsIHNdID0gcnQoKCkgPT4gZSA/IHZvaWQgMCA6IG50KCkpO1xuICByZXR1cm4gUigoKSA9PiB7XG4gICAgZSAmJiBzKG50KCkpO1xuICB9LCBbXSksIHQ7XG59XG5jb25zdCBbY24sIGhuXSA9IF8oUnMpLCBbZXIsIHNyXSA9IGQoY24sIGhuKSwgW3BuLCB1bl0gPSBfKENzKSwgW25yLCBycl0gPSBkKHBuLCB1bik7XG5mdW5jdGlvbiBpcih7IGNoaWxkcmVuOiBlLCBhY2NlcHRDdXN0b21TdHlsZXM6IHQsIGRlYnVnOiBzIH0pIHtcbiAgY29uc3QgbiA9IG10KCEwKSwgW3IsIGldID0gcnQoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIG8gPSBtdChyKSwgYSA9IGllKFxuICAgIChwKSA9PiB7XG4gICAgICBuLmN1cnJlbnQgJiYgaSgoUykgPT4gKHAgJiYgcChTKSwgbmV3IE1hcChTKSkpO1xuICAgIH0sXG4gICAgW11cbiAgKSwgaCA9IG9lKCgpID0+ICh7XG4gICAgdXNlKHAsIC4uLlMpIHtcbiAgICAgIGNvbnN0IGd0ID0gci5nZXQocCk7XG4gICAgICBpZiAoZ3QpXG4gICAgICAgIHJldHVybiBndDtcbiAgICAgIGxldCBiLCBLO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYiA9IHAoLi4uUyk7XG4gICAgICB9IGNhdGNoICh3KSB7XG4gICAgICAgIEsgPSB3O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gSCh3KSB7XG4gICAgICAgIHJldHVybiByLnNldChwLCB3KSwgdztcbiAgICAgIH1cbiAgICAgIGlmIChLKVxuICAgICAgICByZXR1cm4gSCh7IGVycm9yOiBLIH0pO1xuICAgICAgbGV0IEk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSAmJiAoSSA9IGJbMV0sIGIgPSBiWzBdKSwgIWIpXG4gICAgICAgIHJldHVybiBIKHsgcmVzdWx0OiBiLCBjbGVhbnVwOiBJIH0pO1xuICAgICAgZnVuY3Rpb24gd3Qodykge1xuICAgICAgICBpZiAoXCJvblwiIGluIHcpIHtcbiAgICAgICAgICBjb25zdCBrID0gdy5vbihcImNoYW5nZVwiLCAoKSA9PiBhKCkpLCBmdCA9IEk7XG4gICAgICAgICAgSSA9ICgpID0+IHtcbiAgICAgICAgICAgIGZ0ICYmIGZ0KCksIGsoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdywgY2xlYW51cDogSSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGIgaW5zdGFuY2VvZiBQcm9taXNlID8gKGIudGhlbihcbiAgICAgICAgKHcpID0+IGEoKGspID0+IGsuc2V0KHAsIHd0KHcpKSksXG4gICAgICAgICh3KSA9PiBhKChrKSA9PiBrLnNldChwLCB7IGVycm9yOiB3IH0pKVxuICAgICAgKSwgSCh7fSkpIDogSCh3dChiKSk7XG4gICAgfVxuICB9KSwgW3JdKTtcbiAgcmV0dXJuIFIoKCkgPT4gKG4uY3VycmVudCA9ICEwLCAoKSA9PiB7XG4gICAgbi5jdXJyZW50ID0gITE7XG4gIH0pLCBbXSksIFIoKCkgPT4ge1xuICAgIGlmIChhdCgpKVxuICAgICAgcmV0dXJuIFNzKHQpO1xuICB9LCBbdF0pLCBSKCgpID0+IHtcbiAgICB1ZShzIHx8ICExKTtcbiAgfSwgW3NdKSwgUigoKSA9PiB7XG4gICAgby5jdXJyZW50ID0gcjtcbiAgfSwgW3JdKSwgUigoKSA9PiAoKSA9PiB7XG4gICAgby5jdXJyZW50LmZvckVhY2goKHApID0+IHtcbiAgICAgIFwiY2xlYW51cFwiIGluIHAgJiYgcC5jbGVhbnVwICYmIHAuY2xlYW51cCgpO1xuICAgIH0pO1xuICB9LCBbXSksIC8qIEBfX1BVUkVfXyAqLyBQdChzZS5Qcm92aWRlciwgeyB2YWx1ZTogaCwgY2hpbGRyZW46IGUgfSk7XG59XG5leHBvcnQge1xuICBOZSBhcyBCYWNrQnV0dG9uLFxuICBJcyBhcyBCYXNpY05hdmlnYXRvcixcbiAgemUgYXMgQmlvbWV0cnlNYW5hZ2VyLFxuICBlZSBhcyBCcm93c2VyTmF2aWdhdG9yLFxuICBGZSBhcyBDbG9zaW5nQmVoYXZpb3IsXG4gIHRzIGFzIENsb3VkU3RvcmFnZSxcbiAgeWUgYXMgRVJSX0lOVkFMSURfUEFUSF9CQVNFLFxuICB3ZSBhcyBFUlJfSU5WT0tFX0NVU1RPTV9NRVRIT0RfUkVTUE9OU0UsXG4gIF9lIGFzIEVSUl9NRVRIT0RfUEFSQU1FVEVSX1VOU1VQUE9SVEVELFxuICBkZSBhcyBFUlJfTUVUSE9EX1VOU1VQUE9SVEVELFxuICBiZSBhcyBFUlJfTkFWSUdBVElPTl9ISVNUT1JZX0VNUFRZLFxuICB2ZSBhcyBFUlJfTkFWSUdBVElPTl9JTkRFWF9JTlZBTElELFxuICBfbiBhcyBFUlJfTkFWSUdBVElPTl9JVEVNX0lOVkFMSUQsXG4gIEN0IGFzIEVSUl9QQVJTRSxcbiAgZ24gYXMgRVJSX1NTUl9JTklULFxuICBmZSBhcyBFUlJfVElNRURfT1VULFxuICBtZSBhcyBFUlJfVU5FWFBFQ1RFRF9UWVBFLFxuICBnZSBhcyBFUlJfVU5LTk9XTl9FTlYsXG4gIEQgYXMgRXZlbnRFbWl0dGVyLFxuICBzcyBhcyBIYXB0aWNGZWVkYmFjayxcbiAgcnMgYXMgSW5pdERhdGEsXG4gIG9zIGFzIEludm9pY2UsXG4gIGNzIGFzIE1haW5CdXR0b24sXG4gIGxzIGFzIE1pbmlBcHAsXG4gIGdzIGFzIFBvcHVwLFxuICBmcyBhcyBRUlNjYW5uZXIsXG4gIFcgYXMgU0RLRXJyb3IsXG4gIGlyIGFzIFNES1Byb3ZpZGVyLFxuICBicyBhcyBTZXR0aW5nc0J1dHRvbixcbiAgeXMgYXMgVGhlbWVQYXJhbXMsXG4gIFBzIGFzIFV0aWxzLFxuICB4cyBhcyBWaWV3cG9ydCxcbiAgWGUgYXMgYXJyYXksXG4gIHZuIGFzIGJpbmRNaW5pQXBwQ1NTVmFycyxcbiAgeW4gYXMgYmluZFRoZW1lUGFyYW1zQ1NTVmFycyxcbiAgRW4gYXMgYmluZFZpZXdwb3J0Q1NTVmFycyxcbiAgRSBhcyBib29sZWFuLFxuICBxdCBhcyBjYXB0dXJlU2FtZVJlcSxcbiAgc3QgYXMgY2xhc3NOYW1lcyxcbiAgVGUgYXMgY29tcGFyZVZlcnNpb25zLFxuICBPcyBhcyBjcmVhdGVCcm93c2VyTmF2aWdhdG9yRnJvbUxvY2F0aW9uLFxuICBrZSBhcyBjcmVhdGVQb3N0RXZlbnQsXG4gIE0gYXMgY3JlYXRlU2FmZVVSTCxcbiAgTHQgYXMgZGF0ZSxcbiAgQ24gYXMgZ2V0SGFzaCxcbiAgdGUgYXMgZ2V0UGF0aG5hbWUsXG4gIGplIGFzIGluaXRCYWNrQnV0dG9uLFxuICBKZSBhcyBpbml0QmlvbWV0cnlNYW5hZ2VyLFxuICBRZSBhcyBpbml0Q2xvc2luZ0JlaGF2aW9yLFxuICBlcyBhcyBpbml0Q2xvdWRTdG9yYWdlLFxuICBucyBhcyBpbml0SGFwdGljRmVlZGJhY2ssXG4gIGlzIGFzIGluaXRJbml0RGF0YSxcbiAgYXMgYXMgaW5pdEludm9pY2UsXG4gIGhzIGFzIGluaXRNYWluQnV0dG9uLFxuICBkcyBhcyBpbml0TWluaUFwcCxcbiAgU24gYXMgaW5pdE5hdmlnYXRvcixcbiAgd3MgYXMgaW5pdFBvcHVwLFxuICBtcyBhcyBpbml0UVJTY2FubmVyLFxuICB2cyBhcyBpbml0U2V0dGluZ3NCdXR0b24sXG4gIEVzIGFzIGluaXRUaGVtZVBhcmFtcyxcbiAgUnMgYXMgaW5pdFV0aWxzLFxuICBDcyBhcyBpbml0Vmlld3BvcnQsXG4gIFNzIGFzIGluaXRXZWIsXG4gIHEgYXMgaW52b2tlQ3VzdG9tTWV0aG9kLFxuICBCdCBhcyBpc0NvbG9yRGFyayxcbiAgYXQgYXMgaXNJZnJhbWUsXG4gIEZ0IGFzIGlzUGFnZVJlbG9hZCxcbiAgY3QgYXMgaXNSR0IsXG4gIE9lIGFzIGlzUkdCU2hvcnQsXG4gIEFzIGFzIGlzU0RLRXJyb3IsXG4gIHhuIGFzIGlzU0RLRXJyb3JPZlR5cGUsXG4gIFRzIGFzIGlzU1NSLFxuICBQbiBhcyBpc1RNQSxcbiAgdiBhcyBqc29uLFxuICBmbiBhcyBtZXJnZUNsYXNzTmFtZXMsXG4gIFJuIGFzIG1vY2tUZWxlZ3JhbUVudixcbiAgeCBhcyBudW1iZXIsXG4gIHogYXMgb2ZmLFxuICB5IGFzIG9uLFxuICBtbiBhcyBwYXJzZUluaXREYXRhLFxuICBsdCBhcyBwYXJzZUxhdW5jaFBhcmFtcyxcbiAgWnQgYXMgcGFyc2VUaGVtZVBhcmFtcyxcbiAgViBhcyBwb3N0RXZlbnQsXG4gIGcgYXMgcmVxdWVzdCxcbiAgS2UgYXMgcmVxdWVzdEJpb21ldHJ5SW5mbyxcbiAgYm4gYXMgcmVxdWVzdFRoZW1lUGFyYW1zLFxuICBYdCBhcyByZXF1ZXN0Vmlld3BvcnQsXG4gIG50IGFzIHJldHJpZXZlTGF1bmNoUGFyYW1zLFxuICBWZSBhcyByZ2IsXG4gIHV0IGFzIHNlYXJjaFBhcmFtcyxcbiAgVWUgYXMgc2VyaWFsaXplTGF1bmNoUGFyYW1zLFxuICBLdCBhcyBzZXJpYWxpemVUaGVtZVBhcmFtcyxcbiAgUCBhcyBzZXRDU1NWYXIsXG4gIHVlIGFzIHNldERlYnVnLFxuICB3biBhcyBzZXRUYXJnZXRPcmlnaW4sXG4gIHUgYXMgc3RyaW5nLFxuICBoZSBhcyBzdWJzY3JpYmUsXG4gIEMgYXMgc3VwcG9ydHMsXG4gIEllIGFzIHRhcmdldE9yaWdpbixcbiAgVnQgYXMgdG9SR0IsXG4gIHh0IGFzIHVuc3Vic2NyaWJlLFxuICBVIGFzIHVybFRvUGF0aCxcbiAgVnMgYXMgdXNlQmFja0J1dHRvbixcbiAgRHMgYXMgdXNlQmFja0J1dHRvblJhdyxcbiAgTXMgYXMgdXNlQmlvbWV0cnlNYW5hZ2VyLFxuICBCcyBhcyB1c2VCaW9tZXRyeU1hbmFnZXJSYXcsXG4gICRzIGFzIHVzZUNsb3NpbmdCZWhhdmlvcixcbiAgTHMgYXMgdXNlQ2xvc2luZ0JlaGF2aW9yUmF3LFxuICBVcyBhcyB1c2VDbG91ZFN0b3JhZ2UsXG4gIEhzIGFzIHVzZUNsb3VkU3RvcmFnZVJhdyxcbiAgR3MgYXMgdXNlSGFwdGljRmVlZGJhY2ssXG4gIFdzIGFzIHVzZUhhcHRpY0ZlZWRiYWNrUmF3LFxuICB6cyBhcyB1c2VJbml0RGF0YSxcbiAganMgYXMgdXNlSW5pdERhdGFSYXcsXG4gIEpzIGFzIHVzZUludm9pY2UsXG4gIEtzIGFzIHVzZUludm9pY2VSYXcsXG4gIHRyIGFzIHVzZUxhdW5jaFBhcmFtcyxcbiAgUXMgYXMgdXNlTWFpbkJ1dHRvbixcbiAgRnMgYXMgdXNlTWFpbkJ1dHRvblJhdyxcbiAgWnMgYXMgdXNlTWluaUFwcCxcbiAgWXMgYXMgdXNlTWluaUFwcFJhdyxcbiAgdG4gYXMgdXNlUG9wdXAsXG4gIFhzIGFzIHVzZVBvcHVwUmF3LFxuICBzbiBhcyB1c2VRUlNjYW5uZXIsXG4gIGVuIGFzIHVzZVFSU2Nhbm5lclJhdyxcbiAgTnMgYXMgdXNlU0RLLFxuICBybiBhcyB1c2VTZXR0aW5nc0J1dHRvbixcbiAgbm4gYXMgdXNlU2V0dGluZ3NCdXR0b25SYXcsXG4gIGFuIGFzIHVzZVRoZW1lUGFyYW1zLFxuICBvbiBhcyB1c2VUaGVtZVBhcmFtc1JhdyxcbiAgaG4gYXMgdXNlVXRpbHMsXG4gIGNuIGFzIHVzZVV0aWxzUmF3LFxuICB1biBhcyB1c2VWaWV3cG9ydCxcbiAgcG4gYXMgdXNlVmlld3BvcnRSYXcsXG4gIEFuIGFzIHdpdGhCYWNrQnV0dG9uLFxuICBUbiBhcyB3aXRoQmFja0J1dHRvblJhdyxcbiAga24gYXMgd2l0aEJpb21ldHJ5TWFuYWdlcixcbiAgSW4gYXMgd2l0aEJpb21ldHJ5TWFuYWdlclJhdyxcbiAgcW4gYXMgd2l0aENsb3NpbmdCZWhhdmlvcixcbiAgT24gYXMgd2l0aENsb3NpbmdCZWhhdmlvclJhdyxcbiAgRG4gYXMgd2l0aENsb3VkU3RvcmFnZSxcbiAgTm4gYXMgd2l0aENsb3VkU3RvcmFnZVJhdyxcbiAgQm4gYXMgd2l0aEhhcHRpY0ZlZWRiYWNrLFxuICBWbiBhcyB3aXRoSGFwdGljRmVlZGJhY2tSYXcsXG4gIExuIGFzIHdpdGhJbml0RGF0YSxcbiAgTW4gYXMgd2l0aEluaXREYXRhUmF3LFxuICBIbiBhcyB3aXRoSW52b2ljZSxcbiAgJG4gYXMgd2l0aEludm9pY2VSYXcsXG4gIFduIGFzIHdpdGhNYWluQnV0dG9uLFxuICBVbiBhcyB3aXRoTWFpbkJ1dHRvblJhdyxcbiAgam4gYXMgd2l0aE1pbmlBcHAsXG4gIEduIGFzIHdpdGhNaW5pQXBwUmF3LFxuICBLbiBhcyB3aXRoUG9wdXAsXG4gIHpuIGFzIHdpdGhQb3B1cFJhdyxcbiAgRm4gYXMgd2l0aFFSU2Nhbm5lcixcbiAgSm4gYXMgd2l0aFFSU2Nhbm5lclJhdyxcbiAgWW4gYXMgd2l0aFNldHRpbmdzQnV0dG9uLFxuICBRbiBhcyB3aXRoU2V0dGluZ3NCdXR0b25SYXcsXG4gIFhuIGFzIHdpdGhUaGVtZVBhcmFtcyxcbiAgWm4gYXMgd2l0aFRoZW1lUGFyYW1zUmF3LFxuICBEdCBhcyB3aXRoVGltZW91dCxcbiAgc3IgYXMgd2l0aFV0aWxzLFxuICBlciBhcyB3aXRoVXRpbHNSYXcsXG4gIHJyIGFzIHdpdGhWaWV3cG9ydCxcbiAgbnIgYXMgd2l0aFZpZXdwb3J0UmF3XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tma.js/sdk-react/dist/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CAdmin%5C%5CDesktop%5C%5Cls%5C%5Cbackend%5C%5Cfrontend%5C%5Csrc%5C%5Ccomponents%5C%5Ctma%5C%5Cindex.tsx%22%2C%22ids%22%3A%5B%22TmaSDKProvider%22%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);