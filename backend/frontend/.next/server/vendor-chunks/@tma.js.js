"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tma.js";
exports.ids = ["vendor-chunks/@tma.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tma.js/sdk-react/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tma.js/sdk-react/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackButton: () => (/* binding */ Ne),\n/* harmony export */   BasicNavigator: () => (/* binding */ Is),\n/* harmony export */   BiometryManager: () => (/* binding */ ze),\n/* harmony export */   BrowserNavigator: () => (/* binding */ ee),\n/* harmony export */   ClosingBehavior: () => (/* binding */ Fe),\n/* harmony export */   CloudStorage: () => (/* binding */ ts),\n/* harmony export */   ERR_INVALID_PATH_BASE: () => (/* binding */ ye),\n/* harmony export */   ERR_INVOKE_CUSTOM_METHOD_RESPONSE: () => (/* binding */ we),\n/* harmony export */   ERR_METHOD_PARAMETER_UNSUPPORTED: () => (/* binding */ _e),\n/* harmony export */   ERR_METHOD_UNSUPPORTED: () => (/* binding */ de),\n/* harmony export */   ERR_NAVIGATION_HISTORY_EMPTY: () => (/* binding */ be),\n/* harmony export */   ERR_NAVIGATION_INDEX_INVALID: () => (/* binding */ ve),\n/* harmony export */   ERR_NAVIGATION_ITEM_INVALID: () => (/* binding */ _n),\n/* harmony export */   ERR_PARSE: () => (/* binding */ Ct),\n/* harmony export */   ERR_SSR_INIT: () => (/* binding */ gn),\n/* harmony export */   ERR_TIMED_OUT: () => (/* binding */ fe),\n/* harmony export */   ERR_UNEXPECTED_TYPE: () => (/* binding */ me),\n/* harmony export */   ERR_UNKNOWN_ENV: () => (/* binding */ ge),\n/* harmony export */   EventEmitter: () => (/* binding */ D),\n/* harmony export */   HapticFeedback: () => (/* binding */ ss),\n/* harmony export */   InitData: () => (/* binding */ rs),\n/* harmony export */   Invoice: () => (/* binding */ os),\n/* harmony export */   MainButton: () => (/* binding */ cs),\n/* harmony export */   MiniApp: () => (/* binding */ ls),\n/* harmony export */   Popup: () => (/* binding */ gs),\n/* harmony export */   QRScanner: () => (/* binding */ fs),\n/* harmony export */   SDKError: () => (/* binding */ W),\n/* harmony export */   SDKProvider: () => (/* binding */ ir),\n/* harmony export */   SettingsButton: () => (/* binding */ bs),\n/* harmony export */   ThemeParams: () => (/* binding */ ys),\n/* harmony export */   Utils: () => (/* binding */ Ps),\n/* harmony export */   Viewport: () => (/* binding */ xs),\n/* harmony export */   array: () => (/* binding */ Xe),\n/* harmony export */   bindMiniAppCSSVars: () => (/* binding */ vn),\n/* harmony export */   bindThemeParamsCSSVars: () => (/* binding */ yn),\n/* harmony export */   bindViewportCSSVars: () => (/* binding */ En),\n/* harmony export */   boolean: () => (/* binding */ E),\n/* harmony export */   captureSameReq: () => (/* binding */ qt),\n/* harmony export */   classNames: () => (/* binding */ st),\n/* harmony export */   compareVersions: () => (/* binding */ Te),\n/* harmony export */   createBrowserNavigatorFromLocation: () => (/* binding */ Os),\n/* harmony export */   createPostEvent: () => (/* binding */ ke),\n/* harmony export */   createSafeURL: () => (/* binding */ M),\n/* harmony export */   date: () => (/* binding */ Lt),\n/* harmony export */   getHash: () => (/* binding */ Cn),\n/* harmony export */   getPathname: () => (/* binding */ te),\n/* harmony export */   initBackButton: () => (/* binding */ je),\n/* harmony export */   initBiometryManager: () => (/* binding */ Je),\n/* harmony export */   initClosingBehavior: () => (/* binding */ Qe),\n/* harmony export */   initCloudStorage: () => (/* binding */ es),\n/* harmony export */   initHapticFeedback: () => (/* binding */ ns),\n/* harmony export */   initInitData: () => (/* binding */ is),\n/* harmony export */   initInvoice: () => (/* binding */ as),\n/* harmony export */   initMainButton: () => (/* binding */ hs),\n/* harmony export */   initMiniApp: () => (/* binding */ ds),\n/* harmony export */   initNavigator: () => (/* binding */ Sn),\n/* harmony export */   initPopup: () => (/* binding */ ws),\n/* harmony export */   initQRScanner: () => (/* binding */ ms),\n/* harmony export */   initSettingsButton: () => (/* binding */ vs),\n/* harmony export */   initThemeParams: () => (/* binding */ Es),\n/* harmony export */   initUtils: () => (/* binding */ Rs),\n/* harmony export */   initViewport: () => (/* binding */ Cs),\n/* harmony export */   initWeb: () => (/* binding */ Ss),\n/* harmony export */   invokeCustomMethod: () => (/* binding */ q),\n/* harmony export */   isColorDark: () => (/* binding */ Bt),\n/* harmony export */   isIframe: () => (/* binding */ at),\n/* harmony export */   isPageReload: () => (/* binding */ Ft),\n/* harmony export */   isRGB: () => (/* binding */ ct),\n/* harmony export */   isRGBShort: () => (/* binding */ Oe),\n/* harmony export */   isSDKError: () => (/* binding */ As),\n/* harmony export */   isSDKErrorOfType: () => (/* binding */ xn),\n/* harmony export */   isSSR: () => (/* binding */ Ts),\n/* harmony export */   isTMA: () => (/* binding */ Pn),\n/* harmony export */   json: () => (/* binding */ v),\n/* harmony export */   mergeClassNames: () => (/* binding */ fn),\n/* harmony export */   mockTelegramEnv: () => (/* binding */ Rn),\n/* harmony export */   number: () => (/* binding */ x),\n/* harmony export */   off: () => (/* binding */ z),\n/* harmony export */   on: () => (/* binding */ y),\n/* harmony export */   parseInitData: () => (/* binding */ mn),\n/* harmony export */   parseLaunchParams: () => (/* binding */ lt),\n/* harmony export */   parseThemeParams: () => (/* binding */ Zt),\n/* harmony export */   postEvent: () => (/* binding */ V),\n/* harmony export */   request: () => (/* binding */ g),\n/* harmony export */   requestBiometryInfo: () => (/* binding */ Ke),\n/* harmony export */   requestThemeParams: () => (/* binding */ bn),\n/* harmony export */   requestViewport: () => (/* binding */ Xt),\n/* harmony export */   retrieveLaunchParams: () => (/* binding */ nt),\n/* harmony export */   rgb: () => (/* binding */ Ve),\n/* harmony export */   searchParams: () => (/* binding */ ut),\n/* harmony export */   serializeLaunchParams: () => (/* binding */ Ue),\n/* harmony export */   serializeThemeParams: () => (/* binding */ Kt),\n/* harmony export */   setCSSVar: () => (/* binding */ P),\n/* harmony export */   setDebug: () => (/* binding */ ue),\n/* harmony export */   setTargetOrigin: () => (/* binding */ wn),\n/* harmony export */   string: () => (/* binding */ u),\n/* harmony export */   subscribe: () => (/* binding */ he),\n/* harmony export */   supports: () => (/* binding */ C),\n/* harmony export */   targetOrigin: () => (/* binding */ Ie),\n/* harmony export */   toRGB: () => (/* binding */ Vt),\n/* harmony export */   unsubscribe: () => (/* binding */ xt),\n/* harmony export */   urlToPath: () => (/* binding */ U),\n/* harmony export */   useBackButton: () => (/* binding */ Vs),\n/* harmony export */   useBackButtonRaw: () => (/* binding */ Ds),\n/* harmony export */   useBiometryManager: () => (/* binding */ Ms),\n/* harmony export */   useBiometryManagerRaw: () => (/* binding */ Bs),\n/* harmony export */   useClosingBehavior: () => (/* binding */ $s),\n/* harmony export */   useClosingBehaviorRaw: () => (/* binding */ Ls),\n/* harmony export */   useCloudStorage: () => (/* binding */ Us),\n/* harmony export */   useCloudStorageRaw: () => (/* binding */ Hs),\n/* harmony export */   useHapticFeedback: () => (/* binding */ Gs),\n/* harmony export */   useHapticFeedbackRaw: () => (/* binding */ Ws),\n/* harmony export */   useInitData: () => (/* binding */ zs),\n/* harmony export */   useInitDataRaw: () => (/* binding */ js),\n/* harmony export */   useInvoice: () => (/* binding */ Js),\n/* harmony export */   useInvoiceRaw: () => (/* binding */ Ks),\n/* harmony export */   useLaunchParams: () => (/* binding */ tr),\n/* harmony export */   useMainButton: () => (/* binding */ Qs),\n/* harmony export */   useMainButtonRaw: () => (/* binding */ Fs),\n/* harmony export */   useMiniApp: () => (/* binding */ Zs),\n/* harmony export */   useMiniAppRaw: () => (/* binding */ Ys),\n/* harmony export */   usePopup: () => (/* binding */ tn),\n/* harmony export */   usePopupRaw: () => (/* binding */ Xs),\n/* harmony export */   useQRScanner: () => (/* binding */ sn),\n/* harmony export */   useQRScannerRaw: () => (/* binding */ en),\n/* harmony export */   useSDK: () => (/* binding */ Ns),\n/* harmony export */   useSettingsButton: () => (/* binding */ rn),\n/* harmony export */   useSettingsButtonRaw: () => (/* binding */ nn),\n/* harmony export */   useThemeParams: () => (/* binding */ an),\n/* harmony export */   useThemeParamsRaw: () => (/* binding */ on),\n/* harmony export */   useUtils: () => (/* binding */ hn),\n/* harmony export */   useUtilsRaw: () => (/* binding */ cn),\n/* harmony export */   useViewport: () => (/* binding */ un),\n/* harmony export */   useViewportRaw: () => (/* binding */ pn),\n/* harmony export */   withBackButton: () => (/* binding */ An),\n/* harmony export */   withBackButtonRaw: () => (/* binding */ Tn),\n/* harmony export */   withBiometryManager: () => (/* binding */ kn),\n/* harmony export */   withBiometryManagerRaw: () => (/* binding */ In),\n/* harmony export */   withClosingBehavior: () => (/* binding */ qn),\n/* harmony export */   withClosingBehaviorRaw: () => (/* binding */ On),\n/* harmony export */   withCloudStorage: () => (/* binding */ Dn),\n/* harmony export */   withCloudStorageRaw: () => (/* binding */ Nn),\n/* harmony export */   withHapticFeedback: () => (/* binding */ Bn),\n/* harmony export */   withHapticFeedbackRaw: () => (/* binding */ Vn),\n/* harmony export */   withInitData: () => (/* binding */ Ln),\n/* harmony export */   withInitDataRaw: () => (/* binding */ Mn),\n/* harmony export */   withInvoice: () => (/* binding */ Hn),\n/* harmony export */   withInvoiceRaw: () => (/* binding */ $n),\n/* harmony export */   withMainButton: () => (/* binding */ Wn),\n/* harmony export */   withMainButtonRaw: () => (/* binding */ Un),\n/* harmony export */   withMiniApp: () => (/* binding */ jn),\n/* harmony export */   withMiniAppRaw: () => (/* binding */ Gn),\n/* harmony export */   withPopup: () => (/* binding */ Kn),\n/* harmony export */   withPopupRaw: () => (/* binding */ zn),\n/* harmony export */   withQRScanner: () => (/* binding */ Fn),\n/* harmony export */   withQRScannerRaw: () => (/* binding */ Jn),\n/* harmony export */   withSettingsButton: () => (/* binding */ Yn),\n/* harmony export */   withSettingsButtonRaw: () => (/* binding */ Qn),\n/* harmony export */   withThemeParams: () => (/* binding */ Xn),\n/* harmony export */   withThemeParamsRaw: () => (/* binding */ Zn),\n/* harmony export */   withTimeout: () => (/* binding */ Dt),\n/* harmony export */   withUtils: () => (/* binding */ sr),\n/* harmony export */   withUtilsRaw: () => (/* binding */ er),\n/* harmony export */   withViewport: () => (/* binding */ rr),\n/* harmony export */   withViewportRaw: () => (/* binding */ nr)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nvar ae = Object.defineProperty, ce = (e, t, s) => t in e ? ae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, c = (e, t, s) => ce(e, typeof t != \"symbol\" ? t + \"\" : t, s);\nfunction Rt(e, t) {\n  let s;\n  const n = () => {\n    s !== void 0 && t && t(s), s = void 0;\n  };\n  return [() => s === void 0 ? s = e(n) : s, n];\n}\nfunction xt(e) {\n  const t = j(), { count: s } = t;\n  t.unsubscribe(e), s && !t.count && Se();\n}\nfunction he(e) {\n  return j().subscribe(e), () => xt(e);\n}\nclass pe {\n  constructor(t, s = {}) {\n    this.scope = t, this.options = s;\n  }\n  /**\n   * Prints message into a console in case, logger is currently enabled.\n   * @param level - log level.\n   * @param args - arguments.\n   */\n  print(t, ...s) {\n    const n = /* @__PURE__ */ new Date(), r = Intl.DateTimeFormat(\"en-GB\", {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      fractionalSecondDigits: 3,\n      timeZone: \"UTC\"\n    }).format(n), { textColor: i, bgColor: o } = this.options, a = \"font-weight: bold;padding: 0 5px;border-radius:5px\";\n    console[t](\n      `%c${r}%c / %c${this.scope}`,\n      `${a};background-color: lightblue;color:black`,\n      \"\",\n      `${a};${i ? `color:${i};` : \"\"}${o ? `background-color:${o}` : \"\"}`,\n      ...s\n    );\n  }\n  /**\n   * Prints error message into a console.\n   * @param args\n   */\n  error(...t) {\n    this.print(\"error\", ...t);\n  }\n  /**\n   * Prints log message into a console.\n   * @param args\n   */\n  log(...t) {\n    this.print(\"log\", ...t);\n  }\n}\nconst it = new pe(\"SDK\", {\n  bgColor: \"forestgreen\",\n  textColor: \"white\"\n});\nlet X = !1;\nconst bt = ({ name: e, payload: t }) => {\n  it.log(\"Event received:\", t ? { name: e, payload: t } : { name: e });\n};\nfunction ue(e) {\n  X !== e && (X = e, e ? he(bt) : xt(bt));\n}\nfunction le(...e) {\n  X && it.log(...e);\n}\nclass D {\n  constructor() {\n    c(this, \"listeners\", /* @__PURE__ */ new Map()), c(this, \"listenersCount\", 0), c(this, \"subscribeListeners\", []);\n  }\n  /**\n   * Removes all event listeners.\n   */\n  clear() {\n    this.listeners.clear(), this.subscribeListeners = [];\n  }\n  /**\n   * Returns count of bound listeners.\n   */\n  get count() {\n    return this.listenersCount + this.subscribeListeners.length;\n  }\n  emit(t, ...s) {\n    this.subscribeListeners.forEach((n) => n({\n      event: t,\n      args: s\n    })), (this.listeners.get(t) || []).forEach(([n, r]) => {\n      n(...s), r && this.off(t, n);\n    });\n  }\n  /**\n   * Adds new event listener.\n   * @param event - event name.\n   * @param listener - event listener.\n   * @param once - should listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  on(t, s, n) {\n    let r = this.listeners.get(t);\n    return r || this.listeners.set(t, r = []), r.push([s, n]), this.listenersCount += 1, () => this.off(t, s);\n  }\n  /**\n   * Removes event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param event - event name.\n   * @param listener - event listener.\n   */\n  off(t, s) {\n    const n = this.listeners.get(t) || [];\n    for (let r = 0; r < n.length; r += 1)\n      if (s === n[r][0]) {\n        n.splice(r, 1), this.listenersCount -= 1;\n        return;\n      }\n  }\n  /**\n   * Adds a new event listener for all events.\n   * @param listener - event listener.\n   * @returns Function to remove event listener.\n   */\n  subscribe(t) {\n    return this.subscribeListeners.push(t), () => this.unsubscribe(t);\n  }\n  /**\n   * Removes global event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param listener - event listener.\n   */\n  unsubscribe(t) {\n    for (let s = 0; s < this.subscribeListeners.length; s += 1)\n      if (this.subscribeListeners[s] === t) {\n        this.subscribeListeners.splice(s, 1);\n        return;\n      }\n  }\n}\nfunction tt(e, t, s) {\n  return window.addEventListener(e, t, s), () => window.removeEventListener(e, t, s);\n}\nfunction ot(...e) {\n  let t = !1;\n  const s = e.flat(1);\n  return [\n    (n) => !t && s.push(n),\n    () => {\n      t || (t = !0, s.forEach((n) => n()));\n    },\n    t\n  ];\n}\nclass W extends Error {\n  constructor(t, s, n) {\n    super(s, { cause: n }), this.type = t, Object.setPrototypeOf(this, W.prototype);\n  }\n}\nfunction m(e, t, s) {\n  return new W(e, t, s);\n}\nconst de = \"ERR_METHOD_UNSUPPORTED\", _e = \"ERR_METHOD_PARAMETER_UNSUPPORTED\", ge = \"ERR_UNKNOWN_ENV\", we = \"ERR_INVOKE_CUSTOM_METHOD_RESPONSE\", fe = \"ERR_TIMED_OUT\", me = \"ERR_UNEXPECTED_TYPE\", Ct = \"ERR_PARSE\", be = \"ERR_NAVIGATION_LIST_EMPTY\", ve = \"ERR_NAVIGATION_CURSOR_INVALID\", _n = \"ERR_NAVIGATION_ITEM_INVALID\", gn = \"ERR_SSR_INIT\", ye = \"ERR_INVALID_PATH_BASE\";\nfunction T() {\n  return m(me, \"Value has unexpected type\");\n}\nclass G {\n  constructor(t, s, n) {\n    this.parser = t, this.isOptional = s, this.type = n;\n  }\n  /**\n   * Attempts to parse passed value\n   * @param value - value to parse.\n   * @throws {SDKError} ERR_PARSE\n   * @see ERR_PARSE\n   */\n  parse(t) {\n    if (!(this.isOptional && t === void 0))\n      try {\n        return this.parser(t);\n      } catch (s) {\n        throw m(\n          Ct,\n          `Unable to parse value${this.type ? ` as ${this.type}` : \"\"}`,\n          s\n        );\n      }\n  }\n  optional() {\n    return this.isOptional = !0, this;\n  }\n}\nfunction A(e, t) {\n  return () => new G(e, !1, t);\n}\nconst E = A((e) => {\n  if (typeof e == \"boolean\")\n    return e;\n  const t = String(e);\n  if (t === \"1\" || t === \"true\")\n    return !0;\n  if (t === \"0\" || t === \"false\")\n    return !1;\n  throw T();\n}, \"boolean\");\nfunction St(e, t) {\n  const s = {};\n  for (const n in e) {\n    const r = e[n];\n    if (!r)\n      continue;\n    let i, o;\n    if (typeof r == \"function\" || \"parse\" in r)\n      i = n, o = typeof r == \"function\" ? r : r.parse.bind(r);\n    else {\n      const { type: a } = r;\n      i = r.from || n, o = typeof a == \"function\" ? a : a.parse.bind(a);\n    }\n    try {\n      const a = o(t(i));\n      a !== void 0 && (s[n] = a);\n    } catch (a) {\n      throw m(Ct, `Unable to parse field \"${n}\"`, a);\n    }\n  }\n  return s;\n}\nfunction Tt(e) {\n  let t = e;\n  if (typeof t == \"string\" && (t = JSON.parse(t)), typeof t != \"object\" || t === null || Array.isArray(t))\n    throw T();\n  return t;\n}\nfunction v(e, t) {\n  return new G((s) => {\n    const n = Tt(s);\n    return St(e, (r) => n[r]);\n  }, !1, t);\n}\nconst x = A((e) => {\n  if (typeof e == \"number\")\n    return e;\n  if (typeof e == \"string\") {\n    const t = Number(e);\n    if (!Number.isNaN(t))\n      return t;\n  }\n  throw T();\n}, \"number\"), u = A((e) => {\n  if (typeof e == \"string\" || typeof e == \"number\")\n    return e.toString();\n  throw T();\n}, \"string\");\nfunction At(e) {\n  return v({\n    eventType: u(),\n    eventData: (t) => t\n  }).parse(e);\n}\nfunction Ee() {\n  [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((e) => {\n    delete window[e];\n  });\n}\nfunction et(e, t) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: e, eventData: t }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nfunction Pe() {\n  [\n    [\"TelegramGameProxy_receiveEvent\"],\n    // Windows Phone.\n    [\"TelegramGameProxy\", \"receiveEvent\"],\n    // Desktop.\n    [\"Telegram\", \"WebView\", \"receiveEvent\"]\n    // Android and iOS.\n  ].forEach((e) => {\n    let t = window;\n    e.forEach((s, n, r) => {\n      if (n === r.length - 1) {\n        t[s] = et;\n        return;\n      }\n      s in t || (t[s] = {}), t = t[s];\n    });\n  });\n}\nconst Re = {\n  clipboard_text_received: v({\n    req_id: u(),\n    data: (e) => e === null ? e : u().optional().parse(e)\n  }),\n  custom_method_invoked: v({\n    req_id: u(),\n    result: (e) => e,\n    error: u().optional()\n  }),\n  popup_closed: {\n    parse(e) {\n      return v({\n        button_id: (t) => t == null ? void 0 : u().parse(t)\n      }).parse(e ?? {});\n    }\n  },\n  viewport_changed: v({\n    height: x(),\n    width: (e) => e == null ? window.innerWidth : x().parse(e),\n    is_state_stable: E(),\n    is_expanded: E()\n  })\n};\nfunction xe() {\n  const e = new D(), t = new D();\n  t.subscribe((n) => {\n    e.emit(\"event\", { name: n.event, payload: n.args[0] });\n  }), Pe();\n  const [, s] = ot(\n    // Don't forget to remove created handlers.\n    Ee,\n    // Add \"resize\" event listener to make sure, we always have fresh viewport information.\n    // Desktop version of Telegram is sometimes not sending the viewport_changed\n    // event. For example, when the MainButton is shown. That's why we should\n    // add our own listener to make sure, viewport information is always fresh.\n    // Issue: https://github.com/Telegram-Mini-Apps/tma.js/issues/10\n    tt(\"resize\", () => {\n      t.emit(\"viewport_changed\", {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        is_state_stable: !0,\n        is_expanded: !0\n      });\n    }),\n    // Add listener, which handles events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    tt(\"message\", (n) => {\n      if (n.source !== window.parent)\n        return;\n      let r;\n      try {\n        r = At(n.data);\n      } catch {\n        return;\n      }\n      const { eventType: i, eventData: o } = r, a = Re[i];\n      try {\n        const h = a ? a.parse(o) : o;\n        t.emit(...h ? [i, h] : [i]);\n      } catch (h) {\n        it.error(\n          `An error occurred processing the \"${i}\" event from the Telegram application.\nPlease, file an issue here:\nhttps://github.com/Telegram-Mini-Apps/tma.js/issues/new/choose`,\n          r,\n          h\n        );\n      }\n    }),\n    // Clear emitters.\n    () => e.clear(),\n    () => t.clear()\n  );\n  return [{\n    on: t.on.bind(t),\n    off: t.off.bind(t),\n    subscribe(n) {\n      return e.on(\"event\", n);\n    },\n    unsubscribe(n) {\n      e.off(\"event\", n);\n    },\n    get count() {\n      return t.count + e.count;\n    }\n  }, s];\n}\nconst [Ce, Se] = Rt(\n  (e) => {\n    const [t, s] = xe(), n = t.off.bind(t);\n    return t.off = (r, i) => {\n      const { count: o } = t;\n      n(r, i), o && !t.count && e();\n    }, [t, s];\n  },\n  ([, e]) => e()\n);\nfunction j() {\n  return Ce()[0];\n}\nfunction z(e, t) {\n  j().off(e, t);\n}\nfunction y(e, t, s) {\n  return j().on(e, t, s);\n}\nfunction L(e) {\n  return typeof e == \"object\" && e !== null && !Array.isArray(e);\n}\nfunction Te(e, t) {\n  const s = e.split(\".\"), n = t.split(\".\"), r = Math.max(s.length, n.length);\n  for (let i = 0; i < r; i += 1) {\n    const o = parseInt(s[i] || \"0\", 10), a = parseInt(n[i] || \"0\", 10);\n    if (o !== a)\n      return o > a ? 1 : -1;\n  }\n  return 0;\n}\nfunction f(e, t) {\n  return Te(e, t) <= 0;\n}\nfunction C(e, t, s) {\n  if (typeof s == \"string\") {\n    if (e === \"web_app_open_link\") {\n      if (t === \"try_instant_view\")\n        return f(\"6.4\", s);\n      if (t === \"try_browser\")\n        return f(\"7.6\", s);\n    }\n    if (e === \"web_app_set_header_color\" && t === \"color\")\n      return f(\"6.9\", s);\n    if (e === \"web_app_close\" && t === \"return_back\")\n      return f(\"7.6\", s);\n  }\n  switch (e) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return f(\"6.1\", t);\n    case \"web_app_open_popup\":\n      return f(\"6.2\", t);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return f(\"6.4\", t);\n    case \"web_app_switch_inline_query\":\n      return f(\"6.7\", t);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return f(\"6.9\", t);\n    case \"web_app_setup_settings_button\":\n      return f(\"6.10\", t);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return f(\"7.2\", t);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(e);\n  }\n}\nfunction It(e) {\n  return \"external\" in e && L(e.external) && \"notify\" in e.external && typeof e.external.notify == \"function\";\n}\nfunction kt(e) {\n  return \"TelegramWebviewProxy\" in e && L(e.TelegramWebviewProxy) && \"postEvent\" in e.TelegramWebviewProxy && typeof e.TelegramWebviewProxy.postEvent == \"function\";\n}\nfunction at() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nconst Ae = \"https://web.telegram.org\";\nlet Ot = Ae;\nfunction wn(e) {\n  Ot = e;\n}\nfunction Ie() {\n  return Ot;\n}\nfunction V(e, t, s) {\n  let n = {}, r;\n  if (!t && !s ? n = {} : t && s ? (n = s, r = t) : t && (\"targetOrigin\" in t ? n = t : r = t), le(\"Posting event:\", r ? { event: e, data: r } : { event: e }), at())\n    return window.parent.postMessage(\n      JSON.stringify({ eventType: e, eventData: r }),\n      n.targetOrigin || Ie()\n    );\n  if (It(window)) {\n    window.external.notify(JSON.stringify({ eventType: e, eventData: r }));\n    return;\n  }\n  if (kt(window)) {\n    window.TelegramWebviewProxy.postEvent(e, JSON.stringify(r));\n    return;\n  }\n  throw m(\n    ge,\n    \"Unable to determine current environment and possible way to send event. You are probably trying to use Mini Apps method outside the Telegram application environment.\"\n  );\n}\nfunction ke(e) {\n  return (t, s) => {\n    if (!C(t, e))\n      throw m(de, `Method \"${t}\" is unsupported in Mini Apps version ${e}`);\n    if (L(s) && t === \"web_app_set_header_color\" && \"color\" in s && !C(t, \"color\", e))\n      throw m(\n        _e,\n        `Parameter \"color\" of \"${t}\" method is unsupported in Mini Apps version ${e}`\n      );\n    return V(t, s);\n  };\n}\nfunction qt(e) {\n  return ({ req_id: t }) => t === e;\n}\nfunction Nt(e) {\n  return m(fe, `Timeout reached: ${e}ms`);\n}\nfunction Dt(e, t) {\n  return Promise.race([\n    typeof e == \"function\" ? e() : e,\n    new Promise((s, n) => {\n      setTimeout(() => {\n        n(Nt(t));\n      }, t);\n    })\n  ]);\n}\nasync function g(e) {\n  let t;\n  const s = new Promise((a) => t = a), { event: n, capture: r, timeout: i } = e, [, o] = ot(\n    // We need to iterate over all tracked events, and create their event listeners.\n    (Array.isArray(n) ? n : [n]).map((a) => y(a, (h) => {\n      (!r || (Array.isArray(n) ? r({\n        event: a,\n        payload: h\n      }) : r(h))) && t(h);\n    }))\n  );\n  try {\n    return (e.postEvent || V)(e.method, e.params), await (i ? Dt(s, i) : s);\n  } finally {\n    o();\n  }\n}\nasync function q(e, t, s, n = {}) {\n  const {\n    result: r,\n    error: i\n  } = await g({\n    ...n,\n    method: \"web_app_invoke_custom_method\",\n    event: \"custom_method_invoked\",\n    params: {\n      method: e,\n      params: t,\n      req_id: s\n    },\n    capture: qt(s)\n  });\n  if (i)\n    throw m(we, i);\n  return r;\n}\nfunction st(...e) {\n  return e.map((t) => {\n    if (typeof t == \"string\")\n      return t;\n    if (L(t))\n      return st(Object.entries(t).map((s) => s[1] && s[0]));\n    if (Array.isArray(t))\n      return st(...t);\n  }).filter(Boolean).join(\" \");\n}\nfunction fn(...e) {\n  return e.reduce((t, s) => (L(s) && Object.entries(s).forEach(([n, r]) => {\n    const i = st(t[n], r);\n    i.length && (t[n] = i);\n  }), t), {});\n}\nfunction ct(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction Oe(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction Vt(e) {\n  const t = e.replace(/\\s/g, \"\").toLowerCase();\n  if (ct(t))\n    return t;\n  if (Oe(t)) {\n    let n = \"#\";\n    for (let r = 0; r < 3; r += 1)\n      n += t[1 + r].repeat(2);\n    return n;\n  }\n  const s = t.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || t.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!s)\n    throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return s.slice(1).reduce((n, r) => {\n    const i = parseInt(r, 10).toString(16);\n    return n + (i.length === 1 ? \"0\" : \"\") + i;\n  }, \"#\");\n}\nfunction Bt(e) {\n  const t = Vt(e);\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce((s, n, r) => {\n      const i = parseInt(t.slice(1 + r * 2, 1 + (r + 1) * 2), 16);\n      return s + i * i * n;\n    }, 0)\n  ) < 120;\n}\nclass qe {\n  constructor(t) {\n    c(this, \"ee\", new D()), c(this, \"on\", this.ee.on.bind(this.ee)), c(this, \"off\", this.ee.off.bind(this.ee)), this.state = t;\n  }\n  /**\n   * Clones current state and returns its copy.\n   */\n  clone() {\n    return { ...this.state };\n  }\n  set(t, s) {\n    Object.entries(typeof t == \"string\" ? { [t]: s } : t).reduce((n, [r, i]) => this.state[r] === i || i === void 0 ? n : (this.state[r] = i, this.ee.emit(`change:${r}`, i), !0), !1) && this.ee.emit(\"change\", this.state);\n  }\n  /**\n   * Returns value by specified key.\n   * @param key - state key.\n   */\n  get(t) {\n    return this.state[t];\n  }\n}\nclass ht {\n  constructor(t) {\n    c(this, \"state\"), c(this, \"get\"), c(this, \"set\"), c(this, \"clone\"), this.state = new qe(t), this.set = this.state.set.bind(this.state), this.get = this.state.get.bind(this.state), this.clone = this.state.clone.bind(this.state);\n  }\n}\nfunction Mt(e, t) {\n  return (s) => C(t[s], e);\n}\nclass pt extends ht {\n  constructor(t, s, n) {\n    super(t), c(this, \"supports\"), this.supports = Mt(s, n);\n  }\n}\nclass Ne extends pt {\n  constructor(t, s, n) {\n    super({ isVisible: t }, s, {\n      show: \"web_app_setup_back_button\",\n      hide: \"web_app_setup_back_button\"\n    }), c(this, \"on\", (r, i) => r === \"click\" ? y(\"back_button_pressed\", i) : this.state.on(r, i)), c(this, \"off\", (r, i) => r === \"click\" ? z(\"back_button_pressed\", i) : this.state.off(r, i)), this.postEvent = n;\n  }\n  set isVisible(t) {\n    this.set(\"isVisible\", t), this.postEvent(\"web_app_setup_back_button\", { is_visible: t });\n  }\n  /**\n   * True if BackButton is currently visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Hides the BackButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the BackButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nconst Lt = A((e) => e instanceof Date ? e : new Date(x().parse(e) * 1e3), \"Date\");\nfunction ut(e, t) {\n  return new G((s) => {\n    if (typeof s != \"string\" && !(s instanceof URLSearchParams))\n      throw T();\n    const n = typeof s == \"string\" ? new URLSearchParams(s) : s;\n    return St(e, (r) => {\n      const i = n.get(r);\n      return i === null ? void 0 : i;\n    });\n  }, !1, t);\n}\nconst De = v({\n  id: x(),\n  type: u(),\n  title: u(),\n  photoUrl: {\n    type: u().optional(),\n    from: \"photo_url\"\n  },\n  username: u().optional()\n}, \"Chat\").optional(), vt = v({\n  addedToAttachmentMenu: {\n    type: E().optional(),\n    from: \"added_to_attachment_menu\"\n  },\n  allowsWriteToPm: {\n    type: E().optional(),\n    from: \"allows_write_to_pm\"\n  },\n  firstName: {\n    type: u(),\n    from: \"first_name\"\n  },\n  id: x(),\n  isBot: {\n    type: E().optional(),\n    from: \"is_bot\"\n  },\n  isPremium: {\n    type: E().optional(),\n    from: \"is_premium\"\n  },\n  languageCode: {\n    type: u().optional(),\n    from: \"language_code\"\n  },\n  lastName: {\n    type: u().optional(),\n    from: \"last_name\"\n  },\n  photoUrl: {\n    type: u().optional(),\n    from: \"photo_url\"\n  },\n  username: u().optional()\n}, \"User\").optional();\nfunction $t() {\n  return ut({\n    authDate: {\n      type: Lt(),\n      from: \"auth_date\"\n    },\n    canSendAfter: {\n      type: x().optional(),\n      from: \"can_send_after\"\n    },\n    chat: De,\n    chatInstance: {\n      type: u().optional(),\n      from: \"chat_instance\"\n    },\n    chatType: {\n      type: u().optional(),\n      from: \"chat_type\"\n    },\n    hash: u(),\n    queryId: {\n      type: u().optional(),\n      from: \"query_id\"\n    },\n    receiver: vt,\n    startParam: {\n      type: u().optional(),\n      from: \"start_param\"\n    },\n    user: vt\n  }, \"InitData\");\n}\nconst Ve = A((e) => Vt(u().parse(e)), \"rgb\");\nfunction Be(e) {\n  return e.replace(/_[a-z]/g, (t) => t[1].toUpperCase());\n}\nfunction Me(e) {\n  return e.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`);\n}\nconst Ht = A(\n  (e) => {\n    const t = Ve().optional();\n    return Object.entries(Tt(e)).reduce((s, [n, r]) => (s[Be(n)] = t.parse(r), s), {});\n  },\n  \"ThemeParams\"\n);\nfunction lt(e) {\n  return ut({\n    botInline: {\n      type: E().optional(),\n      from: \"tgWebAppBotInline\"\n    },\n    initData: {\n      type: $t().optional(),\n      from: \"tgWebAppData\"\n    },\n    initDataRaw: {\n      type: u().optional(),\n      from: \"tgWebAppData\"\n    },\n    platform: {\n      type: u(),\n      from: \"tgWebAppPlatform\"\n    },\n    showSettings: {\n      type: E().optional(),\n      from: \"tgWebAppShowSettings\"\n    },\n    startParam: {\n      type: u().optional(),\n      from: \"tgWebAppStartParam\"\n    },\n    themeParams: {\n      type: Ht(),\n      from: \"tgWebAppThemeParams\"\n    },\n    version: {\n      type: u(),\n      from: \"tgWebAppVersion\"\n    }\n  }).parse(e);\n}\nfunction Ut(e) {\n  return lt(\n    e.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\")\n  );\n}\nfunction Le() {\n  return Ut(window.location.href);\n}\nfunction Wt() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction $e() {\n  const e = Wt();\n  if (!e)\n    throw new Error(\"Unable to get first navigation entry.\");\n  return Ut(e.name);\n}\nfunction Gt(e) {\n  return `tma.js/${e.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`)}`;\n}\nfunction jt(e, t) {\n  sessionStorage.setItem(Gt(e), JSON.stringify(t));\n}\nfunction zt(e) {\n  const t = sessionStorage.getItem(Gt(e));\n  try {\n    return t ? JSON.parse(t) : void 0;\n  } catch {\n  }\n}\nfunction He() {\n  return lt(zt(\"launchParams\") || \"\");\n}\nfunction Kt(e) {\n  return JSON.stringify(\n    Object.fromEntries(\n      Object.entries(e).map(([t, s]) => [Me(t), s])\n    )\n  );\n}\nfunction Ue(e) {\n  const {\n    initDataRaw: t,\n    themeParams: s,\n    platform: n,\n    version: r,\n    showSettings: i,\n    startParam: o,\n    botInline: a\n  } = e, h = new URLSearchParams();\n  return h.set(\"tgWebAppPlatform\", n), h.set(\"tgWebAppThemeParams\", Kt(s)), h.set(\"tgWebAppVersion\", r), t && h.set(\"tgWebAppData\", t), o && h.set(\"tgWebAppStartParam\", o), typeof i == \"boolean\" && h.set(\"tgWebAppShowSettings\", i ? \"1\" : \"0\"), typeof a == \"boolean\" && h.set(\"tgWebAppBotInline\", a ? \"1\" : \"0\"), h.toString();\n}\nfunction Jt(e) {\n  jt(\"launchParams\", Ue(e));\n}\nfunction nt() {\n  for (const e of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed and then page was reloaded.\n    Le,\n    // Then, try using the lower level API - window.performance.\n    $e,\n    // Finally, try to extract launch parameters from the session storage.\n    He\n  ])\n    try {\n      const t = e();\n      return Jt(t), t;\n    } catch {\n    }\n  throw new Error(\"Unable to retrieve launch parameters from any known source.\");\n}\nfunction Ft() {\n  const e = Wt();\n  return !!(e && e.type === \"reload\");\n}\nfunction We() {\n  let e = 0;\n  return () => (e += 1).toString();\n}\nconst [Ge] = Rt(We);\nfunction l(e, t) {\n  return () => {\n    const s = nt(), n = {\n      ...s,\n      postEvent: ke(s.version),\n      createRequestId: Ge()\n    };\n    if (typeof e == \"function\")\n      return e(n);\n    const [r, i, o] = ot(), a = t({\n      ...n,\n      // State should only be passed only in case, current page was reloaded. If we don't add\n      // this check, state restoration will work improperly in the web version of Telegram,\n      // when we are always working in the same \"session\" (tab).\n      state: Ft() ? zt(e) : void 0,\n      addCleanup: r\n    }), h = (p) => (o || r(\n      p.on(\"change\", (S) => {\n        jt(e, S);\n      })\n    ), p);\n    return [\n      a instanceof Promise ? a.then(h) : h(a),\n      i\n    ];\n  };\n}\nconst je = l(\"backButton\", ({\n  postEvent: e,\n  version: t,\n  state: s = { isVisible: !1 }\n}) => new Ne(s.isVisible, t, e));\nclass $ extends pt {\n  constructor() {\n    super(...arguments), c(this, \"on\", this.state.on.bind(this.state)), c(this, \"off\", this.state.off.bind(this.state));\n  }\n}\nfunction Qt(e) {\n  const t = e.available ? e : {\n    available: !1,\n    device_id: \"\",\n    token_saved: !1,\n    access_requested: !1,\n    access_granted: !1,\n    type: \"\"\n  };\n  return {\n    available: !0,\n    type: t.type,\n    deviceId: t.device_id,\n    tokenSaved: t.token_saved,\n    accessRequested: t.access_requested,\n    accessGranted: t.access_granted\n  };\n}\nclass ze extends $ {\n  constructor({ postEvent: t, version: s, ...n }) {\n    super(n, s, {\n      auth: \"web_app_biometry_request_auth\",\n      openSettings: \"web_app_biometry_open_settings\",\n      requestAccess: \"web_app_biometry_request_access\",\n      updateToken: \"web_app_biometry_update_token\"\n    }), c(this, \"postEvent\"), c(this, \"authPromise\"), c(this, \"accessPromise\"), this.postEvent = t;\n  }\n  /**\n   * Shows whether biometry is available.\n   */\n  get available() {\n    return this.get(\"available\");\n  }\n  /**\n   * Shows whether permission to use biometrics has been granted.\n   */\n  get accessGranted() {\n    return this.get(\"accessGranted\");\n  }\n  /**\n   * Shows whether if permission to use biometrics has been requested.\n   */\n  get accessRequested() {\n    return this.get(\"accessRequested\");\n  }\n  /**\n   * Authenticates the user using biometrics.\n   * @param options - method options.\n   * @since 7.2\n   * @returns Token from the local secure storage, if authentication was successful.\n   */\n  async authenticate({\n    reason: t,\n    ...s\n  }) {\n    return this.authPromise || (this.authPromise = g({\n      ...s,\n      method: \"web_app_biometry_request_auth\",\n      event: \"biometry_auth_requested\",\n      postEvent: this.postEvent,\n      params: {\n        // TODO: Check if reason is empty works fine.\n        reason: (t || \"\").trim()\n      }\n    }).then(({ token: n }) => n).finally(() => this.authPromise = void 0)), this.authPromise;\n  }\n  /**\n   * A unique device identifier that can be used to match the token to the device.\n   */\n  get deviceId() {\n    return this.get(\"deviceId\");\n  }\n  /**\n   * Opens the biometric access settings for bots. Useful when you need to request biometrics\n   * access to users who haven't granted it yet.\n   *\n   * _Note that this method can be called only in response to user interaction with the Mini App\n   * interface (e.g. a click inside the Mini App or on the main button)_.\n   * @since 7.2\n   */\n  openSettings() {\n    this.postEvent(\"web_app_biometry_open_settings\");\n  }\n  /**\n   * Requests permission to use biometrics.\n   * @since 7.2\n   * @returns Promise with true, if access was granted.\n   */\n  requestAccess({ reason: t, ...s } = {}) {\n    return this.accessPromise || (this.accessPromise = g({\n      ...s,\n      postEvent: this.postEvent,\n      method: \"web_app_biometry_request_access\",\n      event: \"biometry_info_received\",\n      params: { reason: t || \"\" }\n    }).then((n) => {\n      const r = Qt(n);\n      return this.set(r), r.accessGranted;\n    }).finally(() => this.accessPromise = void 0)), this.accessPromise;\n  }\n  /**\n   * The type of biometrics currently available on the device.\n   */\n  get biometryType() {\n    return this.get(\"biometryType\");\n  }\n  /**\n   * Shows whether token was saved previously in the local secure storage.\n   */\n  get tokenSaved() {\n    return this.get(\"tokenSaved\");\n  }\n  /**\n   * Updates the biometric token in a secure storage on the device.\n   * @returns Promise with `true`, if token was updated.\n   */\n  async updateToken({ token: t, ...s } = {}) {\n    return [\"removed\", \"updated\"].includes(\n      (await g({\n        ...s,\n        postEvent: this.postEvent,\n        method: \"web_app_biometry_update_token\",\n        event: \"biometry_token_updated\",\n        params: { token: t || \"\" }\n      })).status\n    );\n  }\n}\nasync function Ke(e) {\n  return Qt(\n    await g({\n      ...e || {},\n      method: \"web_app_biometry_get_info\",\n      event: \"biometry_info_received\"\n    })\n  );\n}\nconst Je = l(\n  \"biometryManager\",\n  async ({ postEvent: e, version: t, state: s }) => new ze({\n    ...s || C(\"web_app_biometry_get_info\", t) ? s || await Ke({ timeout: 1e3 }) : {\n      available: !1,\n      accessGranted: !1,\n      accessRequested: !1,\n      tokenSaved: !1,\n      deviceId: \"\"\n    },\n    version: t,\n    postEvent: e\n  })\n);\nclass dt extends ht {\n  constructor() {\n    super(...arguments), c(this, \"on\", this.state.on.bind(this.state)), c(this, \"off\", this.state.off.bind(this.state));\n  }\n}\nclass Fe extends dt {\n  constructor(t, s) {\n    super({ isConfirmationNeeded: t }), this.postEvent = s;\n  }\n  set isConfirmationNeeded(t) {\n    this.set(\"isConfirmationNeeded\", t), this.postEvent(\"web_app_setup_closing_behavior\", { need_confirmation: t });\n  }\n  /**\n   * True, if the confirmation dialog should be shown while the user is trying to close\n   * the Mini App.\n   */\n  get isConfirmationNeeded() {\n    return this.get(\"isConfirmationNeeded\");\n  }\n  /**\n   * Disables the confirmation dialog when closing the Mini App.\n   */\n  disableConfirmation() {\n    this.isConfirmationNeeded = !1;\n  }\n  /**\n   * Enables the confirmation dialog when closing the Mini App.\n   */\n  enableConfirmation() {\n    this.isConfirmationNeeded = !0;\n  }\n}\nconst Qe = l(\n  \"closingBehavior\",\n  ({\n    postEvent: e,\n    state: t = { isConfirmationNeeded: !1 }\n  }) => new Fe(t.isConfirmationNeeded, e)\n);\nclass _t {\n  constructor(t, s) {\n    c(this, \"supports\"), this.supports = Mt(t, s);\n  }\n}\nfunction Ye(e) {\n  if (Array.isArray(e))\n    return e;\n  if (typeof e == \"string\")\n    try {\n      const t = JSON.parse(e);\n      if (Array.isArray(t))\n        return t;\n    } catch {\n    }\n  throw T();\n}\nclass Ze extends G {\n  constructor(t, s, n) {\n    super(Ye, s, n), c(this, \"itemParser\"), this.itemParser = typeof t == \"function\" ? t : t.parse.bind(t);\n  }\n  /**\n   * Attempts to parse passed value\n   * @param value - value to parse.\n   * @throws {SDKError} ERR_PARSE\n   * @see ERR_PARSE\n   */\n  parse(t) {\n    const s = super.parse(t);\n    return s === void 0 ? s : s.map(this.itemParser);\n  }\n  of(t) {\n    return this.itemParser = typeof t == \"function\" ? t : t.parse.bind(t), this;\n  }\n}\nfunction Xe(e) {\n  return new Ze((t) => t, !1, e);\n}\nfunction yt(e, t) {\n  return Object.fromEntries(e.map((s) => [s, t]));\n}\nclass ts extends _t {\n  constructor(t, s, n) {\n    super(t, {\n      delete: \"web_app_invoke_custom_method\",\n      get: \"web_app_invoke_custom_method\",\n      getKeys: \"web_app_invoke_custom_method\",\n      set: \"web_app_invoke_custom_method\"\n    }), this.createRequestId = s, this.postEvent = n;\n  }\n  /**\n   * Deletes specified key or keys from the cloud storage.\n   * @param keyOrKeys - key or keys to delete.\n   * @param options - request execution options.\n   */\n  async delete(t, s = {}) {\n    const n = Array.isArray(t) ? t : [t];\n    n.length && await q(\n      \"deleteStorageValues\",\n      { keys: n },\n      this.createRequestId(),\n      { ...s, postEvent: this.postEvent }\n    );\n  }\n  /**\n   * Returns list of all keys presented in the cloud storage.\n   * @param options - request execution options.\n   */\n  async getKeys(t = {}) {\n    return Xe().of(u()).parse(\n      await q(\n        \"getStorageKeys\",\n        {},\n        this.createRequestId(),\n        { ...t, postEvent: this.postEvent }\n      )\n    );\n  }\n  async get(t, s = {}) {\n    const n = Array.isArray(t) ? t : [t];\n    if (!n.length)\n      return yt(n, \"\");\n    const r = await q(\n      \"getStorageValues\",\n      { keys: n },\n      this.createRequestId(),\n      { ...s, postEvent: this.postEvent }\n    ), i = v(yt(n, u()), \"CloudStorageData\").parse(r);\n    return Array.isArray(t) ? i : i[t];\n  }\n  /**\n   * Saves specified value by key.\n   * @param key - storage key.\n   * @param value - storage value.\n   * @param options - request execution options.\n   */\n  async set(t, s, n = {}) {\n    await q(\n      \"saveStorageValue\",\n      { key: t, value: s },\n      this.createRequestId(),\n      { ...n, postEvent: this.postEvent }\n    );\n  }\n}\nconst es = l(\n  ({ createRequestId: e, postEvent: t, version: s }) => new ts(s, e, t)\n);\nclass ss extends _t {\n  constructor(t, s) {\n    super(t, {\n      impactOccurred: \"web_app_trigger_haptic_feedback\",\n      notificationOccurred: \"web_app_trigger_haptic_feedback\",\n      selectionChanged: \"web_app_trigger_haptic_feedback\"\n    }), this.postEvent = s;\n  }\n  /**\n   * A method tells that an impact occurred. The Telegram app may play the\n   * appropriate haptics based on style value passed.\n   * @param style - impact style.\n   */\n  impactOccurred(t) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"impact\",\n      impact_style: t\n    });\n  }\n  /**\n   * A method tells that a task or action has succeeded, failed, or produced\n   * a warning. The Telegram app may play the appropriate haptics based on\n   * type value passed.\n   * @param type - notification type.\n   */\n  notificationOccurred(t) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"notification\",\n      notification_type: t\n    });\n  }\n  /**\n   * A method tells that the user has changed a selection. The Telegram app\n   * may play the appropriate haptics.\n   *\n   * Do not use this feedback when the user makes or confirms a selection;\n   * use it only when the selection changes.\n   */\n  selectionChanged() {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", { type: \"selection_change\" });\n  }\n}\nconst ns = l(\n  ({ version: e, postEvent: t }) => new ss(e, t)\n);\nclass rs {\n  constructor(t) {\n    this.initData = t;\n  }\n  /**\n   * @see InitDataParsed.authDate\n   */\n  get authDate() {\n    return this.initData.authDate;\n  }\n  /**\n   * @see InitDataParsed.canSendAfter\n   */\n  get canSendAfter() {\n    return this.initData.canSendAfter;\n  }\n  /**\n   * Date after which it is allowed to call\n   * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n   */\n  get canSendAfterDate() {\n    const { canSendAfter: t } = this;\n    return t ? new Date(this.authDate.getTime() + t * 1e3) : void 0;\n  }\n  /**\n   * @see InitDataParsed.chat\n   */\n  get chat() {\n    return this.initData.chat;\n  }\n  /**\n   * @see InitDataParsed.chatType\n   */\n  get chatType() {\n    return this.initData.chatType;\n  }\n  /**\n   * @see InitDataParsed.chatInstance\n   */\n  get chatInstance() {\n    return this.initData.chatInstance;\n  }\n  /**\n   * @see InitDataParsed.hash\n   */\n  get hash() {\n    return this.initData.hash;\n  }\n  /**\n   * @see InitDataParsed.queryId\n   */\n  get queryId() {\n    return this.initData.queryId;\n  }\n  /**\n   * @see InitDataParsed.receiver\n   */\n  get receiver() {\n    return this.initData.receiver;\n  }\n  /**\n   * @see InitDataParsed.startParam\n   */\n  get startParam() {\n    return this.initData.startParam;\n  }\n  /**\n   * @see InitDataParsed.user\n   */\n  get user() {\n    return this.initData.user;\n  }\n}\nconst is = l(\n  ({ initData: e }) => e ? new rs(e) : void 0\n);\nfunction mn(e) {\n  return $t().parse(e);\n}\nclass os extends $ {\n  constructor(t, s, n) {\n    super({ isOpened: t }, s, { open: \"web_app_open_invoice\" }), this.postEvent = n;\n  }\n  set isOpened(t) {\n    this.set(\"isOpened\", t);\n  }\n  /**\n   * True if invoice is currently opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  async open(t, s) {\n    if (this.isOpened)\n      throw new Error(\"Invoice is already opened\");\n    let n;\n    if (!s)\n      n = t;\n    else {\n      const { hostname: r, pathname: i } = new URL(t, window.location.href);\n      if (r !== \"t.me\")\n        throw new Error(`Incorrect hostname: ${r}`);\n      const o = i.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n      if (!o)\n        throw new Error('Link pathname has incorrect format. Expected to receive \"/invoice/{slug}\" or \"/${slug}\"');\n      [, , n] = o;\n    }\n    this.isOpened = !0;\n    try {\n      return (await g({\n        method: \"web_app_open_invoice\",\n        event: \"invoice_closed\",\n        params: { slug: n },\n        postEvent: this.postEvent,\n        capture(r) {\n          return n === r.slug;\n        }\n      })).status;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nconst as = l(\n  ({ version: e, postEvent: t }) => new os(!1, e, t)\n);\nclass cs extends ht {\n  constructor({ postEvent: t, ...s }) {\n    super(s), c(this, \"postEvent\"), c(this, \"on\", (n, r) => n === \"click\" ? y(\"main_button_pressed\", r) : this.state.on(n, r)), c(this, \"off\", (n, r) => n === \"click\" ? z(\"main_button_pressed\", r) : this.state.off(n, r)), this.postEvent = t;\n  }\n  /**\n   * The MainButton background color.\n   */\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  /**\n   * Sends current local state to the Telegram application.\n   */\n  commit() {\n    this.text !== \"\" && this.postEvent(\"web_app_setup_main_button\", {\n      is_visible: this.isVisible,\n      is_active: this.isEnabled,\n      is_progress_visible: this.isLoaderVisible,\n      text: this.text,\n      color: this.bgColor,\n      text_color: this.textColor\n    });\n  }\n  /**\n   * Disables the MainButton.\n   * @see Does not work on Android: https://github.com/Telegram-Mini-Apps/issues/issues/1\n   */\n  disable() {\n    return this.isEnabled = !1, this;\n  }\n  /**\n   * Enables the MainButton.\n   */\n  enable() {\n    return this.isEnabled = !0, this;\n  }\n  /**\n   * Hides the MainButton.\n   */\n  hide() {\n    return this.isVisible = !1, this;\n  }\n  /**\n   * Hides the MainButton loading indicator.\n   */\n  hideLoader() {\n    return this.isLoaderVisible = !1, this;\n  }\n  set isEnabled(t) {\n    this.setParams({ isEnabled: t });\n  }\n  /**\n   * True if the MainButton is enabled.\n   */\n  get isEnabled() {\n    return this.get(\"isEnabled\");\n  }\n  set isLoaderVisible(t) {\n    this.setParams({ isLoaderVisible: t });\n  }\n  /**\n   * True if the MainButton loader is visible.\n   */\n  get isLoaderVisible() {\n    return this.get(\"isLoaderVisible\");\n  }\n  set isVisible(t) {\n    this.setParams({ isVisible: t });\n  }\n  /**\n   * True if the MainButton is visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Shows the MainButton.\n   *\n   * Note that opening the Mini App from the attachment menu hides the main button until the\n   * user interacts with the Mini App interface.\n   */\n  show() {\n    return this.isVisible = !0, this;\n  }\n  /**\n   * Shows a loading indicator on the Main Button.\n   */\n  showLoader() {\n    return this.isLoaderVisible = !0, this;\n  }\n  /**\n   * Sets a new MainButton text. Minimal length for the text is 1 symbol, and maximum is 64 symbols.\n   * @param text - a new text.\n   */\n  setText(t) {\n    return this.setParams({ text: t });\n  }\n  /**\n   * Sets a new Main Button text color.\n   * @param textColor - new text color.\n   */\n  setTextColor(t) {\n    return this.setParams({ textColor: t });\n  }\n  /**\n   * Updates current Main Button color.\n   * @param bgColor - color to set.\n   */\n  setBgColor(t) {\n    return this.setParams({ bgColor: t });\n  }\n  /**\n   * Allows setting multiple Main Button parameters.\n   * @param params - Main Button parameters.\n   */\n  setParams(t) {\n    return this.set(t), this.commit(), this;\n  }\n  /**\n   * The MainButton text.\n   */\n  get text() {\n    return this.get(\"text\");\n  }\n  /**\n   * The MainButton text color.\n   */\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nconst hs = l(\n  \"mainButton\",\n  ({\n    postEvent: e,\n    themeParams: t,\n    state: s = {\n      isVisible: !1,\n      isEnabled: !1,\n      text: \"\",\n      isLoaderVisible: !1,\n      textColor: t.buttonTextColor || \"#ffffff\",\n      bgColor: t.buttonColor || \"#000000\"\n    }\n  }) => new cs({ ...s, postEvent: e })\n);\nfunction ps() {\n  return ut({\n    contact: v({\n      userId: {\n        type: x(),\n        from: \"user_id\"\n      },\n      phoneNumber: {\n        type: u(),\n        from: \"phone_number\"\n      },\n      firstName: {\n        type: u(),\n        from: \"first_name\"\n      },\n      lastName: {\n        type: u().optional(),\n        from: \"last_name\"\n      }\n    }),\n    authDate: {\n      type: Lt(),\n      from: \"auth_date\"\n    },\n    hash: u()\n  }, \"RequestedContact\");\n}\nfunction Yt(e, t) {\n  return (s) => {\n    const [n, r] = t[s];\n    return C(n, r, e);\n  };\n}\nfunction us(e) {\n  return new Promise((t) => {\n    setTimeout(t, e);\n  });\n}\nclass ls extends $ {\n  constructor({ postEvent: t, createRequestId: s, version: n, botInline: r, ...i }) {\n    super(i, n, {\n      requestPhoneAccess: \"web_app_request_phone\",\n      requestWriteAccess: \"web_app_request_write_access\",\n      switchInlineQuery: \"web_app_switch_inline_query\",\n      setHeaderColor: \"web_app_set_header_color\",\n      setBackgroundColor: \"web_app_set_background_color\"\n    }), c(this, \"botInline\"), c(this, \"postEvent\"), c(this, \"createRequestId\"), c(this, \"requestPhoneAccessPromise\"), c(this, \"requestWriteAccessPromise\"), c(this, \"supportsParam\"), this.createRequestId = s, this.postEvent = t, this.botInline = r;\n    const o = this.supports.bind(this);\n    this.supports = (a) => o(a) ? a !== \"switchInlineQuery\" || r : !1, this.supportsParam = Yt(n, {\n      \"setHeaderColor.color\": [\"web_app_set_header_color\", \"color\"]\n    });\n  }\n  /**\n   * Attempts to get requested contact.\n   * @param timeout - request timeout.\n   */\n  async getRequestedContact({\n    timeout: t = 1e4\n  } = {}) {\n    return ps().parse(\n      await q(\n        \"getRequestedContact\",\n        {},\n        this.createRequestId(),\n        { postEvent: this.postEvent, timeout: t }\n      )\n    );\n  }\n  /**\n   * The Mini App background color.\n   * @example \"#ffaabb\"\n   */\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  /**\n   * Closes the Mini App.\n   * @param returnBack - should the application be wrapped into the bottom bar.\n   */\n  close(t) {\n    this.postEvent(\"web_app_close\", { return_back: t });\n  }\n  /**\n   * The Mini App header color.\n   * @example \"#ffaabb\"\n   * @example \"bg_color\"\n   */\n  get headerColor() {\n    return this.get(\"headerColor\");\n  }\n  /**\n   * True if the Mini App is currently launched in bot inline mode.\n   */\n  get isBotInline() {\n    return this.botInline;\n  }\n  /**\n   * True if the current Mini App background color is recognized as dark.\n   */\n  get isDark() {\n    return Bt(this.bgColor);\n  }\n  /**\n   * Informs the Telegram app that the Mini App is ready to be displayed.\n   *\n   * It is recommended to call this method as early as possible, as soon as all essential\n   * interface elements loaded. Once this method called, the loading placeholder is hidden\n   * and the Mini App shown.\n   *\n   * If the method not called, the placeholder will be hidden only when the page fully loaded.\n   */\n  ready() {\n    this.postEvent(\"web_app_ready\");\n  }\n  /**\n   * Requests current user contact information. In contrary to requestPhoneAccess, this method\n   * returns promise with contact information that rejects in case, user denied access, or request\n   * failed.\n   * @param options - additional options.\n   */\n  async requestContact({ timeout: t = 5e3 } = {}) {\n    try {\n      return await this.getRequestedContact();\n    } catch {\n    }\n    if (await this.requestPhoneAccess() !== \"sent\")\n      throw new Error(\"Access denied.\");\n    const s = Date.now() + t;\n    let n = 50;\n    return Dt(async () => {\n      for (; Date.now() < s; ) {\n        try {\n          return await this.getRequestedContact();\n        } catch {\n        }\n        await us(n), n += 50;\n      }\n      throw Nt(t);\n    }, t);\n  }\n  /**\n   * Requests current user phone access. Method returns promise, which resolves\n   * status of the request. In case, user accepted the request, Mini App bot will receive\n   * the according notification.\n   *\n   * To obtain the retrieved information instead, utilize the `requestContact` method.\n   * @param options - additional options.\n   * @see requestContact\n   */\n  async requestPhoneAccess(t = {}) {\n    return this.requestPhoneAccessPromise || (this.requestPhoneAccessPromise = g({\n      ...t,\n      method: \"web_app_request_phone\",\n      event: \"phone_requested\",\n      postEvent: this.postEvent\n    }).then(({ status: s }) => s).finally(() => this.requestPhoneAccessPromise = void 0)), this.requestPhoneAccessPromise;\n  }\n  /**\n   * Requests write message access to current user.\n   * @param options - additional options.\n   */\n  async requestWriteAccess(t = {}) {\n    return this.requestWriteAccessPromise || (this.requestWriteAccessPromise = g({\n      ...t,\n      method: \"web_app_request_write_access\",\n      event: \"write_access_requested\",\n      postEvent: this.postEvent\n    }).then(({ status: s }) => s).finally(() => this.requestWriteAccessPromise = void 0)), this.requestWriteAccessPromise;\n  }\n  /**\n   * A method used to send data to the bot. When this method called, a service message sent to\n   * the bot containing the data of the length up to 4096 bytes, and the Mini App closed. See the\n   * field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n   *\n   * This method is only available for Mini Apps launched via a Keyboard button.\n   * @param data - data to send to bot.\n   * @throws {Error} data has incorrect size.\n   */\n  sendData(t) {\n    const { size: s } = new Blob([t]);\n    if (!s || s > 4096)\n      throw new Error(`Passed data has incorrect size: ${s}`);\n    this.postEvent(\"web_app_data_send\", { data: t });\n  }\n  /**\n   * Updates current Mini App header color.\n   *\n   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/tma.js/issues/9\n   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/tma.js/issues/8\n   * @param color - color key or RGB color.\n   */\n  setHeaderColor(t) {\n    this.postEvent(\"web_app_set_header_color\", ct(t) ? { color: t } : { color_key: t }), this.set(\"headerColor\", t);\n  }\n  /**\n   * Updates current Mini App background color.\n   *\n   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/tma.js/issues/9\n   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/tma.js/issues/8\n   * @param color - RGB color.\n   */\n  setBgColor(t) {\n    this.postEvent(\"web_app_set_background_color\", { color: t }), this.set(\"bgColor\", t);\n  }\n  /**\n   * Inserts the bot's username and the specified inline query in the current chat's input field.\n   * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n   * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n   * the specified inline query in the input field.\n   * @param text - text which should be inserted in the input after the current bot name. Max\n   * length is 256 symbols.\n   * @param chatTypes - List of chat types which could be chosen to send the message. Could be\n   * empty list.\n   */\n  switchInlineQuery(t, s = []) {\n    if (!this.supports(\"switchInlineQuery\") && !this.isBotInline)\n      throw new Error(\"Method is unsupported because Mini App should be launched in inline mode.\");\n    this.postEvent(\"web_app_switch_inline_query\", { query: t, chat_types: s });\n  }\n}\nconst ds = l(\n  \"miniApp\",\n  ({\n    themeParams: e,\n    botInline: t = !1,\n    state: s = {\n      bgColor: e.bgColor || \"#ffffff\",\n      headerColor: e.headerBgColor || \"#000000\"\n    },\n    ...n\n  }) => new ls({ ...n, ...s, botInline: t })\n);\nfunction _s(e) {\n  const t = e.message.trim(), s = (e.title || \"\").trim(), n = e.buttons || [];\n  let r;\n  if (s.length > 64)\n    throw new Error(`Title has incorrect size: ${s.length}`);\n  if (!t.length || t.length > 256)\n    throw new Error(`Message has incorrect size: ${t.length}`);\n  if (n.length > 3)\n    throw new Error(`Buttons have incorrect size: ${n.length}`);\n  return n.length ? r = n.map((i) => {\n    const { id: o = \"\" } = i;\n    if (o.length > 64)\n      throw new Error(`Button ID has incorrect size: ${o}`);\n    if (!i.type || i.type === \"default\" || i.type === \"destructive\") {\n      const a = i.text.trim();\n      if (!a.length || a.length > 64) {\n        const h = i.type || \"default\";\n        throw new Error(`Button text with type \"${h}\" has incorrect size: ${i.text.length}`);\n      }\n      return { ...i, text: a, id: o };\n    }\n    return { ...i, id: o };\n  }) : r = [{ type: \"close\", id: \"\" }], { title: s, message: t, buttons: r };\n}\nclass gs extends $ {\n  constructor(t, s, n) {\n    super({ isOpened: t }, s, { open: \"web_app_open_popup\" }), this.postEvent = n;\n  }\n  set isOpened(t) {\n    this.set(\"isOpened\", t);\n  }\n  /**\n   * True if the Popup is opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  /**\n   * A method that shows a native popup described by the `params` argument.\n   * Promise will be resolved when popup is closed. Resolved value will have\n   * an identifier of pressed button.\n   *\n   * In case, user clicked outside the popup or clicked top right popup close\n   * button, null will be returned.\n   *\n   * @param options - popup parameters.\n   * @throws {Error} Popup is already opened.\n   */\n  async open(t) {\n    if (this.isOpened)\n      throw new Error(\"Popup is already opened.\");\n    this.isOpened = !0;\n    try {\n      const { button_id: s = null } = await g({\n        event: \"popup_closed\",\n        method: \"web_app_open_popup\",\n        postEvent: this.postEvent,\n        params: _s(t)\n      });\n      return s;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nconst ws = l(\n  ({ postEvent: e, version: t }) => new gs(!1, t, e)\n);\nclass fs extends $ {\n  constructor(t, s, n) {\n    super({ isOpened: t }, s, {\n      close: \"web_app_close_scan_qr_popup\",\n      open: \"web_app_open_scan_qr_popup\"\n    }), this.postEvent = n;\n  }\n  /**\n   * Closes the scanner.\n   */\n  close() {\n    this.postEvent(\"web_app_close_scan_qr_popup\"), this.isOpened = !1;\n  }\n  set isOpened(t) {\n    this.set(\"isOpened\", t);\n  }\n  /**\n   * Returns true if the scanner is currently opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  async open(t) {\n    if (this.isOpened)\n      throw new Error(\"The scanner is already opened\");\n    const { text: s, capture: n } = (typeof t == \"string\" ? { text: t } : t) || {};\n    this.isOpened = !0;\n    try {\n      const r = (await g({\n        method: \"web_app_open_scan_qr_popup\",\n        event: [\"qr_text_received\", \"scan_qr_popup_closed\"],\n        postEvent: this.postEvent,\n        params: { text: s },\n        capture(i) {\n          return i.event === \"scan_qr_popup_closed\" || !n || n(i.payload);\n        }\n      }) || {}).data || null;\n      return r && this.close(), r;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n  // TODO: Streaming mode, allowing to scan several QRs until closed.\n}\nconst ms = l(\n  ({ version: e, postEvent: t }) => new fs(!1, e, t)\n);\nclass bs extends pt {\n  constructor(t, s, n) {\n    super({ isVisible: t }, s, {\n      show: \"web_app_setup_settings_button\",\n      hide: \"web_app_setup_settings_button\"\n    }), c(this, \"on\", (r, i) => r === \"click\" ? y(\"settings_button_pressed\", i) : this.state.on(r, i)), c(this, \"off\", (r, i) => r === \"click\" ? z(\"settings_button_pressed\", i) : this.state.off(r, i)), this.postEvent = n;\n  }\n  set isVisible(t) {\n    this.set(\"isVisible\", t), this.postEvent(\"web_app_setup_settings_button\", { is_visible: t });\n  }\n  /**\n   * True if the SettingsButton is visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Hides the SettingsButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the SettingsButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nconst vs = l(\n  \"settingsButton\",\n  ({\n    version: e,\n    postEvent: t,\n    state: s = { isVisible: !1 }\n  }) => new bs(s.isVisible, e, t)\n);\nfunction Zt(e) {\n  return Ht().parse(e);\n}\nclass ys extends dt {\n  /**\n   * @since v6.10\n   */\n  get accentTextColor() {\n    return this.get(\"accentTextColor\");\n  }\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  get buttonColor() {\n    return this.get(\"buttonColor\");\n  }\n  get buttonTextColor() {\n    return this.get(\"buttonTextColor\");\n  }\n  get destructiveTextColor() {\n    return this.get(\"destructiveTextColor\");\n  }\n  /**\n   * Returns the copy of the internal state of the current component instance.\n   */\n  getState() {\n    return this.clone();\n  }\n  /**\n   * @since v6.10\n   */\n  get headerBgColor() {\n    return this.get(\"headerBgColor\");\n  }\n  get hintColor() {\n    return this.get(\"hintColor\");\n  }\n  /**\n   * @returns True in case, current color scheme is recognized as dark. This\n   * value is calculated according to theme bg color.\n   */\n  get isDark() {\n    return !this.bgColor || Bt(this.bgColor);\n  }\n  get linkColor() {\n    return this.get(\"linkColor\");\n  }\n  get secondaryBgColor() {\n    return this.get(\"secondaryBgColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionBgColor() {\n    return this.get(\"sectionBgColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionHeaderTextColor() {\n    return this.get(\"sectionHeaderTextColor\");\n  }\n  /**\n   * @since v7.6\n   */\n  get sectionSeparatorColor() {\n    return this.get(\"sectionHeaderTextColor\");\n  }\n  /**\n   * Starts listening to the external theme changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return y(\"theme_changed\", (t) => {\n      this.set(Zt(t.theme_params));\n    });\n  }\n  /**\n   * @since v6.10\n   */\n  get subtitleTextColor() {\n    return this.get(\"subtitleTextColor\");\n  }\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nconst Es = l(\n  \"themeParams\",\n  ({ themeParams: e, state: t = e, addCleanup: s }) => {\n    const n = new ys(t);\n    return s(n.listen()), n;\n  }\n);\nfunction bn(e = {}) {\n  return g({\n    ...e,\n    method: \"web_app_request_theme\",\n    event: \"theme_changed\"\n  }).then(Zt);\n}\nfunction B(e, t) {\n  return e.startsWith(t) ? e : `${t}${e}`;\n}\nfunction M(e) {\n  return new URL(\n    typeof e == \"string\" ? e : `${e.pathname || \"\"}${B(e.search || \"\", \"?\")}${B(e.hash || \"\", \"#\")}`,\n    \"http://a\"\n  );\n}\nclass Ps extends _t {\n  constructor(t, s, n) {\n    super(t, { readTextFromClipboard: \"web_app_read_text_from_clipboard\" }), c(this, \"supportsParam\"), this.version = t, this.createRequestId = s, this.postEvent = n, this.supportsParam = Yt(t, {\n      \"openLink.tryInstantView\": [\"web_app_open_link\", \"try_instant_view\"]\n    });\n  }\n  openLink(t, s) {\n    const n = M(t).toString();\n    if (!C(\"web_app_open_link\", this.version)) {\n      window.open(n, \"_blank\");\n      return;\n    }\n    const r = typeof s == \"boolean\" ? { tryInstantView: s } : s || {};\n    this.postEvent(\"web_app_open_link\", {\n      url: n,\n      try_browser: r.tryBrowser,\n      try_instant_view: r.tryInstantView\n    });\n  }\n  /**\n   * Opens a Telegram link inside Telegram app. The Mini App will be closed. It expects passing\n   * link in full format, with hostname \"t.me\".\n   * @param url - URL to be opened.\n   * @throws {Error} URL has not allowed hostname.\n   */\n  openTelegramLink(t) {\n    const { hostname: s, pathname: n, search: r } = new URL(t, \"https://t.me\");\n    if (s !== \"t.me\")\n      throw new Error(`URL has not allowed hostname: ${s}. Only \"t.me\" is allowed`);\n    if (!C(\"web_app_open_tg_link\", this.version)) {\n      window.location.href = t;\n      return;\n    }\n    this.postEvent(\"web_app_open_tg_link\", { path_full: n + r });\n  }\n  /**\n   * Reads text from clipboard and returns string or null. null is returned\n   * in cases:\n   * - Value in clipboard is not text\n   * - Access to clipboard is not allowed\n   */\n  async readTextFromClipboard() {\n    const t = this.createRequestId(), {\n      data: s = null\n    } = await g({\n      method: \"web_app_read_text_from_clipboard\",\n      event: \"clipboard_text_received\",\n      postEvent: this.postEvent,\n      params: { req_id: t },\n      capture: qt(t)\n    });\n    return s;\n  }\n  /**\n   * Shares specified URL with the passed to the chats, selected by user. After being called,\n   * it closes the mini application.\n   *\n   * This method uses Telegram's Share Links.\n   * @param url - URL to share.\n   * @param text - text to append after the URL.\n   * @see https://core.telegram.org/api/links#share-links\n   * @see https://core.telegram.org/widgets/share#custom-buttons\n   */\n  shareURL(t, s) {\n    this.openTelegramLink(\n      \"https://t.me/share/url?\" + new URLSearchParams({ url: t, text: s || \"\" }).toString().replace(/\\+/g, \"%20\")\n    );\n  }\n}\nconst Rs = l(\n  ({ version: e, postEvent: t, createRequestId: s }) => new Ps(e, s, t)\n);\nasync function Xt(e = {}) {\n  const {\n    is_expanded: t,\n    is_state_stable: s,\n    ...n\n  } = await g({\n    ...e,\n    method: \"web_app_request_viewport\",\n    event: \"viewport_changed\"\n  });\n  return { ...n, isExpanded: t, isStateStable: s };\n}\nfunction O(e) {\n  return e < 0 ? 0 : e;\n}\nclass xs extends dt {\n  constructor({ postEvent: t, stableHeight: s, height: n, width: r, isExpanded: i }) {\n    super({\n      height: O(n),\n      isExpanded: i,\n      stableHeight: O(s),\n      width: O(r)\n    }), c(this, \"postEvent\"), this.postEvent = t;\n  }\n  /**\n   * Requests viewport information from the Telegram application and updates current Viewport\n   * instance.\n   * @param options - options to request fresh data.\n   */\n  async sync(t) {\n    const { isStateStable: s, ...n } = await Xt(t);\n    this.set({\n      ...n,\n      stableHeight: s ? n.height : this.get(\"stableHeight\")\n    });\n  }\n  /**\n   * The current height of the **visible area** of the Mini App.\n   *\n   * The application can display just the top part of the Mini App, with its lower part remaining\n   * outside the screen area. From this position, the user can \"pull\" the Mini App to its\n   * maximum height, while the bot can do the same by calling `expand` method. As the position of\n   * the Mini App changes, the current height value of the visible area will be updated  in real\n   * time.\n   *\n   * Please note that the refresh rate of this value is not sufficient to smoothly follow the\n   * lower border of the window. It should not be used to pin interface elements to the bottom\n   * of the visible area. It's more appropriate to use the value of the `stableHeight`\n   * field for this purpose.\n   *\n   * @see stableHeight\n   */\n  get height() {\n    return this.get(\"height\");\n  }\n  /**\n   * The height of the visible area of the Mini App in its last stable state.\n   *\n   * The application can display just the top part of the Mini App, with its lower part remaining\n   * outside the screen area. From this position, the user can \"pull\" the Mini App to its\n   * maximum height, while the application can do the same by calling `expand` method.\n   *\n   * Unlike the value of `height`, the value of `stableHeight` does not change as the position\n   * of the Mini App changes with user gestures or during animations. The value of `stableHeight`\n   * will be updated after all gestures and animations are completed and\n   * the Mini App reaches its final size.\n   *\n   * @see height\n   */\n  get stableHeight() {\n    return this.get(\"stableHeight\");\n  }\n  /**\n   * Starts listening to viewport changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return y(\"viewport_changed\", (t) => {\n      const {\n        height: s,\n        width: n,\n        is_expanded: r,\n        is_state_stable: i\n      } = t, o = O(s);\n      this.set({\n        height: o,\n        isExpanded: r,\n        width: O(n),\n        ...i ? { stableHeight: o } : {}\n      });\n    });\n  }\n  /**\n   * True if the Mini App is expanded to the maximum available height. Otherwise, if\n   * the Mini App occupies part of the screen and can be expanded to the full height using\n   * `expand` method.\n   * @see expand\n   */\n  get isExpanded() {\n    return this.get(\"isExpanded\");\n  }\n  /**\n   * Current visible area width.\n   */\n  get width() {\n    return this.get(\"width\");\n  }\n  /**\n   * A method that expands the Mini App to the maximum available height. To find out if the Mini\n   * App is expanded to the maximum height, refer to the value of the `isExpanded`.\n   * @see isExpanded\n   */\n  expand() {\n    this.postEvent(\"web_app_expand\"), this.set(\"isExpanded\", !0);\n  }\n  /**\n   * True if the current viewport height is stable and is not going to change in the next moment.\n   */\n  get isStable() {\n    return this.stableHeight === this.height;\n  }\n}\nconst Cs = l(\n  \"viewport\",\n  async ({ state: e, platform: t, postEvent: s, addCleanup: n }) => {\n    let r = !1, i = 0, o = 0, a = 0;\n    if (e)\n      r = e.isExpanded, i = e.height, o = e.width, a = e.stableHeight;\n    else if ([\"macos\", \"tdesktop\", \"unigram\", \"webk\", \"weba\", \"web\"].includes(t))\n      r = !0, i = window.innerHeight, o = window.innerWidth, a = window.innerHeight;\n    else {\n      const p = await Xt({ timeout: 1e3, postEvent: s });\n      r = p.isExpanded, i = p.height, o = p.width, a = p.isStateStable ? i : 0;\n    }\n    const h = new xs({\n      postEvent: s,\n      height: i,\n      width: o,\n      stableHeight: a,\n      isExpanded: r\n    });\n    return n(h.listen()), h;\n  }\n);\nfunction P(e, t) {\n  document.documentElement.style.setProperty(e, t);\n}\nfunction vn(e, t, s) {\n  s || (s = (a) => `--tg-${a}-color`);\n  const n = s(\"header\"), r = s(\"bg\"), i = () => {\n    const { headerColor: a } = e;\n    if (ct(a))\n      P(n, a);\n    else {\n      const { bgColor: h, secondaryBgColor: p } = t;\n      a === \"bg_color\" && h ? P(n, h) : a === \"secondary_bg_color\" && p && P(n, p);\n    }\n    P(r, e.bgColor);\n  }, o = [\n    t.on(\"change\", i),\n    e.on(\"change\", i)\n  ];\n  return i(), () => o.forEach((a) => a());\n}\nfunction yn(e, t) {\n  t || (t = (n) => `--tg-theme-${n.replace(/[A-Z]/g, (r) => `-${r.toLowerCase()}`)}`);\n  const s = () => {\n    Object.entries(e.getState()).forEach(([n, r]) => {\n      r && P(t(n), r);\n    });\n  };\n  return s(), e.on(\"change\", s);\n}\nfunction En(e, t) {\n  t || (t = (p) => `--tg-viewport-${p}`);\n  const [\n    s,\n    n,\n    r\n  ] = [\"height\", \"width\", \"stable-height\"].map((p) => t(p)), i = () => P(s, `${e.height}px`), o = () => P(n, `${e.width}px`), a = () => P(r, `${e.stableHeight}px`), h = [\n    e.on(\"change:height\", i),\n    e.on(\"change:width\", o),\n    e.on(\"change:stableHeight\", a)\n  ];\n  return i(), o(), a(), () => h.forEach((p) => p());\n}\nfunction Ss(e = !0) {\n  const t = [\n    y(\"reload_iframe\", () => {\n      V(\"iframe_will_reload\"), window.location.reload();\n    })\n  ], s = () => t.forEach((n) => n());\n  if (e) {\n    const n = document.createElement(\"style\");\n    n.id = \"telegram-custom-styles\", document.head.appendChild(n), t.push(\n      y(\"set_custom_style\", (r) => {\n        n.innerHTML = r;\n      }),\n      () => document.head.removeChild(n)\n    );\n  }\n  return V(\"iframe_ready\", { reload_supported: !0 }), s;\n}\nfunction Ts() {\n  return typeof window > \"u\";\n}\nasync function Pn() {\n  if (kt(window))\n    return !0;\n  try {\n    return await g({ method: \"web_app_request_theme\", event: \"theme_changed\", timeout: 100 }), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction Rn(e) {\n  const t = typeof e == \"string\" ? lt(e) : e;\n  Jt(t);\n  function s(r) {\n    if (typeof r == \"string\")\n      try {\n        const { eventType: i } = At(r);\n        i === \"web_app_request_theme\" && et(\"theme_changed\", {\n          theme_params: JSON.parse(Kt(t.themeParams))\n        }), i === \"web_app_request_viewport\" && et(\"viewport_changed\", {\n          width: window.innerWidth,\n          height: window.innerHeight,\n          is_state_stable: !0,\n          is_expanded: !0\n        });\n      } catch {\n      }\n  }\n  if (at()) {\n    const r = window.parent.postMessage.bind(window.parent);\n    window.parent.postMessage = (i) => {\n      s(i), r(i);\n    };\n    return;\n  }\n  if (It(window)) {\n    const r = window.external.notify.bind(window.external);\n    window.external.notify = (i) => {\n      s(i), r(i);\n    };\n    return;\n  }\n  const n = window.TelegramWebviewProxy;\n  window.TelegramWebviewProxy = {\n    ...n || {},\n    postEvent(...r) {\n      s(JSON.stringify({ eventType: r[0], eventData: r[1] })), n && n.postEvent(...r);\n    }\n  };\n}\nfunction As(e) {\n  return e instanceof W;\n}\nfunction xn(e, t) {\n  return As(e) && e.type === t;\n}\nfunction J(e, t) {\n  let s, n, r;\n  return typeof e == \"string\" ? s = e : (s = e.pathname === void 0 ? t : e.pathname, n = e.params, r = e.id), Object.freeze({\n    id: r || (Math.random() * 2 ** 14 | 0).toString(16),\n    pathname: s,\n    params: n\n  });\n}\nclass Is {\n  constructor(t, s, n = V) {\n    if (c(this, \"history\"), c(this, \"ee\", new D()), c(this, \"attached\", !1), c(this, \"back\", () => this.go(-1)), c(this, \"on\", this.ee.on.bind(this.ee)), c(this, \"off\", this.ee.off.bind(this.ee)), this._index = s, this.postEvent = n, t.length === 0)\n      throw m(be, \"History should not be empty.\");\n    if (s < 0 || s >= t.length)\n      throw m(\n        ve,\n        \"Index should not be zero and higher or equal than history size.\"\n      );\n    this.history = t.map((r) => J(r, \"\"));\n  }\n  /**\n   * Allows this navigator to control the `BackButton` visibility state. It also tracks the\n   * `BackButton` clicks and calls the `back` method.\n   */\n  attach() {\n    this.attached || (this.attached = !0, this.sync(), y(\"back_button_pressed\", this.back));\n  }\n  /**\n   * Currently active history item.\n   */\n  get current() {\n    return this.history[this.index];\n  }\n  /**\n   * Prevents current navigator from controlling the BackButton visibility state.\n   */\n  detach() {\n    this.attached = !1, z(\"back_button_pressed\", this.back);\n  }\n  /**\n   * Goes to the next history item.\n   */\n  forward() {\n    this.go(1);\n  }\n  /**\n   * Changes currently active history item index by the specified delta. This method doesn't\n   * change index in case, the updated index points to the non-existing history item. This behavior\n   * is preserved until the `fit` argument is specified.\n   * @param delta - index delta.\n   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.\n   */\n  go(t, s) {\n    const n = this.index + t, r = Math.min(\n      Math.max(0, n),\n      this.history.length - 1\n    );\n    (n === r || s) && this.replaceAndMove(r, this.history[r]);\n  }\n  /**\n   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.\n   *\n   * If \"fit\" option was specified and index is out of bounds, it will be cut to the nearest\n   * bound.\n   * @param index - target index.\n   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.\n   */\n  goTo(t, s) {\n    this.go(t - this.index, s);\n  }\n  /**\n   * True if navigator has items before the current item.\n   */\n  get hasPrev() {\n    return this.index > 0;\n  }\n  /**\n   * True if navigator has items after the current item.\n   */\n  get hasNext() {\n    return this.index !== this.history.length - 1;\n  }\n  /**\n   * Currently active history item index.\n   */\n  get index() {\n    return this._index;\n  }\n  /**\n   * Adds a new history item removing all after the current one.\n   * @param item - item to add.\n   */\n  push(t) {\n    this.hasNext && this.history.splice(this.index + 1), this.replaceAndMove(this.index + 1, J(t, this.current.pathname));\n  }\n  /**\n   * Replaces the current history item.\n   * @param item - item to replace the current item with.\n   */\n  replace(t) {\n    this.replaceAndMove(this.index, J(t, this.current.pathname));\n  }\n  /**\n   * Sets history item by the specified index.\n   * @param index - history item index to replace.\n   * @param historyItem - history item to set.\n   */\n  replaceAndMove(t, s) {\n    const n = t - this.index;\n    if (!n && this.current === s)\n      return;\n    const r = this.current;\n    if (this.index !== t) {\n      const i = this._index;\n      this._index = t, this.attached && i > 0 != t > 0 && this.sync();\n    }\n    this.history[t] = s, this.ee.emit(\"change\", {\n      navigator: this,\n      from: r,\n      to: this.current,\n      delta: n\n    });\n  }\n  /**\n   * Actualizes the `BackButton` visibility state.\n   */\n  sync() {\n    this.postEvent(\"web_app_setup_back_button\", { is_visible: !!this.index });\n  }\n}\nfunction F({\n  params: e,\n  ...t\n}) {\n  return { ...e || { hash: \"\", search: \"\" }, ...t };\n}\nfunction U(e) {\n  const t = typeof e == \"string\" ? e.startsWith(\"/\") : !!(e.pathname && e.pathname.startsWith(\"/\")), s = M(e);\n  return `${t ? s.pathname : s.pathname.slice(1)}${s.search}${s.hash}`;\n}\nfunction Q(e, t, s) {\n  let n, r;\n  typeof e == \"string\" ? n = e : (n = U(e), s = e.state, r = e.id);\n  const { pathname: i, search: o, hash: a } = new URL(n, `http://a${B(t, \"/\")}`);\n  return { id: r, pathname: i, params: { hash: a, search: o, state: s } };\n}\nasync function N(e) {\n  return e === 0 ? !0 : Promise.race([\n    new Promise((t) => {\n      const s = tt(\"popstate\", () => {\n        s(), t(!0);\n      });\n      window.history.go(e);\n    }),\n    // Usually, it takes about 1ms to emit this event, but we use some buffer.\n    new Promise((t) => {\n      setTimeout(t, 50, !1);\n    })\n  ]);\n}\nasync function ks() {\n  if (window.history.length <= 1 || (window.history.pushState(null, \"\"), await N(1 - window.history.length)))\n    return;\n  let e = await N(-1);\n  for (; e; )\n    e = await N(-1);\n}\nfunction te(e) {\n  return M(e).pathname;\n}\nconst Et = 0, Y = 1, Z = 2;\nclass ee {\n  constructor(t, s, { postEvent: n, hashMode: r = \"classic\", base: i } = {}) {\n    c(this, \"navigator\"), c(this, \"ee\", new D()), c(this, \"hashMode\"), c(this, \"base\"), c(this, \"attached\", !1), c(this, \"onPopState\", ({ state: o }) => {\n      if (o === null)\n        return this.push(this.parsePath(window.location.href));\n      o === Et ? window.history.forward() : o === Y && this.back(), o === Z && this.forward();\n    }), c(this, \"onNavigatorChange\", async ({\n      to: o,\n      from: a,\n      delta: h\n    }) => {\n      this.attached && await this.syncHistory(), this.ee.emit(\"change\", {\n        delta: h,\n        from: F(a),\n        to: F(o),\n        navigator: this\n      });\n    }), c(this, \"on\", this.ee.on.bind(this.ee)), c(this, \"off\", this.ee.off.bind(this.ee)), this.navigator = new Is(\n      t.map((o) => Q(o, \"/\")),\n      s,\n      n\n    ), this.navigator.on(\"change\", (o) => {\n      this.onNavigatorChange(o);\n    }), this.hashMode = r, this.base = te(i || \"\");\n  }\n  /**\n   * Attaches current navigator to the browser history allowing navigator to manipulate it.\n   */\n  async attach() {\n    this.attached || (this.attached = !0, this.navigator.attach(), window.addEventListener(\"popstate\", this.onPopState), await this.syncHistory());\n  }\n  /**\n   * Goes back in history by 1.\n   */\n  back() {\n    this.navigator.back();\n  }\n  /**\n   * Detaches current navigator from the browser history.\n   */\n  detach() {\n    this.attached = !1, this.navigator.detach(), window.removeEventListener(\"popstate\", this.onPopState);\n  }\n  /**\n   * Goes forward in history.\n   */\n  forward() {\n    return this.navigator.forward();\n  }\n  /**\n   * Current history cursor.\n   */\n  get index() {\n    return this.navigator.index;\n  }\n  /**\n   * Current history item identifier.\n   */\n  get id() {\n    return this.navigator.current.id;\n  }\n  /**\n   * Changes currently active history item index by the specified delta. This method doesn't\n   * change index in case, the updated index points to the non-existing history item. This behavior\n   * is preserved until the `fit` argument is specified.\n   * @param delta - index delta.\n   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.\n   */\n  go(t, s) {\n    return this.navigator.go(t, s);\n  }\n  /**\n   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.\n   *\n   * If \"fit\" option was specified and index is out of bounds, it will be cut to the nearest\n   * bound.\n   * @param index - target index.\n   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.\n   */\n  goTo(t, s) {\n    this.navigator.goTo(t, s);\n  }\n  /**\n   * Current history item hash.\n   * @see URL.hash\n   * @example\n   * \"\", \"#my-hash\"\n   */\n  get hash() {\n    return (this.navigator.current.params || {}).hash || \"\";\n  }\n  /**\n   * True if navigator has items before the current item.\n   */\n  get hasPrev() {\n    return this.navigator.hasPrev;\n  }\n  /**\n   * True if navigator has items after the current item.\n   */\n  get hasNext() {\n    return this.navigator.hasNext;\n  }\n  /**\n   * Navigation history.\n   */\n  get history() {\n    return this.navigator.history.map(F);\n  }\n  /**\n   * Path, including pathname, search and hash.\n   * @example Pathname only.\n   * \"/pathname\"\n   * @example Pathname + search.\n   * \"/pathname?search\"\n   * @example Pathname + hash.\n   * \"/pathname#hash\"\n   * @example Pathname + search + hash.\n   * \"/pathname?search#hash\"\n   */\n  get path() {\n    return U(this);\n  }\n  /**\n   * Current pathname. Always starts with the slash.\n   * @see URL.pathname\n   * @example\n   * \"/\", \"/abc\"\n   */\n  get pathname() {\n    return this.navigator.current.pathname;\n  }\n  /**\n   * Depending on the current navigation type, parses incoming path and returns it presented as\n   * an object. In other words, this method parses the passed path and returns object, describing\n   * how the navigator \"sees\" it.\n   *\n   * @example Hash mode is omitted.\n   * parsePath('/abc?a=1#hash');\n   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }\n   * parsePath('http://example.com/abc?a=1#hash');\n   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }\n   *\n   * @example Hash mode is enabled.\n   * parsePath('/abc?a=1#tma?is=cool#yeah');\n   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }\n   * parsePath('http://example.com/abc?a=1#tma?is=cool#yeah');\n   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }\n   */\n  parsePath(t) {\n    let s = M(t);\n    return this.hashMode && (s = M(s.hash.slice(1))), {\n      pathname: s.pathname,\n      search: s.search,\n      hash: s.hash\n    };\n  }\n  push(t, s) {\n    const n = Q(t, this.path), { state: r = s } = n.params;\n    this.navigator.push({ ...n, params: { ...n.params, state: r } });\n  }\n  replace(t, s) {\n    const n = Q(t, this.path), { state: r = s } = n.params;\n    this.navigator.replace({ ...n, params: { ...n.params, state: r } });\n  }\n  /**\n   * Combines the navigator `base` property with the passed path data applying the navigator\n   * navigation mode.\n   * @param value - path presented as string or URLLike.\n   */\n  renderPath(t) {\n    const s = (this.base.length === 1 ? \"\" : this.base) + B(U(t), \"/\");\n    return this.hashMode ? B(s.slice(1), this.hashMode === \"classic\" ? \"#\" : \"#/\") : s;\n  }\n  /**\n   * Synchronizes current navigator state with browser history.\n   */\n  async syncHistory() {\n    window.removeEventListener(\"popstate\", this.onPopState);\n    const { state: t } = this, s = this.renderPath(this);\n    await ks(), this.hasPrev && this.hasNext ? (window.history.replaceState(Y, \"\"), window.history.pushState(t, \"\", s), window.history.pushState(Z, \"\"), await N(-1)) : this.hasPrev ? (window.history.replaceState(Y, \"\"), window.history.pushState(t, \"\", s)) : this.hasNext ? (window.history.replaceState(t, s), window.history.pushState(Z, \"\"), await N(-1)) : (window.history.replaceState(Et, \"\"), window.history.pushState(t, \"\", s)), window.addEventListener(\"popstate\", this.onPopState);\n  }\n  /**\n   * Current query parameters.\n   * @see URL.search\n   * @example\n   * \"\", \"?\", \"?a=1\"\n   */\n  get search() {\n    return (this.navigator.current.params || {}).search || \"\";\n  }\n  /**\n   * Current history item state.\n   */\n  get state() {\n    return (this.navigator.current.params || {}).state;\n  }\n}\nfunction Os(e) {\n  e || (e = {});\n  const { href: t, hash: s } = window.location;\n  let n = U(\n    e.hashMode === null ? t : s.includes(\"?\") ? s.slice(1) : `?${s.slice(1)}`\n  );\n  const r = e.base ? te(e.base) : void 0;\n  if (r) {\n    if (!n.startsWith(r))\n      throw m(\n        ye,\n        `Path \"${n}\" expected to be starting with \"${r}\"`\n      );\n    n = n.slice(r.length);\n  }\n  return new ee([n], 0, e);\n}\nfunction Cn(e) {\n  const t = e.match(/#(.+)/);\n  return t ? t[1] : null;\n}\nfunction qs(e, t) {\n  if (Ft()) {\n    const s = sessionStorage.getItem(e);\n    if (s)\n      try {\n        const { index: n, history: r } = JSON.parse(s);\n        return new ee(\n          r,\n          n,\n          t\n        );\n      } catch (n) {\n        console.error(\"Unable to restore hash navigator state.\", n);\n      }\n  }\n  return Os(t);\n}\nfunction Sn(e, t) {\n  const s = qs(e, t), n = () => sessionStorage.setItem(e, JSON.stringify({\n    index: s.index,\n    history: s.history\n  }));\n  return s.on(\"change\", n), n(), s;\n}\nfunction d(e, t) {\n  function s(n) {\n    return function(i, o, a) {\n      return (h) => {\n        const p = {\n          ...h,\n          [i]: n(o)\n        };\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(a, { ...p });\n      };\n    };\n  }\n  return [s(e), s(t)];\n}\nconst se = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(void 0);\nfunction Ns() {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(se);\n  if (!e)\n    throw new Error(\"useSDK was used outside the SDKProvider.\");\n  return e;\n}\nfunction _(e) {\n  function t(n) {\n    const r = Ns(), [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\n      n ? void 0 : () => {\n        if (Ts())\n          throw new Error(\"Using hooks on the server side, you must explicitly specify ssr = true option\");\n        return r.use(e);\n      }\n    );\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      o(r.use(e));\n    }, [r]), i;\n  }\n  function s(n) {\n    const r = t(n);\n    if (r) {\n      if (\"error\" in r)\n        throw r.error;\n      return r.result;\n    }\n  }\n  return [t, s];\n}\nconst [Ds, Vs] = _(je), [Tn, An] = d(\n  Ds,\n  Vs\n), [Bs, Ms] = _(Je), [In, kn] = d(\n  Bs,\n  Ms\n), [Ls, $s] = _(Qe), [On, qn] = d(\n  Ls,\n  $s\n), [Hs, Us] = _(es), [Nn, Dn] = d(\n  Hs,\n  Us\n), [Ws, Gs] = _(ns), [Vn, Bn] = d(\n  Ws,\n  Gs\n), [js, zs] = _(is), [Mn, Ln] = d(js, zs), [Ks, Js] = _(as), [$n, Hn] = d(Ks, Js), [Fs, Qs] = _(hs), [Un, Wn] = d(Fs, Qs), [Ys, Zs] = _(ds), [Gn, jn] = d(Ys, Zs), [Xs, tn] = _(ws), [zn, Kn] = d(Xs, tn), [en, sn] = _(ms), [Jn, Fn] = d(en, sn), [nn, rn] = _(vs), [Qn, Yn] = d(\n  nn,\n  rn\n), [on, an] = _(Es), [Zn, Xn] = d(on, an);\nfunction tr(e) {\n  const [t, s] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => e ? void 0 : nt());\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    e && s(nt());\n  }, []), t;\n}\nconst [cn, hn] = _(Rs), [er, sr] = d(cn, hn), [pn, un] = _(Cs), [nr, rr] = d(pn, un);\nfunction ir({ children: e, acceptCustomStyles: t, debug: s }) {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(!0), [r, i] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(/* @__PURE__ */ new Map()), o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(r), a = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (p) => {\n      n.current && i((S) => (p && p(S), new Map(S)));\n    },\n    []\n  ), h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n    use(p, ...S) {\n      const gt = r.get(p);\n      if (gt)\n        return gt;\n      let b, K;\n      try {\n        b = p(...S);\n      } catch (w) {\n        K = w;\n      }\n      function H(w) {\n        return r.set(p, w), w;\n      }\n      if (K)\n        return H({ error: K });\n      let I;\n      if (Array.isArray(b) && (I = b[1], b = b[0]), !b)\n        return H({ result: b, cleanup: I });\n      function wt(w) {\n        if (\"on\" in w) {\n          const k = w.on(\"change\", () => a()), ft = I;\n          I = () => {\n            ft && ft(), k();\n          };\n        }\n        return { result: w, cleanup: I };\n      }\n      return b instanceof Promise ? (b.then(\n        (w) => a((k) => k.set(p, wt(w))),\n        (w) => a((k) => k.set(p, { error: w }))\n      ), H({})) : H(wt(b));\n    }\n  }), [r]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => (n.current = !0, () => {\n    n.current = !1;\n  }), []), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (at())\n      return Ss(t);\n  }, [t]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    ue(s || !1);\n  }, [s]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    o.current = r;\n  }, [r]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => () => {\n    o.current.forEach((p) => {\n      \"cleanup\" in p && p.cleanup && p.cleanup();\n    });\n  }, []), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(se.Provider, { value: h, children: e });\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRtYS5qcy9zZGstcmVhY3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNnRztBQUM5SSxzRUFBc0UsMERBQTBEO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZUFBZSwyQkFBMkIsdUNBQXVDLGVBQWU7QUFDckc7QUFDQSxXQUFXLEVBQUUsU0FBUyxXQUFXO0FBQ2pDLFNBQVMsR0FBRyw0QkFBNEI7QUFDeEM7QUFDQSxTQUFTLEdBQUcsRUFBRSxhQUFhLEdBQUcsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkMsa0NBQWtDLHNCQUFzQixJQUFJLFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUIsVUFBVSxPQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEMsRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUNBQW1DO0FBQ3pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWix3QkFBd0IsbUdBQW1HLG9CQUFvQixJQUFJLFVBQVU7QUFDN0o7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw0QkFBNEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFLHdDQUF3QyxFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxFQUFFLCtDQUErQyxFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQ0FBbUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVM7QUFDWjtBQUNBO0FBQ0Esb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSw4QkFBOEIsSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSTtBQUN0SDtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNENBQTRDLFNBQVMsZ0hBQWdILEVBQUU7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0IsZ0JBQWdCLEdBQUc7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFVBQVUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQixJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUIsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0MsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0EsNEZBQTRGLHNCQUFzQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw4Q0FBOEM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMEJBQTBCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLEtBQUssMEJBQTBCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGFBQWE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhLE9BQU8sOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBLCtDQUErQyxFQUFFO0FBQ2pEO0FBQ0E7QUFDQSw0RkFBNEYsS0FBSyxTQUFTLEtBQUs7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMEJBQTBCO0FBQy9CO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsY0FBYyxvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdCQUFnQixrRUFBa0U7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUIsSUFBSTtBQUNoRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssVUFBVSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssVUFBVSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBLHlEQUF5RCxFQUFFO0FBQzNELDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxXQUFXLElBQUksY0FBYztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsY0FBYywwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBLHVEQUF1RCxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUUsd0JBQXdCLGNBQWM7QUFDMUY7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2IsR0FBRyxXQUFXLHVCQUF1QixLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYSxPQUFPLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywwQkFBMEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQiw0QkFBNEIsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxPQUFPLE9BQU87QUFDZDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDBCQUEwQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0ZBQWdGLGVBQWU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2Q0FBNkM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtDQUFrQyxFQUFFLEVBQUUsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCLEVBQUUsdUJBQXVCLEVBQUUscUJBQXFCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUEyRDtBQUMxRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQSx1REFBdUQsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDhDQUE4QztBQUNuRDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQW1FO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQyxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0RBQW9EO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFO0FBQzdCO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0IsZ0JBQWdCLEdBQUc7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsU0FBUyx3QkFBd0IsUUFBUSx3QkFBd0IsZUFBZTtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVFQUF1RTtBQUM1RixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EseUJBQXlCLGtDQUFrQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDBCQUEwQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFdBQVcsVUFBVSxzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUMsRUFBRSxTQUFTLEVBQUUsT0FBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0NBQWtDLHdCQUF3QixVQUFVO0FBQzlFLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQWlELElBQUk7QUFDM0UsMElBQTBJLFVBQVU7QUFDcEo7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQsMEJBQTBCLGdCQUFnQix5QkFBeUI7QUFDbkU7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hELDZCQUE2QixnQkFBZ0IseUJBQXlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQSxpRUFBaUUsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRSxrQ0FBa0MsRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBRSxNQUFNLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0RBQUU7QUFDYjtBQUNBLFlBQVksaURBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0NBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBQztBQUNaO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFFO0FBQ25CLFNBQVMsZ0RBQUM7QUFDVjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyw4Q0FBOEM7QUFDNUQsWUFBWSw2Q0FBRSxlQUFlLCtDQUFFLGlDQUFpQyw2Q0FBRSxTQUFTLGtEQUFFO0FBQzdFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxTQUFTLDhDQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0MsYUFBYTtBQUNiO0FBQ0EsR0FBRztBQUNILFNBQVMsZ0RBQUM7QUFDVjtBQUNBLEdBQUcsUUFBUSxnREFBQztBQUNaO0FBQ0E7QUFDQSxHQUFHLFFBQVEsZ0RBQUM7QUFDWjtBQUNBLEdBQUcsUUFBUSxnREFBQztBQUNaO0FBQ0EsR0FBRyxRQUFRLGdEQUFDO0FBQ1o7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLHVCQUF1QixzREFBRSxnQkFBZ0IsdUJBQXVCO0FBQ25FO0FBdUtFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlZ3JhbS1taW5pLWFwcC1uZXh0anMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHRtYS5qcy9zZGstcmVhY3QvZGlzdC9pbmRleC5qcz9mZDA0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCBhcyBQdCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBuZSwgdXNlQ29udGV4dCBhcyByZSwgdXNlU3RhdGUgYXMgcnQsIHVzZUVmZmVjdCBhcyBSLCB1c2VSZWYgYXMgbXQsIHVzZUNhbGxiYWNrIGFzIGllLCB1c2VNZW1vIGFzIG9lIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgYWUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGNlID0gKGUsIHQsIHMpID0+IHQgaW4gZSA/IGFlKGUsIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHMgfSkgOiBlW3RdID0gcywgYyA9IChlLCB0LCBzKSA9PiBjZShlLCB0eXBlb2YgdCAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBzKTtcbmZ1bmN0aW9uIFJ0KGUsIHQpIHtcbiAgbGV0IHM7XG4gIGNvbnN0IG4gPSAoKSA9PiB7XG4gICAgcyAhPT0gdm9pZCAwICYmIHQgJiYgdChzKSwgcyA9IHZvaWQgMDtcbiAgfTtcbiAgcmV0dXJuIFsoKSA9PiBzID09PSB2b2lkIDAgPyBzID0gZShuKSA6IHMsIG5dO1xufVxuZnVuY3Rpb24geHQoZSkge1xuICBjb25zdCB0ID0gaigpLCB7IGNvdW50OiBzIH0gPSB0O1xuICB0LnVuc3Vic2NyaWJlKGUpLCBzICYmICF0LmNvdW50ICYmIFNlKCk7XG59XG5mdW5jdGlvbiBoZShlKSB7XG4gIHJldHVybiBqKCkuc3Vic2NyaWJlKGUpLCAoKSA9PiB4dChlKTtcbn1cbmNsYXNzIHBlIHtcbiAgY29uc3RydWN0b3IodCwgcyA9IHt9KSB7XG4gICAgdGhpcy5zY29wZSA9IHQsIHRoaXMub3B0aW9ucyA9IHM7XG4gIH1cbiAgLyoqXG4gICAqIFByaW50cyBtZXNzYWdlIGludG8gYSBjb25zb2xlIGluIGNhc2UsIGxvZ2dlciBpcyBjdXJyZW50bHkgZW5hYmxlZC5cbiAgICogQHBhcmFtIGxldmVsIC0gbG9nIGxldmVsLlxuICAgKiBAcGFyYW0gYXJncyAtIGFyZ3VtZW50cy5cbiAgICovXG4gIHByaW50KHQsIC4uLnMpIHtcbiAgICBjb25zdCBuID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHIgPSBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tR0JcIiwge1xuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgc2Vjb25kOiBcIjItZGlnaXRcIixcbiAgICAgIGZyYWN0aW9uYWxTZWNvbmREaWdpdHM6IDMsXG4gICAgICB0aW1lWm9uZTogXCJVVENcIlxuICAgIH0pLmZvcm1hdChuKSwgeyB0ZXh0Q29sb3I6IGksIGJnQ29sb3I6IG8gfSA9IHRoaXMub3B0aW9ucywgYSA9IFwiZm9udC13ZWlnaHQ6IGJvbGQ7cGFkZGluZzogMCA1cHg7Ym9yZGVyLXJhZGl1czo1cHhcIjtcbiAgICBjb25zb2xlW3RdKFxuICAgICAgYCVjJHtyfSVjIC8gJWMke3RoaXMuc2NvcGV9YCxcbiAgICAgIGAke2F9O2JhY2tncm91bmQtY29sb3I6IGxpZ2h0Ymx1ZTtjb2xvcjpibGFja2AsXG4gICAgICBcIlwiLFxuICAgICAgYCR7YX07JHtpID8gYGNvbG9yOiR7aX07YCA6IFwiXCJ9JHtvID8gYGJhY2tncm91bmQtY29sb3I6JHtvfWAgOiBcIlwifWAsXG4gICAgICAuLi5zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUHJpbnRzIGVycm9yIG1lc3NhZ2UgaW50byBhIGNvbnNvbGUuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICBlcnJvciguLi50KSB7XG4gICAgdGhpcy5wcmludChcImVycm9yXCIsIC4uLnQpO1xuICB9XG4gIC8qKlxuICAgKiBQcmludHMgbG9nIG1lc3NhZ2UgaW50byBhIGNvbnNvbGUuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICBsb2coLi4udCkge1xuICAgIHRoaXMucHJpbnQoXCJsb2dcIiwgLi4udCk7XG4gIH1cbn1cbmNvbnN0IGl0ID0gbmV3IHBlKFwiU0RLXCIsIHtcbiAgYmdDb2xvcjogXCJmb3Jlc3RncmVlblwiLFxuICB0ZXh0Q29sb3I6IFwid2hpdGVcIlxufSk7XG5sZXQgWCA9ICExO1xuY29uc3QgYnQgPSAoeyBuYW1lOiBlLCBwYXlsb2FkOiB0IH0pID0+IHtcbiAgaXQubG9nKFwiRXZlbnQgcmVjZWl2ZWQ6XCIsIHQgPyB7IG5hbWU6IGUsIHBheWxvYWQ6IHQgfSA6IHsgbmFtZTogZSB9KTtcbn07XG5mdW5jdGlvbiB1ZShlKSB7XG4gIFggIT09IGUgJiYgKFggPSBlLCBlID8gaGUoYnQpIDogeHQoYnQpKTtcbn1cbmZ1bmN0aW9uIGxlKC4uLmUpIHtcbiAgWCAmJiBpdC5sb2coLi4uZSk7XG59XG5jbGFzcyBEIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgYyh0aGlzLCBcImxpc3RlbmVyc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSwgYyh0aGlzLCBcImxpc3RlbmVyc0NvdW50XCIsIDApLCBjKHRoaXMsIFwic3Vic2NyaWJlTGlzdGVuZXJzXCIsIFtdKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKSwgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjb3VudCBvZiBib3VuZCBsaXN0ZW5lcnMuXG4gICAqL1xuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzQ291bnQgKyB0aGlzLnN1YnNjcmliZUxpc3RlbmVycy5sZW5ndGg7XG4gIH1cbiAgZW1pdCh0LCAuLi5zKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMuZm9yRWFjaCgobikgPT4gbih7XG4gICAgICBldmVudDogdCxcbiAgICAgIGFyZ3M6IHNcbiAgICB9KSksICh0aGlzLmxpc3RlbmVycy5nZXQodCkgfHwgW10pLmZvckVhY2goKFtuLCByXSkgPT4ge1xuICAgICAgbiguLi5zKSwgciAmJiB0aGlzLm9mZih0LCBuKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBuZXcgZXZlbnQgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gb25jZSAtIHNob3VsZCBsaXN0ZW5lciBiZSBjYWxsZWQgb25seSBvbmNlLlxuICAgKiBAcmV0dXJucyBGdW5jdGlvbiB0byByZW1vdmUgYm91bmQgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBvbih0LCBzLCBuKSB7XG4gICAgbGV0IHIgPSB0aGlzLmxpc3RlbmVycy5nZXQodCk7XG4gICAgcmV0dXJuIHIgfHwgdGhpcy5saXN0ZW5lcnMuc2V0KHQsIHIgPSBbXSksIHIucHVzaChbcywgbl0pLCB0aGlzLmxpc3RlbmVyc0NvdW50ICs9IDEsICgpID0+IHRoaXMub2ZmKHQsIHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVyLiBJbiBjYXNlLCBzcGVjaWZpZWQgbGlzdGVuZXIgd2FzIGJvdW5kIHNldmVyYWwgdGltZXMsIGl0IHJlbW92ZXNcbiAgICogb25seSBhIHNpbmdsZSBvbmUuXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgb2ZmKHQsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy5saXN0ZW5lcnMuZ2V0KHQpIHx8IFtdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgbi5sZW5ndGg7IHIgKz0gMSlcbiAgICAgIGlmIChzID09PSBuW3JdWzBdKSB7XG4gICAgICAgIG4uc3BsaWNlKHIsIDEpLCB0aGlzLmxpc3RlbmVyc0NvdW50IC09IDE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBldmVudCBsaXN0ZW5lciBmb3IgYWxsIGV2ZW50cy5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gZXZlbnQgbGlzdGVuZXIuXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIHN1YnNjcmliZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlTGlzdGVuZXJzLnB1c2godCksICgpID0+IHRoaXMudW5zdWJzY3JpYmUodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZ2xvYmFsIGV2ZW50IGxpc3RlbmVyLiBJbiBjYXNlLCBzcGVjaWZpZWQgbGlzdGVuZXIgd2FzIGJvdW5kIHNldmVyYWwgdGltZXMsIGl0IHJlbW92ZXNcbiAgICogb25seSBhIHNpbmdsZSBvbmUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgdW5zdWJzY3JpYmUodCkge1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMubGVuZ3RoOyBzICs9IDEpXG4gICAgICBpZiAodGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnNbc10gPT09IHQpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMuc3BsaWNlKHMsIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHR0KGUsIHQsIHMpIHtcbiAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGUsIHQsIHMpLCAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCB0LCBzKTtcbn1cbmZ1bmN0aW9uIG90KC4uLmUpIHtcbiAgbGV0IHQgPSAhMTtcbiAgY29uc3QgcyA9IGUuZmxhdCgxKTtcbiAgcmV0dXJuIFtcbiAgICAobikgPT4gIXQgJiYgcy5wdXNoKG4pLFxuICAgICgpID0+IHtcbiAgICAgIHQgfHwgKHQgPSAhMCwgcy5mb3JFYWNoKChuKSA9PiBuKCkpKTtcbiAgICB9LFxuICAgIHRcbiAgXTtcbn1cbmNsYXNzIFcgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcihzLCB7IGNhdXNlOiBuIH0pLCB0aGlzLnR5cGUgPSB0LCBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVy5wcm90b3R5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBtKGUsIHQsIHMpIHtcbiAgcmV0dXJuIG5ldyBXKGUsIHQsIHMpO1xufVxuY29uc3QgZGUgPSBcIkVSUl9NRVRIT0RfVU5TVVBQT1JURURcIiwgX2UgPSBcIkVSUl9NRVRIT0RfUEFSQU1FVEVSX1VOU1VQUE9SVEVEXCIsIGdlID0gXCJFUlJfVU5LTk9XTl9FTlZcIiwgd2UgPSBcIkVSUl9JTlZPS0VfQ1VTVE9NX01FVEhPRF9SRVNQT05TRVwiLCBmZSA9IFwiRVJSX1RJTUVEX09VVFwiLCBtZSA9IFwiRVJSX1VORVhQRUNURURfVFlQRVwiLCBDdCA9IFwiRVJSX1BBUlNFXCIsIGJlID0gXCJFUlJfTkFWSUdBVElPTl9MSVNUX0VNUFRZXCIsIHZlID0gXCJFUlJfTkFWSUdBVElPTl9DVVJTT1JfSU5WQUxJRFwiLCBfbiA9IFwiRVJSX05BVklHQVRJT05fSVRFTV9JTlZBTElEXCIsIGduID0gXCJFUlJfU1NSX0lOSVRcIiwgeWUgPSBcIkVSUl9JTlZBTElEX1BBVEhfQkFTRVwiO1xuZnVuY3Rpb24gVCgpIHtcbiAgcmV0dXJuIG0obWUsIFwiVmFsdWUgaGFzIHVuZXhwZWN0ZWQgdHlwZVwiKTtcbn1cbmNsYXNzIEcge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgdGhpcy5wYXJzZXIgPSB0LCB0aGlzLmlzT3B0aW9uYWwgPSBzLCB0aGlzLnR5cGUgPSBuO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBwYXJzZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gcGFyc2UuXG4gICAqIEB0aHJvd3Mge1NES0Vycm9yfSBFUlJfUEFSU0VcbiAgICogQHNlZSBFUlJfUEFSU0VcbiAgICovXG4gIHBhcnNlKHQpIHtcbiAgICBpZiAoISh0aGlzLmlzT3B0aW9uYWwgJiYgdCA9PT0gdm9pZCAwKSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlcih0KTtcbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgdGhyb3cgbShcbiAgICAgICAgICBDdCxcbiAgICAgICAgICBgVW5hYmxlIHRvIHBhcnNlIHZhbHVlJHt0aGlzLnR5cGUgPyBgIGFzICR7dGhpcy50eXBlfWAgOiBcIlwifWAsXG4gICAgICAgICAgc1xuICAgICAgICApO1xuICAgICAgfVxuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3B0aW9uYWwgPSAhMCwgdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gQShlLCB0KSB7XG4gIHJldHVybiAoKSA9PiBuZXcgRyhlLCAhMSwgdCk7XG59XG5jb25zdCBFID0gQSgoZSkgPT4ge1xuICBpZiAodHlwZW9mIGUgPT0gXCJib29sZWFuXCIpXG4gICAgcmV0dXJuIGU7XG4gIGNvbnN0IHQgPSBTdHJpbmcoZSk7XG4gIGlmICh0ID09PSBcIjFcIiB8fCB0ID09PSBcInRydWVcIilcbiAgICByZXR1cm4gITA7XG4gIGlmICh0ID09PSBcIjBcIiB8fCB0ID09PSBcImZhbHNlXCIpXG4gICAgcmV0dXJuICExO1xuICB0aHJvdyBUKCk7XG59LCBcImJvb2xlYW5cIik7XG5mdW5jdGlvbiBTdChlLCB0KSB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChjb25zdCBuIGluIGUpIHtcbiAgICBjb25zdCByID0gZVtuXTtcbiAgICBpZiAoIXIpXG4gICAgICBjb250aW51ZTtcbiAgICBsZXQgaSwgbztcbiAgICBpZiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiIHx8IFwicGFyc2VcIiBpbiByKVxuICAgICAgaSA9IG4sIG8gPSB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByIDogci5wYXJzZS5iaW5kKHIpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgeyB0eXBlOiBhIH0gPSByO1xuICAgICAgaSA9IHIuZnJvbSB8fCBuLCBvID0gdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiID8gYSA6IGEucGFyc2UuYmluZChhKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGEgPSBvKHQoaSkpO1xuICAgICAgYSAhPT0gdm9pZCAwICYmIChzW25dID0gYSk7XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgdGhyb3cgbShDdCwgYFVuYWJsZSB0byBwYXJzZSBmaWVsZCBcIiR7bn1cImAsIGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIFR0KGUpIHtcbiAgbGV0IHQgPSBlO1xuICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IEpTT04ucGFyc2UodCkpLCB0eXBlb2YgdCAhPSBcIm9iamVjdFwiIHx8IHQgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBUKCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gdihlLCB0KSB7XG4gIHJldHVybiBuZXcgRygocykgPT4ge1xuICAgIGNvbnN0IG4gPSBUdChzKTtcbiAgICByZXR1cm4gU3QoZSwgKHIpID0+IG5bcl0pO1xuICB9LCAhMSwgdCk7XG59XG5jb25zdCB4ID0gQSgoZSkgPT4ge1xuICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZTtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCB0ID0gTnVtYmVyKGUpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHQpKVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgdGhyb3cgVCgpO1xufSwgXCJudW1iZXJcIiksIHUgPSBBKChlKSA9PiB7XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGUudG9TdHJpbmcoKTtcbiAgdGhyb3cgVCgpO1xufSwgXCJzdHJpbmdcIik7XG5mdW5jdGlvbiBBdChlKSB7XG4gIHJldHVybiB2KHtcbiAgICBldmVudFR5cGU6IHUoKSxcbiAgICBldmVudERhdGE6ICh0KSA9PiB0XG4gIH0pLnBhcnNlKGUpO1xufVxuZnVuY3Rpb24gRWUoKSB7XG4gIFtcIlRlbGVncmFtR2FtZVByb3h5X3JlY2VpdmVFdmVudFwiLCBcIlRlbGVncmFtR2FtZVByb3h5XCIsIFwiVGVsZWdyYW1cIl0uZm9yRWFjaCgoZSkgPT4ge1xuICAgIGRlbGV0ZSB3aW5kb3dbZV07XG4gIH0pO1xufVxuZnVuY3Rpb24gZXQoZSwgdCkge1xuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCB7XG4gICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IGUsIGV2ZW50RGF0YTogdCB9KSxcbiAgICAvLyBXZSBzcGVjaWZ5IHdpbmRvdy5wYXJlbnQgdG8gaW1pdGF0ZSB0aGUgY2FzZSwgdGhlIHBhcmVudCBpZnJhbWUgc2VudCB1cyB0aGlzIGV2ZW50LlxuICAgIHNvdXJjZTogd2luZG93LnBhcmVudFxuICB9KSk7XG59XG5mdW5jdGlvbiBQZSgpIHtcbiAgW1xuICAgIFtcIlRlbGVncmFtR2FtZVByb3h5X3JlY2VpdmVFdmVudFwiXSxcbiAgICAvLyBXaW5kb3dzIFBob25lLlxuICAgIFtcIlRlbGVncmFtR2FtZVByb3h5XCIsIFwicmVjZWl2ZUV2ZW50XCJdLFxuICAgIC8vIERlc2t0b3AuXG4gICAgW1wiVGVsZWdyYW1cIiwgXCJXZWJWaWV3XCIsIFwicmVjZWl2ZUV2ZW50XCJdXG4gICAgLy8gQW5kcm9pZCBhbmQgaU9TLlxuICBdLmZvckVhY2goKGUpID0+IHtcbiAgICBsZXQgdCA9IHdpbmRvdztcbiAgICBlLmZvckVhY2goKHMsIG4sIHIpID0+IHtcbiAgICAgIGlmIChuID09PSByLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdFtzXSA9IGV0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzIGluIHQgfHwgKHRbc10gPSB7fSksIHQgPSB0W3NdO1xuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IFJlID0ge1xuICBjbGlwYm9hcmRfdGV4dF9yZWNlaXZlZDogdih7XG4gICAgcmVxX2lkOiB1KCksXG4gICAgZGF0YTogKGUpID0+IGUgPT09IG51bGwgPyBlIDogdSgpLm9wdGlvbmFsKCkucGFyc2UoZSlcbiAgfSksXG4gIGN1c3RvbV9tZXRob2RfaW52b2tlZDogdih7XG4gICAgcmVxX2lkOiB1KCksXG4gICAgcmVzdWx0OiAoZSkgPT4gZSxcbiAgICBlcnJvcjogdSgpLm9wdGlvbmFsKClcbiAgfSksXG4gIHBvcHVwX2Nsb3NlZDoge1xuICAgIHBhcnNlKGUpIHtcbiAgICAgIHJldHVybiB2KHtcbiAgICAgICAgYnV0dG9uX2lkOiAodCkgPT4gdCA9PSBudWxsID8gdm9pZCAwIDogdSgpLnBhcnNlKHQpXG4gICAgICB9KS5wYXJzZShlID8/IHt9KTtcbiAgICB9XG4gIH0sXG4gIHZpZXdwb3J0X2NoYW5nZWQ6IHYoe1xuICAgIGhlaWdodDogeCgpLFxuICAgIHdpZHRoOiAoZSkgPT4gZSA9PSBudWxsID8gd2luZG93LmlubmVyV2lkdGggOiB4KCkucGFyc2UoZSksXG4gICAgaXNfc3RhdGVfc3RhYmxlOiBFKCksXG4gICAgaXNfZXhwYW5kZWQ6IEUoKVxuICB9KVxufTtcbmZ1bmN0aW9uIHhlKCkge1xuICBjb25zdCBlID0gbmV3IEQoKSwgdCA9IG5ldyBEKCk7XG4gIHQuc3Vic2NyaWJlKChuKSA9PiB7XG4gICAgZS5lbWl0KFwiZXZlbnRcIiwgeyBuYW1lOiBuLmV2ZW50LCBwYXlsb2FkOiBuLmFyZ3NbMF0gfSk7XG4gIH0pLCBQZSgpO1xuICBjb25zdCBbLCBzXSA9IG90KFxuICAgIC8vIERvbid0IGZvcmdldCB0byByZW1vdmUgY3JlYXRlZCBoYW5kbGVycy5cbiAgICBFZSxcbiAgICAvLyBBZGQgXCJyZXNpemVcIiBldmVudCBsaXN0ZW5lciB0byBtYWtlIHN1cmUsIHdlIGFsd2F5cyBoYXZlIGZyZXNoIHZpZXdwb3J0IGluZm9ybWF0aW9uLlxuICAgIC8vIERlc2t0b3AgdmVyc2lvbiBvZiBUZWxlZ3JhbSBpcyBzb21ldGltZXMgbm90IHNlbmRpbmcgdGhlIHZpZXdwb3J0X2NoYW5nZWRcbiAgICAvLyBldmVudC4gRm9yIGV4YW1wbGUsIHdoZW4gdGhlIE1haW5CdXR0b24gaXMgc2hvd24uIFRoYXQncyB3aHkgd2Ugc2hvdWxkXG4gICAgLy8gYWRkIG91ciBvd24gbGlzdGVuZXIgdG8gbWFrZSBzdXJlLCB2aWV3cG9ydCBpbmZvcm1hdGlvbiBpcyBhbHdheXMgZnJlc2guXG4gICAgLy8gSXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvdG1hLmpzL2lzc3Vlcy8xMFxuICAgIHR0KFwicmVzaXplXCIsICgpID0+IHtcbiAgICAgIHQuZW1pdChcInZpZXdwb3J0X2NoYW5nZWRcIiwge1xuICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICBpc19zdGF0ZV9zdGFibGU6ICEwLFxuICAgICAgICBpc19leHBhbmRlZDogITBcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIC8vIEFkZCBsaXN0ZW5lciwgd2hpY2ggaGFuZGxlcyBldmVudHMgc2VudCBmcm9tIHRoZSBUZWxlZ3JhbSB3ZWIgYXBwbGljYXRpb24gYW5kIGFsc28gZXZlbnRzXG4gICAgLy8gZ2VuZXJhdGVkIGJ5IHRoZSBsb2NhbCBlbWl0RXZlbnQgZnVuY3Rpb24uXG4gICAgdHQoXCJtZXNzYWdlXCIsIChuKSA9PiB7XG4gICAgICBpZiAobi5zb3VyY2UgIT09IHdpbmRvdy5wYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCByO1xuICAgICAgdHJ5IHtcbiAgICAgICAgciA9IEF0KG4uZGF0YSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBldmVudFR5cGU6IGksIGV2ZW50RGF0YTogbyB9ID0gciwgYSA9IFJlW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaCA9IGEgPyBhLnBhcnNlKG8pIDogbztcbiAgICAgICAgdC5lbWl0KC4uLmggPyBbaSwgaF0gOiBbaV0pO1xuICAgICAgfSBjYXRjaCAoaCkge1xuICAgICAgICBpdC5lcnJvcihcbiAgICAgICAgICBgQW4gZXJyb3Igb2NjdXJyZWQgcHJvY2Vzc2luZyB0aGUgXCIke2l9XCIgZXZlbnQgZnJvbSB0aGUgVGVsZWdyYW0gYXBwbGljYXRpb24uXG5QbGVhc2UsIGZpbGUgYW4gaXNzdWUgaGVyZTpcbmh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvdG1hLmpzL2lzc3Vlcy9uZXcvY2hvb3NlYCxcbiAgICAgICAgICByLFxuICAgICAgICAgIGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICAvLyBDbGVhciBlbWl0dGVycy5cbiAgICAoKSA9PiBlLmNsZWFyKCksXG4gICAgKCkgPT4gdC5jbGVhcigpXG4gICk7XG4gIHJldHVybiBbe1xuICAgIG9uOiB0Lm9uLmJpbmQodCksXG4gICAgb2ZmOiB0Lm9mZi5iaW5kKHQpLFxuICAgIHN1YnNjcmliZShuKSB7XG4gICAgICByZXR1cm4gZS5vbihcImV2ZW50XCIsIG4pO1xuICAgIH0sXG4gICAgdW5zdWJzY3JpYmUobikge1xuICAgICAgZS5vZmYoXCJldmVudFwiLCBuKTtcbiAgICB9LFxuICAgIGdldCBjb3VudCgpIHtcbiAgICAgIHJldHVybiB0LmNvdW50ICsgZS5jb3VudDtcbiAgICB9XG4gIH0sIHNdO1xufVxuY29uc3QgW0NlLCBTZV0gPSBSdChcbiAgKGUpID0+IHtcbiAgICBjb25zdCBbdCwgc10gPSB4ZSgpLCBuID0gdC5vZmYuYmluZCh0KTtcbiAgICByZXR1cm4gdC5vZmYgPSAociwgaSkgPT4ge1xuICAgICAgY29uc3QgeyBjb3VudDogbyB9ID0gdDtcbiAgICAgIG4ociwgaSksIG8gJiYgIXQuY291bnQgJiYgZSgpO1xuICAgIH0sIFt0LCBzXTtcbiAgfSxcbiAgKFssIGVdKSA9PiBlKClcbik7XG5mdW5jdGlvbiBqKCkge1xuICByZXR1cm4gQ2UoKVswXTtcbn1cbmZ1bmN0aW9uIHooZSwgdCkge1xuICBqKCkub2ZmKGUsIHQpO1xufVxuZnVuY3Rpb24geShlLCB0LCBzKSB7XG4gIHJldHVybiBqKCkub24oZSwgdCwgcyk7XG59XG5mdW5jdGlvbiBMKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShlKTtcbn1cbmZ1bmN0aW9uIFRlKGUsIHQpIHtcbiAgY29uc3QgcyA9IGUuc3BsaXQoXCIuXCIpLCBuID0gdC5zcGxpdChcIi5cIiksIHIgPSBNYXRoLm1heChzLmxlbmd0aCwgbi5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHI7IGkgKz0gMSkge1xuICAgIGNvbnN0IG8gPSBwYXJzZUludChzW2ldIHx8IFwiMFwiLCAxMCksIGEgPSBwYXJzZUludChuW2ldIHx8IFwiMFwiLCAxMCk7XG4gICAgaWYgKG8gIT09IGEpXG4gICAgICByZXR1cm4gbyA+IGEgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBmKGUsIHQpIHtcbiAgcmV0dXJuIFRlKGUsIHQpIDw9IDA7XG59XG5mdW5jdGlvbiBDKGUsIHQsIHMpIHtcbiAgaWYgKHR5cGVvZiBzID09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoZSA9PT0gXCJ3ZWJfYXBwX29wZW5fbGlua1wiKSB7XG4gICAgICBpZiAodCA9PT0gXCJ0cnlfaW5zdGFudF92aWV3XCIpXG4gICAgICAgIHJldHVybiBmKFwiNi40XCIsIHMpO1xuICAgICAgaWYgKHQgPT09IFwidHJ5X2Jyb3dzZXJcIilcbiAgICAgICAgcmV0dXJuIGYoXCI3LjZcIiwgcyk7XG4gICAgfVxuICAgIGlmIChlID09PSBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiICYmIHQgPT09IFwiY29sb3JcIilcbiAgICAgIHJldHVybiBmKFwiNi45XCIsIHMpO1xuICAgIGlmIChlID09PSBcIndlYl9hcHBfY2xvc2VcIiAmJiB0ID09PSBcInJldHVybl9iYWNrXCIpXG4gICAgICByZXR1cm4gZihcIjcuNlwiLCBzKTtcbiAgfVxuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX3RnX2xpbmtcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX2ludm9pY2VcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9zZXR1cF9iYWNrX2J1dHRvblwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3NldF9iYWNrZ3JvdW5kX2NvbG9yXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCI6XG4gICAgICByZXR1cm4gZihcIjYuMVwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX3BvcHVwXCI6XG4gICAgICByZXR1cm4gZihcIjYuMlwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9jbG9zZV9zY2FuX3FyX3BvcHVwXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfb3Blbl9zY2FuX3FyX3BvcHVwXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfcmVhZF90ZXh0X2Zyb21fY2xpcGJvYXJkXCI6XG4gICAgICByZXR1cm4gZihcIjYuNFwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9zd2l0Y2hfaW5saW5lX3F1ZXJ5XCI6XG4gICAgICByZXR1cm4gZihcIjYuN1wiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9pbnZva2VfY3VzdG9tX21ldGhvZFwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3JlcXVlc3Rfd3JpdGVfYWNjZXNzXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfcmVxdWVzdF9waG9uZVwiOlxuICAgICAgcmV0dXJuIGYoXCI2LjlcIiwgdCk7XG4gICAgY2FzZSBcIndlYl9hcHBfc2V0dXBfc2V0dGluZ3NfYnV0dG9uXCI6XG4gICAgICByZXR1cm4gZihcIjYuMTBcIiwgdCk7XG4gICAgY2FzZSBcIndlYl9hcHBfYmlvbWV0cnlfZ2V0X2luZm9cIjpcbiAgICBjYXNlIFwid2ViX2FwcF9iaW9tZXRyeV9vcGVuX3NldHRpbmdzXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfYmlvbWV0cnlfcmVxdWVzdF9hY2Nlc3NcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2F1dGhcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9iaW9tZXRyeV91cGRhdGVfdG9rZW5cIjpcbiAgICAgIHJldHVybiBmKFwiNy4yXCIsIHQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW1xuICAgICAgICBcImlmcmFtZV9yZWFkeVwiLFxuICAgICAgICBcImlmcmFtZV93aWxsX3JlbG9hZFwiLFxuICAgICAgICBcIndlYl9hcHBfY2xvc2VcIixcbiAgICAgICAgXCJ3ZWJfYXBwX2RhdGFfc2VuZFwiLFxuICAgICAgICBcIndlYl9hcHBfZXhwYW5kXCIsXG4gICAgICAgIFwid2ViX2FwcF9vcGVuX2xpbmtcIixcbiAgICAgICAgXCJ3ZWJfYXBwX3JlYWR5XCIsXG4gICAgICAgIFwid2ViX2FwcF9yZXF1ZXN0X3RoZW1lXCIsXG4gICAgICAgIFwid2ViX2FwcF9yZXF1ZXN0X3ZpZXdwb3J0XCIsXG4gICAgICAgIFwid2ViX2FwcF9zZXR1cF9tYWluX2J1dHRvblwiLFxuICAgICAgICBcIndlYl9hcHBfc2V0dXBfY2xvc2luZ19iZWhhdmlvclwiXG4gICAgICBdLmluY2x1ZGVzKGUpO1xuICB9XG59XG5mdW5jdGlvbiBJdChlKSB7XG4gIHJldHVybiBcImV4dGVybmFsXCIgaW4gZSAmJiBMKGUuZXh0ZXJuYWwpICYmIFwibm90aWZ5XCIgaW4gZS5leHRlcm5hbCAmJiB0eXBlb2YgZS5leHRlcm5hbC5ub3RpZnkgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24ga3QoZSkge1xuICByZXR1cm4gXCJUZWxlZ3JhbVdlYnZpZXdQcm94eVwiIGluIGUgJiYgTChlLlRlbGVncmFtV2Vidmlld1Byb3h5KSAmJiBcInBvc3RFdmVudFwiIGluIGUuVGVsZWdyYW1XZWJ2aWV3UHJveHkgJiYgdHlwZW9mIGUuVGVsZWdyYW1XZWJ2aWV3UHJveHkucG9zdEV2ZW50ID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGF0KCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5jb25zdCBBZSA9IFwiaHR0cHM6Ly93ZWIudGVsZWdyYW0ub3JnXCI7XG5sZXQgT3QgPSBBZTtcbmZ1bmN0aW9uIHduKGUpIHtcbiAgT3QgPSBlO1xufVxuZnVuY3Rpb24gSWUoKSB7XG4gIHJldHVybiBPdDtcbn1cbmZ1bmN0aW9uIFYoZSwgdCwgcykge1xuICBsZXQgbiA9IHt9LCByO1xuICBpZiAoIXQgJiYgIXMgPyBuID0ge30gOiB0ICYmIHMgPyAobiA9IHMsIHIgPSB0KSA6IHQgJiYgKFwidGFyZ2V0T3JpZ2luXCIgaW4gdCA/IG4gPSB0IDogciA9IHQpLCBsZShcIlBvc3RpbmcgZXZlbnQ6XCIsIHIgPyB7IGV2ZW50OiBlLCBkYXRhOiByIH0gOiB7IGV2ZW50OiBlIH0pLCBhdCgpKVxuICAgIHJldHVybiB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IGUsIGV2ZW50RGF0YTogciB9KSxcbiAgICAgIG4udGFyZ2V0T3JpZ2luIHx8IEllKClcbiAgICApO1xuICBpZiAoSXQod2luZG93KSkge1xuICAgIHdpbmRvdy5leHRlcm5hbC5ub3RpZnkoSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IGUsIGV2ZW50RGF0YTogciB9KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChrdCh3aW5kb3cpKSB7XG4gICAgd2luZG93LlRlbGVncmFtV2Vidmlld1Byb3h5LnBvc3RFdmVudChlLCBKU09OLnN0cmluZ2lmeShyKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG0oXG4gICAgZ2UsXG4gICAgXCJVbmFibGUgdG8gZGV0ZXJtaW5lIGN1cnJlbnQgZW52aXJvbm1lbnQgYW5kIHBvc3NpYmxlIHdheSB0byBzZW5kIGV2ZW50LiBZb3UgYXJlIHByb2JhYmx5IHRyeWluZyB0byB1c2UgTWluaSBBcHBzIG1ldGhvZCBvdXRzaWRlIHRoZSBUZWxlZ3JhbSBhcHBsaWNhdGlvbiBlbnZpcm9ubWVudC5cIlxuICApO1xufVxuZnVuY3Rpb24ga2UoZSkge1xuICByZXR1cm4gKHQsIHMpID0+IHtcbiAgICBpZiAoIUModCwgZSkpXG4gICAgICB0aHJvdyBtKGRlLCBgTWV0aG9kIFwiJHt0fVwiIGlzIHVuc3VwcG9ydGVkIGluIE1pbmkgQXBwcyB2ZXJzaW9uICR7ZX1gKTtcbiAgICBpZiAoTChzKSAmJiB0ID09PSBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiICYmIFwiY29sb3JcIiBpbiBzICYmICFDKHQsIFwiY29sb3JcIiwgZSkpXG4gICAgICB0aHJvdyBtKFxuICAgICAgICBfZSxcbiAgICAgICAgYFBhcmFtZXRlciBcImNvbG9yXCIgb2YgXCIke3R9XCIgbWV0aG9kIGlzIHVuc3VwcG9ydGVkIGluIE1pbmkgQXBwcyB2ZXJzaW9uICR7ZX1gXG4gICAgICApO1xuICAgIHJldHVybiBWKHQsIHMpO1xuICB9O1xufVxuZnVuY3Rpb24gcXQoZSkge1xuICByZXR1cm4gKHsgcmVxX2lkOiB0IH0pID0+IHQgPT09IGU7XG59XG5mdW5jdGlvbiBOdChlKSB7XG4gIHJldHVybiBtKGZlLCBgVGltZW91dCByZWFjaGVkOiAke2V9bXNgKTtcbn1cbmZ1bmN0aW9uIER0KGUsIHQpIHtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSgpIDogZSxcbiAgICBuZXcgUHJvbWlzZSgocywgbikgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4oTnQodCkpO1xuICAgICAgfSwgdCk7XG4gICAgfSlcbiAgXSk7XG59XG5hc3luYyBmdW5jdGlvbiBnKGUpIHtcbiAgbGV0IHQ7XG4gIGNvbnN0IHMgPSBuZXcgUHJvbWlzZSgoYSkgPT4gdCA9IGEpLCB7IGV2ZW50OiBuLCBjYXB0dXJlOiByLCB0aW1lb3V0OiBpIH0gPSBlLCBbLCBvXSA9IG90KFxuICAgIC8vIFdlIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIGFsbCB0cmFja2VkIGV2ZW50cywgYW5kIGNyZWF0ZSB0aGVpciBldmVudCBsaXN0ZW5lcnMuXG4gICAgKEFycmF5LmlzQXJyYXkobikgPyBuIDogW25dKS5tYXAoKGEpID0+IHkoYSwgKGgpID0+IHtcbiAgICAgICghciB8fCAoQXJyYXkuaXNBcnJheShuKSA/IHIoe1xuICAgICAgICBldmVudDogYSxcbiAgICAgICAgcGF5bG9hZDogaFxuICAgICAgfSkgOiByKGgpKSkgJiYgdChoKTtcbiAgICB9KSlcbiAgKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKGUucG9zdEV2ZW50IHx8IFYpKGUubWV0aG9kLCBlLnBhcmFtcyksIGF3YWl0IChpID8gRHQocywgaSkgOiBzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBvKCk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHEoZSwgdCwgcywgbiA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICByZXN1bHQ6IHIsXG4gICAgZXJyb3I6IGlcbiAgfSA9IGF3YWl0IGcoe1xuICAgIC4uLm4sXG4gICAgbWV0aG9kOiBcIndlYl9hcHBfaW52b2tlX2N1c3RvbV9tZXRob2RcIixcbiAgICBldmVudDogXCJjdXN0b21fbWV0aG9kX2ludm9rZWRcIixcbiAgICBwYXJhbXM6IHtcbiAgICAgIG1ldGhvZDogZSxcbiAgICAgIHBhcmFtczogdCxcbiAgICAgIHJlcV9pZDogc1xuICAgIH0sXG4gICAgY2FwdHVyZTogcXQocylcbiAgfSk7XG4gIGlmIChpKVxuICAgIHRocm93IG0od2UsIGkpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHN0KC4uLmUpIHtcbiAgcmV0dXJuIGUubWFwKCh0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdDtcbiAgICBpZiAoTCh0KSlcbiAgICAgIHJldHVybiBzdChPYmplY3QuZW50cmllcyh0KS5tYXAoKHMpID0+IHNbMV0gJiYgc1swXSkpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHQpKVxuICAgICAgcmV0dXJuIHN0KC4uLnQpO1xuICB9KS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiBmbiguLi5lKSB7XG4gIHJldHVybiBlLnJlZHVjZSgodCwgcykgPT4gKEwocykgJiYgT2JqZWN0LmVudHJpZXMocykuZm9yRWFjaCgoW24sIHJdKSA9PiB7XG4gICAgY29uc3QgaSA9IHN0KHRbbl0sIHIpO1xuICAgIGkubGVuZ3RoICYmICh0W25dID0gaSk7XG4gIH0pLCB0KSwge30pO1xufVxuZnVuY3Rpb24gY3QoZSkge1xuICByZXR1cm4gL14jW1xcZGEtZl17Nn0kL2kudGVzdChlKTtcbn1cbmZ1bmN0aW9uIE9lKGUpIHtcbiAgcmV0dXJuIC9eI1tcXGRhLWZdezN9JC9pLnRlc3QoZSk7XG59XG5mdW5jdGlvbiBWdChlKSB7XG4gIGNvbnN0IHQgPSBlLnJlcGxhY2UoL1xccy9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoY3QodCkpXG4gICAgcmV0dXJuIHQ7XG4gIGlmIChPZSh0KSkge1xuICAgIGxldCBuID0gXCIjXCI7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCAzOyByICs9IDEpXG4gICAgICBuICs9IHRbMSArIHJdLnJlcGVhdCgyKTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBjb25zdCBzID0gdC5tYXRjaCgvXnJnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpJC8pIHx8IHQubWF0Y2goL15yZ2JhXFwoKFxcZHsxLDN9KSwoXFxkezEsM30pLChcXGR7MSwzfSksXFxkezEsM31cXCkkLyk7XG4gIGlmICghcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIFwiJHtlfVwiIGRvZXMgbm90IHNhdGlzZnkgYW55IG9mIGtub3duIFJHQiBmb3JtYXRzLmApO1xuICByZXR1cm4gcy5zbGljZSgxKS5yZWR1Y2UoKG4sIHIpID0+IHtcbiAgICBjb25zdCBpID0gcGFyc2VJbnQociwgMTApLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gbiArIChpLmxlbmd0aCA9PT0gMSA/IFwiMFwiIDogXCJcIikgKyBpO1xuICB9LCBcIiNcIik7XG59XG5mdW5jdGlvbiBCdChlKSB7XG4gIGNvbnN0IHQgPSBWdChlKTtcbiAgcmV0dXJuIE1hdGguc3FydChcbiAgICBbMC4yOTksIDAuNTg3LCAwLjExNF0ucmVkdWNlKChzLCBuLCByKSA9PiB7XG4gICAgICBjb25zdCBpID0gcGFyc2VJbnQodC5zbGljZSgxICsgciAqIDIsIDEgKyAociArIDEpICogMiksIDE2KTtcbiAgICAgIHJldHVybiBzICsgaSAqIGkgKiBuO1xuICAgIH0sIDApXG4gICkgPCAxMjA7XG59XG5jbGFzcyBxZSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBjKHRoaXMsIFwiZWVcIiwgbmV3IEQoKSksIGModGhpcywgXCJvblwiLCB0aGlzLmVlLm9uLmJpbmQodGhpcy5lZSkpLCBjKHRoaXMsIFwib2ZmXCIsIHRoaXMuZWUub2ZmLmJpbmQodGhpcy5lZSkpLCB0aGlzLnN0YXRlID0gdDtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIGN1cnJlbnQgc3RhdGUgYW5kIHJldHVybnMgaXRzIGNvcHkuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLnN0YXRlIH07XG4gIH1cbiAgc2V0KHQsIHMpIHtcbiAgICBPYmplY3QuZW50cmllcyh0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8geyBbdF06IHMgfSA6IHQpLnJlZHVjZSgobiwgW3IsIGldKSA9PiB0aGlzLnN0YXRlW3JdID09PSBpIHx8IGkgPT09IHZvaWQgMCA/IG4gOiAodGhpcy5zdGF0ZVtyXSA9IGksIHRoaXMuZWUuZW1pdChgY2hhbmdlOiR7cn1gLCBpKSwgITApLCAhMSkgJiYgdGhpcy5lZS5lbWl0KFwiY2hhbmdlXCIsIHRoaXMuc3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHZhbHVlIGJ5IHNwZWNpZmllZCBrZXkuXG4gICAqIEBwYXJhbSBrZXkgLSBzdGF0ZSBrZXkuXG4gICAqL1xuICBnZXQodCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlW3RdO1xuICB9XG59XG5jbGFzcyBodCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBjKHRoaXMsIFwic3RhdGVcIiksIGModGhpcywgXCJnZXRcIiksIGModGhpcywgXCJzZXRcIiksIGModGhpcywgXCJjbG9uZVwiKSwgdGhpcy5zdGF0ZSA9IG5ldyBxZSh0KSwgdGhpcy5zZXQgPSB0aGlzLnN0YXRlLnNldC5iaW5kKHRoaXMuc3RhdGUpLCB0aGlzLmdldCA9IHRoaXMuc3RhdGUuZ2V0LmJpbmQodGhpcy5zdGF0ZSksIHRoaXMuY2xvbmUgPSB0aGlzLnN0YXRlLmNsb25lLmJpbmQodGhpcy5zdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIE10KGUsIHQpIHtcbiAgcmV0dXJuIChzKSA9PiBDKHRbc10sIGUpO1xufVxuY2xhc3MgcHQgZXh0ZW5kcyBodCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih0KSwgYyh0aGlzLCBcInN1cHBvcnRzXCIpLCB0aGlzLnN1cHBvcnRzID0gTXQocywgbik7XG4gIH1cbn1cbmNsYXNzIE5lIGV4dGVuZHMgcHQge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgc3VwZXIoeyBpc1Zpc2libGU6IHQgfSwgcywge1xuICAgICAgc2hvdzogXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCIsXG4gICAgICBoaWRlOiBcIndlYl9hcHBfc2V0dXBfYmFja19idXR0b25cIlxuICAgIH0pLCBjKHRoaXMsIFwib25cIiwgKHIsIGkpID0+IHIgPT09IFwiY2xpY2tcIiA/IHkoXCJiYWNrX2J1dHRvbl9wcmVzc2VkXCIsIGkpIDogdGhpcy5zdGF0ZS5vbihyLCBpKSksIGModGhpcywgXCJvZmZcIiwgKHIsIGkpID0+IHIgPT09IFwiY2xpY2tcIiA/IHooXCJiYWNrX2J1dHRvbl9wcmVzc2VkXCIsIGkpIDogdGhpcy5zdGF0ZS5vZmYociwgaSkpLCB0aGlzLnBvc3RFdmVudCA9IG47XG4gIH1cbiAgc2V0IGlzVmlzaWJsZSh0KSB7XG4gICAgdGhpcy5zZXQoXCJpc1Zpc2libGVcIiwgdCksIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXR1cF9iYWNrX2J1dHRvblwiLCB7IGlzX3Zpc2libGU6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgQmFja0J1dHRvbiBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICovXG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaXNWaXNpYmxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgQmFja0J1dHRvbi5cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5pc1Zpc2libGUgPSAhMTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgdGhlIEJhY2tCdXR0b24uXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMuaXNWaXNpYmxlID0gITA7XG4gIH1cbn1cbmNvbnN0IEx0ID0gQSgoZSkgPT4gZSBpbnN0YW5jZW9mIERhdGUgPyBlIDogbmV3IERhdGUoeCgpLnBhcnNlKGUpICogMWUzKSwgXCJEYXRlXCIpO1xuZnVuY3Rpb24gdXQoZSwgdCkge1xuICByZXR1cm4gbmV3IEcoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT0gXCJzdHJpbmdcIiAmJiAhKHMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpKVxuICAgICAgdGhyb3cgVCgpO1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gbmV3IFVSTFNlYXJjaFBhcmFtcyhzKSA6IHM7XG4gICAgcmV0dXJuIFN0KGUsIChyKSA9PiB7XG4gICAgICBjb25zdCBpID0gbi5nZXQocik7XG4gICAgICByZXR1cm4gaSA9PT0gbnVsbCA/IHZvaWQgMCA6IGk7XG4gICAgfSk7XG4gIH0sICExLCB0KTtcbn1cbmNvbnN0IERlID0gdih7XG4gIGlkOiB4KCksXG4gIHR5cGU6IHUoKSxcbiAgdGl0bGU6IHUoKSxcbiAgcGhvdG9Vcmw6IHtcbiAgICB0eXBlOiB1KCkub3B0aW9uYWwoKSxcbiAgICBmcm9tOiBcInBob3RvX3VybFwiXG4gIH0sXG4gIHVzZXJuYW1lOiB1KCkub3B0aW9uYWwoKVxufSwgXCJDaGF0XCIpLm9wdGlvbmFsKCksIHZ0ID0gdih7XG4gIGFkZGVkVG9BdHRhY2htZW50TWVudToge1xuICAgIHR5cGU6IEUoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwiYWRkZWRfdG9fYXR0YWNobWVudF9tZW51XCJcbiAgfSxcbiAgYWxsb3dzV3JpdGVUb1BtOiB7XG4gICAgdHlwZTogRSgpLm9wdGlvbmFsKCksXG4gICAgZnJvbTogXCJhbGxvd3Nfd3JpdGVfdG9fcG1cIlxuICB9LFxuICBmaXJzdE5hbWU6IHtcbiAgICB0eXBlOiB1KCksXG4gICAgZnJvbTogXCJmaXJzdF9uYW1lXCJcbiAgfSxcbiAgaWQ6IHgoKSxcbiAgaXNCb3Q6IHtcbiAgICB0eXBlOiBFKCkub3B0aW9uYWwoKSxcbiAgICBmcm9tOiBcImlzX2JvdFwiXG4gIH0sXG4gIGlzUHJlbWl1bToge1xuICAgIHR5cGU6IEUoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwiaXNfcHJlbWl1bVwiXG4gIH0sXG4gIGxhbmd1YWdlQ29kZToge1xuICAgIHR5cGU6IHUoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwibGFuZ3VhZ2VfY29kZVwiXG4gIH0sXG4gIGxhc3ROYW1lOiB7XG4gICAgdHlwZTogdSgpLm9wdGlvbmFsKCksXG4gICAgZnJvbTogXCJsYXN0X25hbWVcIlxuICB9LFxuICBwaG90b1VybDoge1xuICAgIHR5cGU6IHUoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwicGhvdG9fdXJsXCJcbiAgfSxcbiAgdXNlcm5hbWU6IHUoKS5vcHRpb25hbCgpXG59LCBcIlVzZXJcIikub3B0aW9uYWwoKTtcbmZ1bmN0aW9uICR0KCkge1xuICByZXR1cm4gdXQoe1xuICAgIGF1dGhEYXRlOiB7XG4gICAgICB0eXBlOiBMdCgpLFxuICAgICAgZnJvbTogXCJhdXRoX2RhdGVcIlxuICAgIH0sXG4gICAgY2FuU2VuZEFmdGVyOiB7XG4gICAgICB0eXBlOiB4KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwiY2FuX3NlbmRfYWZ0ZXJcIlxuICAgIH0sXG4gICAgY2hhdDogRGUsXG4gICAgY2hhdEluc3RhbmNlOiB7XG4gICAgICB0eXBlOiB1KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwiY2hhdF9pbnN0YW5jZVwiXG4gICAgfSxcbiAgICBjaGF0VHlwZToge1xuICAgICAgdHlwZTogdSgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcImNoYXRfdHlwZVwiXG4gICAgfSxcbiAgICBoYXNoOiB1KCksXG4gICAgcXVlcnlJZDoge1xuICAgICAgdHlwZTogdSgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInF1ZXJ5X2lkXCJcbiAgICB9LFxuICAgIHJlY2VpdmVyOiB2dCxcbiAgICBzdGFydFBhcmFtOiB7XG4gICAgICB0eXBlOiB1KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwic3RhcnRfcGFyYW1cIlxuICAgIH0sXG4gICAgdXNlcjogdnRcbiAgfSwgXCJJbml0RGF0YVwiKTtcbn1cbmNvbnN0IFZlID0gQSgoZSkgPT4gVnQodSgpLnBhcnNlKGUpKSwgXCJyZ2JcIik7XG5mdW5jdGlvbiBCZShlKSB7XG4gIHJldHVybiBlLnJlcGxhY2UoL19bYS16XS9nLCAodCkgPT4gdFsxXS50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIE1lKGUpIHtcbiAgcmV0dXJuIGUucmVwbGFjZSgvW0EtWl0vZywgKHQpID0+IGBfJHt0LnRvTG93ZXJDYXNlKCl9YCk7XG59XG5jb25zdCBIdCA9IEEoXG4gIChlKSA9PiB7XG4gICAgY29uc3QgdCA9IFZlKCkub3B0aW9uYWwoKTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoVHQoZSkpLnJlZHVjZSgocywgW24sIHJdKSA9PiAoc1tCZShuKV0gPSB0LnBhcnNlKHIpLCBzKSwge30pO1xuICB9LFxuICBcIlRoZW1lUGFyYW1zXCJcbik7XG5mdW5jdGlvbiBsdChlKSB7XG4gIHJldHVybiB1dCh7XG4gICAgYm90SW5saW5lOiB7XG4gICAgICB0eXBlOiBFKCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBCb3RJbmxpbmVcIlxuICAgIH0sXG4gICAgaW5pdERhdGE6IHtcbiAgICAgIHR5cGU6ICR0KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBEYXRhXCJcbiAgICB9LFxuICAgIGluaXREYXRhUmF3OiB7XG4gICAgICB0eXBlOiB1KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBEYXRhXCJcbiAgICB9LFxuICAgIHBsYXRmb3JtOiB7XG4gICAgICB0eXBlOiB1KCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwUGxhdGZvcm1cIlxuICAgIH0sXG4gICAgc2hvd1NldHRpbmdzOiB7XG4gICAgICB0eXBlOiBFKCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBTaG93U2V0dGluZ3NcIlxuICAgIH0sXG4gICAgc3RhcnRQYXJhbToge1xuICAgICAgdHlwZTogdSgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwU3RhcnRQYXJhbVwiXG4gICAgfSxcbiAgICB0aGVtZVBhcmFtczoge1xuICAgICAgdHlwZTogSHQoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBUaGVtZVBhcmFtc1wiXG4gICAgfSxcbiAgICB2ZXJzaW9uOiB7XG4gICAgICB0eXBlOiB1KCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwVmVyc2lvblwiXG4gICAgfVxuICB9KS5wYXJzZShlKTtcbn1cbmZ1bmN0aW9uIFV0KGUpIHtcbiAgcmV0dXJuIGx0KFxuICAgIGUucmVwbGFjZSgvXltePyNdKls/I10vLCBcIlwiKS5yZXBsYWNlKC9bPyNdL2csIFwiJlwiKVxuICApO1xufVxuZnVuY3Rpb24gTGUoKSB7XG4gIHJldHVybiBVdCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG59XG5mdW5jdGlvbiBXdCgpIHtcbiAgcmV0dXJuIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoXCJuYXZpZ2F0aW9uXCIpWzBdO1xufVxuZnVuY3Rpb24gJGUoKSB7XG4gIGNvbnN0IGUgPSBXdCgpO1xuICBpZiAoIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdldCBmaXJzdCBuYXZpZ2F0aW9uIGVudHJ5LlwiKTtcbiAgcmV0dXJuIFV0KGUubmFtZSk7XG59XG5mdW5jdGlvbiBHdChlKSB7XG4gIHJldHVybiBgdG1hLmpzLyR7ZS5yZXBsYWNlKC9bQS1aXS9nLCAodCkgPT4gYC0ke3QudG9Mb3dlckNhc2UoKX1gKX1gO1xufVxuZnVuY3Rpb24ganQoZSwgdCkge1xuICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKEd0KGUpLCBKU09OLnN0cmluZ2lmeSh0KSk7XG59XG5mdW5jdGlvbiB6dChlKSB7XG4gIGNvbnN0IHQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKEd0KGUpKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdCA/IEpTT04ucGFyc2UodCkgOiB2b2lkIDA7XG4gIH0gY2F0Y2gge1xuICB9XG59XG5mdW5jdGlvbiBIZSgpIHtcbiAgcmV0dXJuIGx0KHp0KFwibGF1bmNoUGFyYW1zXCIpIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gS3QoZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMoZSkubWFwKChbdCwgc10pID0+IFtNZSh0KSwgc10pXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gVWUoZSkge1xuICBjb25zdCB7XG4gICAgaW5pdERhdGFSYXc6IHQsXG4gICAgdGhlbWVQYXJhbXM6IHMsXG4gICAgcGxhdGZvcm06IG4sXG4gICAgdmVyc2lvbjogcixcbiAgICBzaG93U2V0dGluZ3M6IGksXG4gICAgc3RhcnRQYXJhbTogbyxcbiAgICBib3RJbmxpbmU6IGFcbiAgfSA9IGUsIGggPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIHJldHVybiBoLnNldChcInRnV2ViQXBwUGxhdGZvcm1cIiwgbiksIGguc2V0KFwidGdXZWJBcHBUaGVtZVBhcmFtc1wiLCBLdChzKSksIGguc2V0KFwidGdXZWJBcHBWZXJzaW9uXCIsIHIpLCB0ICYmIGguc2V0KFwidGdXZWJBcHBEYXRhXCIsIHQpLCBvICYmIGguc2V0KFwidGdXZWJBcHBTdGFydFBhcmFtXCIsIG8pLCB0eXBlb2YgaSA9PSBcImJvb2xlYW5cIiAmJiBoLnNldChcInRnV2ViQXBwU2hvd1NldHRpbmdzXCIsIGkgPyBcIjFcIiA6IFwiMFwiKSwgdHlwZW9mIGEgPT0gXCJib29sZWFuXCIgJiYgaC5zZXQoXCJ0Z1dlYkFwcEJvdElubGluZVwiLCBhID8gXCIxXCIgOiBcIjBcIiksIGgudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIEp0KGUpIHtcbiAganQoXCJsYXVuY2hQYXJhbXNcIiwgVWUoZSkpO1xufVxuZnVuY3Rpb24gbnQoKSB7XG4gIGZvciAoY29uc3QgZSBvZiBbXG4gICAgLy8gVHJ5IHRvIHJldHJpZXZlIGxhdW5jaCBwYXJhbWV0ZXJzIGZyb20gdGhlIGN1cnJlbnQgbG9jYXRpb24uIFRoaXMgbWV0aG9kIGNhbiByZXR1cm5cbiAgICAvLyBub3RoaW5nIGluIGNhc2UsIGxvY2F0aW9uIHdhcyBjaGFuZ2VkIGFuZCB0aGVuIHBhZ2Ugd2FzIHJlbG9hZGVkLlxuICAgIExlLFxuICAgIC8vIFRoZW4sIHRyeSB1c2luZyB0aGUgbG93ZXIgbGV2ZWwgQVBJIC0gd2luZG93LnBlcmZvcm1hbmNlLlxuICAgICRlLFxuICAgIC8vIEZpbmFsbHksIHRyeSB0byBleHRyYWN0IGxhdW5jaCBwYXJhbWV0ZXJzIGZyb20gdGhlIHNlc3Npb24gc3RvcmFnZS5cbiAgICBIZVxuICBdKVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ID0gZSgpO1xuICAgICAgcmV0dXJuIEp0KHQpLCB0O1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJldHJpZXZlIGxhdW5jaCBwYXJhbWV0ZXJzIGZyb20gYW55IGtub3duIHNvdXJjZS5cIik7XG59XG5mdW5jdGlvbiBGdCgpIHtcbiAgY29uc3QgZSA9IFd0KCk7XG4gIHJldHVybiAhIShlICYmIGUudHlwZSA9PT0gXCJyZWxvYWRcIik7XG59XG5mdW5jdGlvbiBXZSgpIHtcbiAgbGV0IGUgPSAwO1xuICByZXR1cm4gKCkgPT4gKGUgKz0gMSkudG9TdHJpbmcoKTtcbn1cbmNvbnN0IFtHZV0gPSBSdChXZSk7XG5mdW5jdGlvbiBsKGUsIHQpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBzID0gbnQoKSwgbiA9IHtcbiAgICAgIC4uLnMsXG4gICAgICBwb3N0RXZlbnQ6IGtlKHMudmVyc2lvbiksXG4gICAgICBjcmVhdGVSZXF1ZXN0SWQ6IEdlKClcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gZShuKTtcbiAgICBjb25zdCBbciwgaSwgb10gPSBvdCgpLCBhID0gdCh7XG4gICAgICAuLi5uLFxuICAgICAgLy8gU3RhdGUgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIG9ubHkgaW4gY2FzZSwgY3VycmVudCBwYWdlIHdhcyByZWxvYWRlZC4gSWYgd2UgZG9uJ3QgYWRkXG4gICAgICAvLyB0aGlzIGNoZWNrLCBzdGF0ZSByZXN0b3JhdGlvbiB3aWxsIHdvcmsgaW1wcm9wZXJseSBpbiB0aGUgd2ViIHZlcnNpb24gb2YgVGVsZWdyYW0sXG4gICAgICAvLyB3aGVuIHdlIGFyZSBhbHdheXMgd29ya2luZyBpbiB0aGUgc2FtZSBcInNlc3Npb25cIiAodGFiKS5cbiAgICAgIHN0YXRlOiBGdCgpID8genQoZSkgOiB2b2lkIDAsXG4gICAgICBhZGRDbGVhbnVwOiByXG4gICAgfSksIGggPSAocCkgPT4gKG8gfHwgcihcbiAgICAgIHAub24oXCJjaGFuZ2VcIiwgKFMpID0+IHtcbiAgICAgICAganQoZSwgUyk7XG4gICAgICB9KVxuICAgICksIHApO1xuICAgIHJldHVybiBbXG4gICAgICBhIGluc3RhbmNlb2YgUHJvbWlzZSA/IGEudGhlbihoKSA6IGgoYSksXG4gICAgICBpXG4gICAgXTtcbiAgfTtcbn1cbmNvbnN0IGplID0gbChcImJhY2tCdXR0b25cIiwgKHtcbiAgcG9zdEV2ZW50OiBlLFxuICB2ZXJzaW9uOiB0LFxuICBzdGF0ZTogcyA9IHsgaXNWaXNpYmxlOiAhMSB9XG59KSA9PiBuZXcgTmUocy5pc1Zpc2libGUsIHQsIGUpKTtcbmNsYXNzICQgZXh0ZW5kcyBwdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIGModGhpcywgXCJvblwiLCB0aGlzLnN0YXRlLm9uLmJpbmQodGhpcy5zdGF0ZSkpLCBjKHRoaXMsIFwib2ZmXCIsIHRoaXMuc3RhdGUub2ZmLmJpbmQodGhpcy5zdGF0ZSkpO1xuICB9XG59XG5mdW5jdGlvbiBRdChlKSB7XG4gIGNvbnN0IHQgPSBlLmF2YWlsYWJsZSA/IGUgOiB7XG4gICAgYXZhaWxhYmxlOiAhMSxcbiAgICBkZXZpY2VfaWQ6IFwiXCIsXG4gICAgdG9rZW5fc2F2ZWQ6ICExLFxuICAgIGFjY2Vzc19yZXF1ZXN0ZWQ6ICExLFxuICAgIGFjY2Vzc19ncmFudGVkOiAhMSxcbiAgICB0eXBlOiBcIlwiXG4gIH07XG4gIHJldHVybiB7XG4gICAgYXZhaWxhYmxlOiAhMCxcbiAgICB0eXBlOiB0LnR5cGUsXG4gICAgZGV2aWNlSWQ6IHQuZGV2aWNlX2lkLFxuICAgIHRva2VuU2F2ZWQ6IHQudG9rZW5fc2F2ZWQsXG4gICAgYWNjZXNzUmVxdWVzdGVkOiB0LmFjY2Vzc19yZXF1ZXN0ZWQsXG4gICAgYWNjZXNzR3JhbnRlZDogdC5hY2Nlc3NfZ3JhbnRlZFxuICB9O1xufVxuY2xhc3MgemUgZXh0ZW5kcyAkIHtcbiAgY29uc3RydWN0b3IoeyBwb3N0RXZlbnQ6IHQsIHZlcnNpb246IHMsIC4uLm4gfSkge1xuICAgIHN1cGVyKG4sIHMsIHtcbiAgICAgIGF1dGg6IFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2F1dGhcIixcbiAgICAgIG9wZW5TZXR0aW5nczogXCJ3ZWJfYXBwX2Jpb21ldHJ5X29wZW5fc2V0dGluZ3NcIixcbiAgICAgIHJlcXVlc3RBY2Nlc3M6IFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2FjY2Vzc1wiLFxuICAgICAgdXBkYXRlVG9rZW46IFwid2ViX2FwcF9iaW9tZXRyeV91cGRhdGVfdG9rZW5cIlxuICAgIH0pLCBjKHRoaXMsIFwicG9zdEV2ZW50XCIpLCBjKHRoaXMsIFwiYXV0aFByb21pc2VcIiksIGModGhpcywgXCJhY2Nlc3NQcm9taXNlXCIpLCB0aGlzLnBvc3RFdmVudCA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHdoZXRoZXIgYmlvbWV0cnkgaXMgYXZhaWxhYmxlLlxuICAgKi9cbiAgZ2V0IGF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJhdmFpbGFibGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHdoZXRoZXIgcGVybWlzc2lvbiB0byB1c2UgYmlvbWV0cmljcyBoYXMgYmVlbiBncmFudGVkLlxuICAgKi9cbiAgZ2V0IGFjY2Vzc0dyYW50ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYWNjZXNzR3JhbnRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3Mgd2hldGhlciBpZiBwZXJtaXNzaW9uIHRvIHVzZSBiaW9tZXRyaWNzIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIGdldCBhY2Nlc3NSZXF1ZXN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYWNjZXNzUmVxdWVzdGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGVzIHRoZSB1c2VyIHVzaW5nIGJpb21ldHJpY3MuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gbWV0aG9kIG9wdGlvbnMuXG4gICAqIEBzaW5jZSA3LjJcbiAgICogQHJldHVybnMgVG9rZW4gZnJvbSB0aGUgbG9jYWwgc2VjdXJlIHN0b3JhZ2UsIGlmIGF1dGhlbnRpY2F0aW9uIHdhcyBzdWNjZXNzZnVsLlxuICAgKi9cbiAgYXN5bmMgYXV0aGVudGljYXRlKHtcbiAgICByZWFzb246IHQsXG4gICAgLi4uc1xuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aFByb21pc2UgfHwgKHRoaXMuYXV0aFByb21pc2UgPSBnKHtcbiAgICAgIC4uLnMsXG4gICAgICBtZXRob2Q6IFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2F1dGhcIixcbiAgICAgIGV2ZW50OiBcImJpb21ldHJ5X2F1dGhfcmVxdWVzdGVkXCIsXG4gICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHJlYXNvbiBpcyBlbXB0eSB3b3JrcyBmaW5lLlxuICAgICAgICByZWFzb246ICh0IHx8IFwiXCIpLnRyaW0oKVxuICAgICAgfVxuICAgIH0pLnRoZW4oKHsgdG9rZW46IG4gfSkgPT4gbikuZmluYWxseSgoKSA9PiB0aGlzLmF1dGhQcm9taXNlID0gdm9pZCAwKSksIHRoaXMuYXV0aFByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGRldmljZSBpZGVudGlmaWVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWF0Y2ggdGhlIHRva2VuIHRvIHRoZSBkZXZpY2UuXG4gICAqL1xuICBnZXQgZGV2aWNlSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiZGV2aWNlSWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBiaW9tZXRyaWMgYWNjZXNzIHNldHRpbmdzIGZvciBib3RzLiBVc2VmdWwgd2hlbiB5b3UgbmVlZCB0byByZXF1ZXN0IGJpb21ldHJpY3NcbiAgICogYWNjZXNzIHRvIHVzZXJzIHdobyBoYXZlbid0IGdyYW50ZWQgaXQgeWV0LlxuICAgKlxuICAgKiBfTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgb25seSBpbiByZXNwb25zZSB0byB1c2VyIGludGVyYWN0aW9uIHdpdGggdGhlIE1pbmkgQXBwXG4gICAqIGludGVyZmFjZSAoZS5nLiBhIGNsaWNrIGluc2lkZSB0aGUgTWluaSBBcHAgb3Igb24gdGhlIG1haW4gYnV0dG9uKV8uXG4gICAqIEBzaW5jZSA3LjJcbiAgICovXG4gIG9wZW5TZXR0aW5ncygpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfYmlvbWV0cnlfb3Blbl9zZXR0aW5nc1wiKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgcGVybWlzc2lvbiB0byB1c2UgYmlvbWV0cmljcy5cbiAgICogQHNpbmNlIDcuMlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdHJ1ZSwgaWYgYWNjZXNzIHdhcyBncmFudGVkLlxuICAgKi9cbiAgcmVxdWVzdEFjY2Vzcyh7IHJlYXNvbjogdCwgLi4ucyB9ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5hY2Nlc3NQcm9taXNlIHx8ICh0aGlzLmFjY2Vzc1Byb21pc2UgPSBnKHtcbiAgICAgIC4uLnMsXG4gICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgbWV0aG9kOiBcIndlYl9hcHBfYmlvbWV0cnlfcmVxdWVzdF9hY2Nlc3NcIixcbiAgICAgIGV2ZW50OiBcImJpb21ldHJ5X2luZm9fcmVjZWl2ZWRcIixcbiAgICAgIHBhcmFtczogeyByZWFzb246IHQgfHwgXCJcIiB9XG4gICAgfSkudGhlbigobikgPT4ge1xuICAgICAgY29uc3QgciA9IFF0KG4pO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KHIpLCByLmFjY2Vzc0dyYW50ZWQ7XG4gICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLmFjY2Vzc1Byb21pc2UgPSB2b2lkIDApKSwgdGhpcy5hY2Nlc3NQcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBiaW9tZXRyaWNzIGN1cnJlbnRseSBhdmFpbGFibGUgb24gdGhlIGRldmljZS5cbiAgICovXG4gIGdldCBiaW9tZXRyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYmlvbWV0cnlUeXBlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB3aGV0aGVyIHRva2VuIHdhcyBzYXZlZCBwcmV2aW91c2x5IGluIHRoZSBsb2NhbCBzZWN1cmUgc3RvcmFnZS5cbiAgICovXG4gIGdldCB0b2tlblNhdmVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRva2VuU2F2ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGJpb21ldHJpYyB0b2tlbiBpbiBhIHNlY3VyZSBzdG9yYWdlIG9uIHRoZSBkZXZpY2UuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBgdHJ1ZWAsIGlmIHRva2VuIHdhcyB1cGRhdGVkLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVG9rZW4oeyB0b2tlbjogdCwgLi4ucyB9ID0ge30pIHtcbiAgICByZXR1cm4gW1wicmVtb3ZlZFwiLCBcInVwZGF0ZWRcIl0uaW5jbHVkZXMoXG4gICAgICAoYXdhaXQgZyh7XG4gICAgICAgIC4uLnMsXG4gICAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX2Jpb21ldHJ5X3VwZGF0ZV90b2tlblwiLFxuICAgICAgICBldmVudDogXCJiaW9tZXRyeV90b2tlbl91cGRhdGVkXCIsXG4gICAgICAgIHBhcmFtczogeyB0b2tlbjogdCB8fCBcIlwiIH1cbiAgICAgIH0pKS5zdGF0dXNcbiAgICApO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBLZShlKSB7XG4gIHJldHVybiBRdChcbiAgICBhd2FpdCBnKHtcbiAgICAgIC4uLmUgfHwge30sXG4gICAgICBtZXRob2Q6IFwid2ViX2FwcF9iaW9tZXRyeV9nZXRfaW5mb1wiLFxuICAgICAgZXZlbnQ6IFwiYmlvbWV0cnlfaW5mb19yZWNlaXZlZFwiXG4gICAgfSlcbiAgKTtcbn1cbmNvbnN0IEplID0gbChcbiAgXCJiaW9tZXRyeU1hbmFnZXJcIixcbiAgYXN5bmMgKHsgcG9zdEV2ZW50OiBlLCB2ZXJzaW9uOiB0LCBzdGF0ZTogcyB9KSA9PiBuZXcgemUoe1xuICAgIC4uLnMgfHwgQyhcIndlYl9hcHBfYmlvbWV0cnlfZ2V0X2luZm9cIiwgdCkgPyBzIHx8IGF3YWl0IEtlKHsgdGltZW91dDogMWUzIH0pIDoge1xuICAgICAgYXZhaWxhYmxlOiAhMSxcbiAgICAgIGFjY2Vzc0dyYW50ZWQ6ICExLFxuICAgICAgYWNjZXNzUmVxdWVzdGVkOiAhMSxcbiAgICAgIHRva2VuU2F2ZWQ6ICExLFxuICAgICAgZGV2aWNlSWQ6IFwiXCJcbiAgICB9LFxuICAgIHZlcnNpb246IHQsXG4gICAgcG9zdEV2ZW50OiBlXG4gIH0pXG4pO1xuY2xhc3MgZHQgZXh0ZW5kcyBodCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIGModGhpcywgXCJvblwiLCB0aGlzLnN0YXRlLm9uLmJpbmQodGhpcy5zdGF0ZSkpLCBjKHRoaXMsIFwib2ZmXCIsIHRoaXMuc3RhdGUub2ZmLmJpbmQodGhpcy5zdGF0ZSkpO1xuICB9XG59XG5jbGFzcyBGZSBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IodCwgcykge1xuICAgIHN1cGVyKHsgaXNDb25maXJtYXRpb25OZWVkZWQ6IHQgfSksIHRoaXMucG9zdEV2ZW50ID0gcztcbiAgfVxuICBzZXQgaXNDb25maXJtYXRpb25OZWVkZWQodCkge1xuICAgIHRoaXMuc2V0KFwiaXNDb25maXJtYXRpb25OZWVkZWRcIiwgdCksIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXR1cF9jbG9zaW5nX2JlaGF2aW9yXCIsIHsgbmVlZF9jb25maXJtYXRpb246IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUsIGlmIHRoZSBjb25maXJtYXRpb24gZGlhbG9nIHNob3VsZCBiZSBzaG93biB3aGlsZSB0aGUgdXNlciBpcyB0cnlpbmcgdG8gY2xvc2VcbiAgICogdGhlIE1pbmkgQXBwLlxuICAgKi9cbiAgZ2V0IGlzQ29uZmlybWF0aW9uTmVlZGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzQ29uZmlybWF0aW9uTmVlZGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgY29uZmlybWF0aW9uIGRpYWxvZyB3aGVuIGNsb3NpbmcgdGhlIE1pbmkgQXBwLlxuICAgKi9cbiAgZGlzYWJsZUNvbmZpcm1hdGlvbigpIHtcbiAgICB0aGlzLmlzQ29uZmlybWF0aW9uTmVlZGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIGNvbmZpcm1hdGlvbiBkaWFsb2cgd2hlbiBjbG9zaW5nIHRoZSBNaW5pIEFwcC5cbiAgICovXG4gIGVuYWJsZUNvbmZpcm1hdGlvbigpIHtcbiAgICB0aGlzLmlzQ29uZmlybWF0aW9uTmVlZGVkID0gITA7XG4gIH1cbn1cbmNvbnN0IFFlID0gbChcbiAgXCJjbG9zaW5nQmVoYXZpb3JcIixcbiAgKHtcbiAgICBwb3N0RXZlbnQ6IGUsXG4gICAgc3RhdGU6IHQgPSB7IGlzQ29uZmlybWF0aW9uTmVlZGVkOiAhMSB9XG4gIH0pID0+IG5ldyBGZSh0LmlzQ29uZmlybWF0aW9uTmVlZGVkLCBlKVxuKTtcbmNsYXNzIF90IHtcbiAgY29uc3RydWN0b3IodCwgcykge1xuICAgIGModGhpcywgXCJzdXBwb3J0c1wiKSwgdGhpcy5zdXBwb3J0cyA9IE10KHQsIHMpO1xuICB9XG59XG5mdW5jdGlvbiBZZShlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgIHJldHVybiBlO1xuICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IEpTT04ucGFyc2UoZSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSlcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB0aHJvdyBUKCk7XG59XG5jbGFzcyBaZSBleHRlbmRzIEcge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgc3VwZXIoWWUsIHMsIG4pLCBjKHRoaXMsIFwiaXRlbVBhcnNlclwiKSwgdGhpcy5pdGVtUGFyc2VyID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdCA6IHQucGFyc2UuYmluZCh0KTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcGFyc2UgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIHBhcnNlLlxuICAgKiBAdGhyb3dzIHtTREtFcnJvcn0gRVJSX1BBUlNFXG4gICAqIEBzZWUgRVJSX1BBUlNFXG4gICAqL1xuICBwYXJzZSh0KSB7XG4gICAgY29uc3QgcyA9IHN1cGVyLnBhcnNlKHQpO1xuICAgIHJldHVybiBzID09PSB2b2lkIDAgPyBzIDogcy5tYXAodGhpcy5pdGVtUGFyc2VyKTtcbiAgfVxuICBvZih0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbVBhcnNlciA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQgOiB0LnBhcnNlLmJpbmQodCksIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIFhlKGUpIHtcbiAgcmV0dXJuIG5ldyBaZSgodCkgPT4gdCwgITEsIGUpO1xufVxuZnVuY3Rpb24geXQoZSwgdCkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGUubWFwKChzKSA9PiBbcywgdF0pKTtcbn1cbmNsYXNzIHRzIGV4dGVuZHMgX3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgc3VwZXIodCwge1xuICAgICAgZGVsZXRlOiBcIndlYl9hcHBfaW52b2tlX2N1c3RvbV9tZXRob2RcIixcbiAgICAgIGdldDogXCJ3ZWJfYXBwX2ludm9rZV9jdXN0b21fbWV0aG9kXCIsXG4gICAgICBnZXRLZXlzOiBcIndlYl9hcHBfaW52b2tlX2N1c3RvbV9tZXRob2RcIixcbiAgICAgIHNldDogXCJ3ZWJfYXBwX2ludm9rZV9jdXN0b21fbWV0aG9kXCJcbiAgICB9KSwgdGhpcy5jcmVhdGVSZXF1ZXN0SWQgPSBzLCB0aGlzLnBvc3RFdmVudCA9IG47XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgc3BlY2lmaWVkIGtleSBvciBrZXlzIGZyb20gdGhlIGNsb3VkIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSBrZXlPcktleXMgLSBrZXkgb3Iga2V5cyB0byBkZWxldGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gcmVxdWVzdCBleGVjdXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZSh0LCBzID0ge30pIHtcbiAgICBjb25zdCBuID0gQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbdF07XG4gICAgbi5sZW5ndGggJiYgYXdhaXQgcShcbiAgICAgIFwiZGVsZXRlU3RvcmFnZVZhbHVlc1wiLFxuICAgICAgeyBrZXlzOiBuIH0sXG4gICAgICB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLFxuICAgICAgeyAuLi5zLCBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50IH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgYWxsIGtleXMgcHJlc2VudGVkIGluIHRoZSBjbG91ZCBzdG9yYWdlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHJlcXVlc3QgZXhlY3V0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBnZXRLZXlzKHQgPSB7fSkge1xuICAgIHJldHVybiBYZSgpLm9mKHUoKSkucGFyc2UoXG4gICAgICBhd2FpdCBxKFxuICAgICAgICBcImdldFN0b3JhZ2VLZXlzXCIsXG4gICAgICAgIHt9LFxuICAgICAgICB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLFxuICAgICAgICB7IC4uLnQsIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0KHQsIHMgPSB7fSkge1xuICAgIGNvbnN0IG4gPSBBcnJheS5pc0FycmF5KHQpID8gdCA6IFt0XTtcbiAgICBpZiAoIW4ubGVuZ3RoKVxuICAgICAgcmV0dXJuIHl0KG4sIFwiXCIpO1xuICAgIGNvbnN0IHIgPSBhd2FpdCBxKFxuICAgICAgXCJnZXRTdG9yYWdlVmFsdWVzXCIsXG4gICAgICB7IGtleXM6IG4gfSxcbiAgICAgIHRoaXMuY3JlYXRlUmVxdWVzdElkKCksXG4gICAgICB7IC4uLnMsIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICksIGkgPSB2KHl0KG4sIHUoKSksIFwiQ2xvdWRTdG9yYWdlRGF0YVwiKS5wYXJzZShyKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IGkgOiBpW3RdO1xuICB9XG4gIC8qKlxuICAgKiBTYXZlcyBzcGVjaWZpZWQgdmFsdWUgYnkga2V5LlxuICAgKiBAcGFyYW0ga2V5IC0gc3RvcmFnZSBrZXkuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHN0b3JhZ2UgdmFsdWUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gcmVxdWVzdCBleGVjdXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIHNldCh0LCBzLCBuID0ge30pIHtcbiAgICBhd2FpdCBxKFxuICAgICAgXCJzYXZlU3RvcmFnZVZhbHVlXCIsXG4gICAgICB7IGtleTogdCwgdmFsdWU6IHMgfSxcbiAgICAgIHRoaXMuY3JlYXRlUmVxdWVzdElkKCksXG4gICAgICB7IC4uLm4sIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGVzID0gbChcbiAgKHsgY3JlYXRlUmVxdWVzdElkOiBlLCBwb3N0RXZlbnQ6IHQsIHZlcnNpb246IHMgfSkgPT4gbmV3IHRzKHMsIGUsIHQpXG4pO1xuY2xhc3Mgc3MgZXh0ZW5kcyBfdCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMpIHtcbiAgICBzdXBlcih0LCB7XG4gICAgICBpbXBhY3RPY2N1cnJlZDogXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCIsXG4gICAgICBub3RpZmljYXRpb25PY2N1cnJlZDogXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCIsXG4gICAgICBzZWxlY3Rpb25DaGFuZ2VkOiBcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIlxuICAgIH0pLCB0aGlzLnBvc3RFdmVudCA9IHM7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRlbGxzIHRoYXQgYW4gaW1wYWN0IG9jY3VycmVkLiBUaGUgVGVsZWdyYW0gYXBwIG1heSBwbGF5IHRoZVxuICAgKiBhcHByb3ByaWF0ZSBoYXB0aWNzIGJhc2VkIG9uIHN0eWxlIHZhbHVlIHBhc3NlZC5cbiAgICogQHBhcmFtIHN0eWxlIC0gaW1wYWN0IHN0eWxlLlxuICAgKi9cbiAgaW1wYWN0T2NjdXJyZWQodCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF90cmlnZ2VyX2hhcHRpY19mZWVkYmFja1wiLCB7XG4gICAgICB0eXBlOiBcImltcGFjdFwiLFxuICAgICAgaW1wYWN0X3N0eWxlOiB0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRlbGxzIHRoYXQgYSB0YXNrIG9yIGFjdGlvbiBoYXMgc3VjY2VlZGVkLCBmYWlsZWQsIG9yIHByb2R1Y2VkXG4gICAqIGEgd2FybmluZy4gVGhlIFRlbGVncmFtIGFwcCBtYXkgcGxheSB0aGUgYXBwcm9wcmlhdGUgaGFwdGljcyBiYXNlZCBvblxuICAgKiB0eXBlIHZhbHVlIHBhc3NlZC5cbiAgICogQHBhcmFtIHR5cGUgLSBub3RpZmljYXRpb24gdHlwZS5cbiAgICovXG4gIG5vdGlmaWNhdGlvbk9jY3VycmVkKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIiwge1xuICAgICAgdHlwZTogXCJub3RpZmljYXRpb25cIixcbiAgICAgIG5vdGlmaWNhdGlvbl90eXBlOiB0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRlbGxzIHRoYXQgdGhlIHVzZXIgaGFzIGNoYW5nZWQgYSBzZWxlY3Rpb24uIFRoZSBUZWxlZ3JhbSBhcHBcbiAgICogbWF5IHBsYXkgdGhlIGFwcHJvcHJpYXRlIGhhcHRpY3MuXG4gICAqXG4gICAqIERvIG5vdCB1c2UgdGhpcyBmZWVkYmFjayB3aGVuIHRoZSB1c2VyIG1ha2VzIG9yIGNvbmZpcm1zIGEgc2VsZWN0aW9uO1xuICAgKiB1c2UgaXQgb25seSB3aGVuIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cbiAgICovXG4gIHNlbGVjdGlvbkNoYW5nZWQoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCIsIHsgdHlwZTogXCJzZWxlY3Rpb25fY2hhbmdlXCIgfSk7XG4gIH1cbn1cbmNvbnN0IG5zID0gbChcbiAgKHsgdmVyc2lvbjogZSwgcG9zdEV2ZW50OiB0IH0pID0+IG5ldyBzcyhlLCB0KVxuKTtcbmNsYXNzIHJzIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuaW5pdERhdGEgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmF1dGhEYXRlXG4gICAqL1xuICBnZXQgYXV0aERhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuYXV0aERhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuY2FuU2VuZEFmdGVyXG4gICAqL1xuICBnZXQgY2FuU2VuZEFmdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmNhblNlbmRBZnRlcjtcbiAgfVxuICAvKipcbiAgICogRGF0ZSBhZnRlciB3aGljaCBpdCBpcyBhbGxvd2VkIHRvIGNhbGxcbiAgICogdGhlIFthbnN3ZXJXZWJBcHBRdWVyeV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhbnN3ZXJ3ZWJhcHBxdWVyeSkgbWV0aG9kLlxuICAgKi9cbiAgZ2V0IGNhblNlbmRBZnRlckRhdGUoKSB7XG4gICAgY29uc3QgeyBjYW5TZW5kQWZ0ZXI6IHQgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHQgPyBuZXcgRGF0ZSh0aGlzLmF1dGhEYXRlLmdldFRpbWUoKSArIHQgKiAxZTMpIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmNoYXRcbiAgICovXG4gIGdldCBjaGF0KCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmNoYXQ7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuY2hhdFR5cGVcbiAgICovXG4gIGdldCBjaGF0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5jaGF0VHlwZTtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5jaGF0SW5zdGFuY2VcbiAgICovXG4gIGdldCBjaGF0SW5zdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuY2hhdEluc3RhbmNlO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmhhc2hcbiAgICovXG4gIGdldCBoYXNoKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmhhc2g7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQucXVlcnlJZFxuICAgKi9cbiAgZ2V0IHF1ZXJ5SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEucXVlcnlJZDtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5yZWNlaXZlclxuICAgKi9cbiAgZ2V0IHJlY2VpdmVyKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLnJlY2VpdmVyO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLnN0YXJ0UGFyYW1cbiAgICovXG4gIGdldCBzdGFydFBhcmFtKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLnN0YXJ0UGFyYW07XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQudXNlclxuICAgKi9cbiAgZ2V0IHVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEudXNlcjtcbiAgfVxufVxuY29uc3QgaXMgPSBsKFxuICAoeyBpbml0RGF0YTogZSB9KSA9PiBlID8gbmV3IHJzKGUpIDogdm9pZCAwXG4pO1xuZnVuY3Rpb24gbW4oZSkge1xuICByZXR1cm4gJHQoKS5wYXJzZShlKTtcbn1cbmNsYXNzIG9zIGV4dGVuZHMgJCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih7IGlzT3BlbmVkOiB0IH0sIHMsIHsgb3BlbjogXCJ3ZWJfYXBwX29wZW5faW52b2ljZVwiIH0pLCB0aGlzLnBvc3RFdmVudCA9IG47XG4gIH1cbiAgc2V0IGlzT3BlbmVkKHQpIHtcbiAgICB0aGlzLnNldChcImlzT3BlbmVkXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGludm9pY2UgaXMgY3VycmVudGx5IG9wZW5lZC5cbiAgICovXG4gIGdldCBpc09wZW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc09wZW5lZFwiKTtcbiAgfVxuICBhc3luYyBvcGVuKHQsIHMpIHtcbiAgICBpZiAodGhpcy5pc09wZW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludm9pY2UgaXMgYWxyZWFkeSBvcGVuZWRcIik7XG4gICAgbGV0IG47XG4gICAgaWYgKCFzKVxuICAgICAgbiA9IHQ7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB7IGhvc3RuYW1lOiByLCBwYXRobmFtZTogaSB9ID0gbmV3IFVSTCh0LCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICBpZiAociAhPT0gXCJ0Lm1lXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb3JyZWN0IGhvc3RuYW1lOiAke3J9YCk7XG4gICAgICBjb25zdCBvID0gaS5tYXRjaCgvXlxcLyhcXCR8aW52b2ljZVxcLykoW0EtWmEtejAtOVxcLV89XSspJC8pO1xuICAgICAgaWYgKCFvKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmsgcGF0aG5hbWUgaGFzIGluY29ycmVjdCBmb3JtYXQuIEV4cGVjdGVkIHRvIHJlY2VpdmUgXCIvaW52b2ljZS97c2x1Z31cIiBvciBcIi8ke3NsdWd9XCInKTtcbiAgICAgIFssICwgbl0gPSBvO1xuICAgIH1cbiAgICB0aGlzLmlzT3BlbmVkID0gITA7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoYXdhaXQgZyh7XG4gICAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX29wZW5faW52b2ljZVwiLFxuICAgICAgICBldmVudDogXCJpbnZvaWNlX2Nsb3NlZFwiLFxuICAgICAgICBwYXJhbXM6IHsgc2x1ZzogbiB9LFxuICAgICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgICBjYXB0dXJlKHIpIHtcbiAgICAgICAgICByZXR1cm4gbiA9PT0gci5zbHVnO1xuICAgICAgICB9XG4gICAgICB9KSkuc3RhdHVzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzT3BlbmVkID0gITE7XG4gICAgfVxuICB9XG59XG5jb25zdCBhcyA9IGwoXG4gICh7IHZlcnNpb246IGUsIHBvc3RFdmVudDogdCB9KSA9PiBuZXcgb3MoITEsIGUsIHQpXG4pO1xuY2xhc3MgY3MgZXh0ZW5kcyBodCB7XG4gIGNvbnN0cnVjdG9yKHsgcG9zdEV2ZW50OiB0LCAuLi5zIH0pIHtcbiAgICBzdXBlcihzKSwgYyh0aGlzLCBcInBvc3RFdmVudFwiKSwgYyh0aGlzLCBcIm9uXCIsIChuLCByKSA9PiBuID09PSBcImNsaWNrXCIgPyB5KFwibWFpbl9idXR0b25fcHJlc3NlZFwiLCByKSA6IHRoaXMuc3RhdGUub24obiwgcikpLCBjKHRoaXMsIFwib2ZmXCIsIChuLCByKSA9PiBuID09PSBcImNsaWNrXCIgPyB6KFwibWFpbl9idXR0b25fcHJlc3NlZFwiLCByKSA6IHRoaXMuc3RhdGUub2ZmKG4sIHIpKSwgdGhpcy5wb3N0RXZlbnQgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTWFpbkJ1dHRvbiBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKi9cbiAgZ2V0IGJnQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYmdDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgY3VycmVudCBsb2NhbCBzdGF0ZSB0byB0aGUgVGVsZWdyYW0gYXBwbGljYXRpb24uXG4gICAqL1xuICBjb21taXQoKSB7XG4gICAgdGhpcy50ZXh0ICE9PSBcIlwiICYmIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXR1cF9tYWluX2J1dHRvblwiLCB7XG4gICAgICBpc192aXNpYmxlOiB0aGlzLmlzVmlzaWJsZSxcbiAgICAgIGlzX2FjdGl2ZTogdGhpcy5pc0VuYWJsZWQsXG4gICAgICBpc19wcm9ncmVzc192aXNpYmxlOiB0aGlzLmlzTG9hZGVyVmlzaWJsZSxcbiAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgIGNvbG9yOiB0aGlzLmJnQ29sb3IsXG4gICAgICB0ZXh0X2NvbG9yOiB0aGlzLnRleHRDb2xvclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgTWFpbkJ1dHRvbi5cbiAgICogQHNlZSBEb2VzIG5vdCB3b3JrIG9uIEFuZHJvaWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvaXNzdWVzL2lzc3Vlcy8xXG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCA9ICExLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBNYWluQnV0dG9uLlxuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCA9ICEwLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgTWFpbkJ1dHRvbi5cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWaXNpYmxlID0gITEsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBNYWluQnV0dG9uIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgKi9cbiAgaGlkZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xvYWRlclZpc2libGUgPSAhMSwgdGhpcztcbiAgfVxuICBzZXQgaXNFbmFibGVkKHQpIHtcbiAgICB0aGlzLnNldFBhcmFtcyh7IGlzRW5hYmxlZDogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgTWFpbkJ1dHRvbiBpcyBlbmFibGVkLlxuICAgKi9cbiAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc0VuYWJsZWRcIik7XG4gIH1cbiAgc2V0IGlzTG9hZGVyVmlzaWJsZSh0KSB7XG4gICAgdGhpcy5zZXRQYXJhbXMoeyBpc0xvYWRlclZpc2libGU6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIE1haW5CdXR0b24gbG9hZGVyIGlzIHZpc2libGUuXG4gICAqL1xuICBnZXQgaXNMb2FkZXJWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzTG9hZGVyVmlzaWJsZVwiKTtcbiAgfVxuICBzZXQgaXNWaXNpYmxlKHQpIHtcbiAgICB0aGlzLnNldFBhcmFtcyh7IGlzVmlzaWJsZTogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgTWFpbkJ1dHRvbiBpcyB2aXNpYmxlLlxuICAgKi9cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc1Zpc2libGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBNYWluQnV0dG9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgb3BlbmluZyB0aGUgTWluaSBBcHAgZnJvbSB0aGUgYXR0YWNobWVudCBtZW51IGhpZGVzIHRoZSBtYWluIGJ1dHRvbiB1bnRpbCB0aGVcbiAgICogdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgTWluaSBBcHAgaW50ZXJmYWNlLlxuICAgKi9cbiAgc2hvdygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Zpc2libGUgPSAhMCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU2hvd3MgYSBsb2FkaW5nIGluZGljYXRvciBvbiB0aGUgTWFpbiBCdXR0b24uXG4gICAqL1xuICBzaG93TG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzTG9hZGVyVmlzaWJsZSA9ICEwLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IE1haW5CdXR0b24gdGV4dC4gTWluaW1hbCBsZW5ndGggZm9yIHRoZSB0ZXh0IGlzIDEgc3ltYm9sLCBhbmQgbWF4aW11bSBpcyA2NCBzeW1ib2xzLlxuICAgKiBAcGFyYW0gdGV4dCAtIGEgbmV3IHRleHQuXG4gICAqL1xuICBzZXRUZXh0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRQYXJhbXMoeyB0ZXh0OiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IE1haW4gQnV0dG9uIHRleHQgY29sb3IuXG4gICAqIEBwYXJhbSB0ZXh0Q29sb3IgLSBuZXcgdGV4dCBjb2xvci5cbiAgICovXG4gIHNldFRleHRDb2xvcih0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyYW1zKHsgdGV4dENvbG9yOiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGN1cnJlbnQgTWFpbiBCdXR0b24gY29sb3IuXG4gICAqIEBwYXJhbSBiZ0NvbG9yIC0gY29sb3IgdG8gc2V0LlxuICAgKi9cbiAgc2V0QmdDb2xvcih0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyYW1zKHsgYmdDb2xvcjogdCB9KTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHNldHRpbmcgbXVsdGlwbGUgTWFpbiBCdXR0b24gcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHBhcmFtcyAtIE1haW4gQnV0dG9uIHBhcmFtZXRlcnMuXG4gICAqL1xuICBzZXRQYXJhbXModCkge1xuICAgIHJldHVybiB0aGlzLnNldCh0KSwgdGhpcy5jb21taXQoKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIE1haW5CdXR0b24gdGV4dC5cbiAgICovXG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRleHRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNYWluQnV0dG9uIHRleHQgY29sb3IuXG4gICAqL1xuICBnZXQgdGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRleHRDb2xvclwiKTtcbiAgfVxufVxuY29uc3QgaHMgPSBsKFxuICBcIm1haW5CdXR0b25cIixcbiAgKHtcbiAgICBwb3N0RXZlbnQ6IGUsXG4gICAgdGhlbWVQYXJhbXM6IHQsXG4gICAgc3RhdGU6IHMgPSB7XG4gICAgICBpc1Zpc2libGU6ICExLFxuICAgICAgaXNFbmFibGVkOiAhMSxcbiAgICAgIHRleHQ6IFwiXCIsXG4gICAgICBpc0xvYWRlclZpc2libGU6ICExLFxuICAgICAgdGV4dENvbG9yOiB0LmJ1dHRvblRleHRDb2xvciB8fCBcIiNmZmZmZmZcIixcbiAgICAgIGJnQ29sb3I6IHQuYnV0dG9uQ29sb3IgfHwgXCIjMDAwMDAwXCJcbiAgICB9XG4gIH0pID0+IG5ldyBjcyh7IC4uLnMsIHBvc3RFdmVudDogZSB9KVxuKTtcbmZ1bmN0aW9uIHBzKCkge1xuICByZXR1cm4gdXQoe1xuICAgIGNvbnRhY3Q6IHYoe1xuICAgICAgdXNlcklkOiB7XG4gICAgICAgIHR5cGU6IHgoKSxcbiAgICAgICAgZnJvbTogXCJ1c2VyX2lkXCJcbiAgICAgIH0sXG4gICAgICBwaG9uZU51bWJlcjoge1xuICAgICAgICB0eXBlOiB1KCksXG4gICAgICAgIGZyb206IFwicGhvbmVfbnVtYmVyXCJcbiAgICAgIH0sXG4gICAgICBmaXJzdE5hbWU6IHtcbiAgICAgICAgdHlwZTogdSgpLFxuICAgICAgICBmcm9tOiBcImZpcnN0X25hbWVcIlxuICAgICAgfSxcbiAgICAgIGxhc3ROYW1lOiB7XG4gICAgICAgIHR5cGU6IHUoKS5vcHRpb25hbCgpLFxuICAgICAgICBmcm9tOiBcImxhc3RfbmFtZVwiXG4gICAgICB9XG4gICAgfSksXG4gICAgYXV0aERhdGU6IHtcbiAgICAgIHR5cGU6IEx0KCksXG4gICAgICBmcm9tOiBcImF1dGhfZGF0ZVwiXG4gICAgfSxcbiAgICBoYXNoOiB1KClcbiAgfSwgXCJSZXF1ZXN0ZWRDb250YWN0XCIpO1xufVxuZnVuY3Rpb24gWXQoZSwgdCkge1xuICByZXR1cm4gKHMpID0+IHtcbiAgICBjb25zdCBbbiwgcl0gPSB0W3NdO1xuICAgIHJldHVybiBDKG4sIHIsIGUpO1xuICB9O1xufVxuZnVuY3Rpb24gdXMoZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICBzZXRUaW1lb3V0KHQsIGUpO1xuICB9KTtcbn1cbmNsYXNzIGxzIGV4dGVuZHMgJCB7XG4gIGNvbnN0cnVjdG9yKHsgcG9zdEV2ZW50OiB0LCBjcmVhdGVSZXF1ZXN0SWQ6IHMsIHZlcnNpb246IG4sIGJvdElubGluZTogciwgLi4uaSB9KSB7XG4gICAgc3VwZXIoaSwgbiwge1xuICAgICAgcmVxdWVzdFBob25lQWNjZXNzOiBcIndlYl9hcHBfcmVxdWVzdF9waG9uZVwiLFxuICAgICAgcmVxdWVzdFdyaXRlQWNjZXNzOiBcIndlYl9hcHBfcmVxdWVzdF93cml0ZV9hY2Nlc3NcIixcbiAgICAgIHN3aXRjaElubGluZVF1ZXJ5OiBcIndlYl9hcHBfc3dpdGNoX2lubGluZV9xdWVyeVwiLFxuICAgICAgc2V0SGVhZGVyQ29sb3I6IFwid2ViX2FwcF9zZXRfaGVhZGVyX2NvbG9yXCIsXG4gICAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IFwid2ViX2FwcF9zZXRfYmFja2dyb3VuZF9jb2xvclwiXG4gICAgfSksIGModGhpcywgXCJib3RJbmxpbmVcIiksIGModGhpcywgXCJwb3N0RXZlbnRcIiksIGModGhpcywgXCJjcmVhdGVSZXF1ZXN0SWRcIiksIGModGhpcywgXCJyZXF1ZXN0UGhvbmVBY2Nlc3NQcm9taXNlXCIpLCBjKHRoaXMsIFwicmVxdWVzdFdyaXRlQWNjZXNzUHJvbWlzZVwiKSwgYyh0aGlzLCBcInN1cHBvcnRzUGFyYW1cIiksIHRoaXMuY3JlYXRlUmVxdWVzdElkID0gcywgdGhpcy5wb3N0RXZlbnQgPSB0LCB0aGlzLmJvdElubGluZSA9IHI7XG4gICAgY29uc3QgbyA9IHRoaXMuc3VwcG9ydHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN1cHBvcnRzID0gKGEpID0+IG8oYSkgPyBhICE9PSBcInN3aXRjaElubGluZVF1ZXJ5XCIgfHwgciA6ICExLCB0aGlzLnN1cHBvcnRzUGFyYW0gPSBZdChuLCB7XG4gICAgICBcInNldEhlYWRlckNvbG9yLmNvbG9yXCI6IFtcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiLCBcImNvbG9yXCJdXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGdldCByZXF1ZXN0ZWQgY29udGFjdC5cbiAgICogQHBhcmFtIHRpbWVvdXQgLSByZXF1ZXN0IHRpbWVvdXQuXG4gICAqL1xuICBhc3luYyBnZXRSZXF1ZXN0ZWRDb250YWN0KHtcbiAgICB0aW1lb3V0OiB0ID0gMWU0XG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBwcygpLnBhcnNlKFxuICAgICAgYXdhaXQgcShcbiAgICAgICAgXCJnZXRSZXF1ZXN0ZWRDb250YWN0XCIsXG4gICAgICAgIHt9LFxuICAgICAgICB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLFxuICAgICAgICB7IHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsIHRpbWVvdXQ6IHQgfVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNaW5pIEFwcCBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKiBAZXhhbXBsZSBcIiNmZmFhYmJcIlxuICAgKi9cbiAgZ2V0IGJnQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYmdDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBNaW5pIEFwcC5cbiAgICogQHBhcmFtIHJldHVybkJhY2sgLSBzaG91bGQgdGhlIGFwcGxpY2F0aW9uIGJlIHdyYXBwZWQgaW50byB0aGUgYm90dG9tIGJhci5cbiAgICovXG4gIGNsb3NlKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfY2xvc2VcIiwgeyByZXR1cm5fYmFjazogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIE1pbmkgQXBwIGhlYWRlciBjb2xvci5cbiAgICogQGV4YW1wbGUgXCIjZmZhYWJiXCJcbiAgICogQGV4YW1wbGUgXCJiZ19jb2xvclwiXG4gICAqL1xuICBnZXQgaGVhZGVyQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaGVhZGVyQ29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIE1pbmkgQXBwIGlzIGN1cnJlbnRseSBsYXVuY2hlZCBpbiBib3QgaW5saW5lIG1vZGUuXG4gICAqL1xuICBnZXQgaXNCb3RJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90SW5saW5lO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBjdXJyZW50IE1pbmkgQXBwIGJhY2tncm91bmQgY29sb3IgaXMgcmVjb2duaXplZCBhcyBkYXJrLlxuICAgKi9cbiAgZ2V0IGlzRGFyaygpIHtcbiAgICByZXR1cm4gQnQodGhpcy5iZ0NvbG9yKTtcbiAgfVxuICAvKipcbiAgICogSW5mb3JtcyB0aGUgVGVsZWdyYW0gYXBwIHRoYXQgdGhlIE1pbmkgQXBwIGlzIHJlYWR5IHRvIGJlIGRpc3BsYXllZC5cbiAgICpcbiAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBhcyBlYXJseSBhcyBwb3NzaWJsZSwgYXMgc29vbiBhcyBhbGwgZXNzZW50aWFsXG4gICAqIGludGVyZmFjZSBlbGVtZW50cyBsb2FkZWQuIE9uY2UgdGhpcyBtZXRob2QgY2FsbGVkLCB0aGUgbG9hZGluZyBwbGFjZWhvbGRlciBpcyBoaWRkZW5cbiAgICogYW5kIHRoZSBNaW5pIEFwcCBzaG93bi5cbiAgICpcbiAgICogSWYgdGhlIG1ldGhvZCBub3QgY2FsbGVkLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBiZSBoaWRkZW4gb25seSB3aGVuIHRoZSBwYWdlIGZ1bGx5IGxvYWRlZC5cbiAgICovXG4gIHJlYWR5KCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9yZWFkeVwiKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgY3VycmVudCB1c2VyIGNvbnRhY3QgaW5mb3JtYXRpb24uIEluIGNvbnRyYXJ5IHRvIHJlcXVlc3RQaG9uZUFjY2VzcywgdGhpcyBtZXRob2RcbiAgICogcmV0dXJucyBwcm9taXNlIHdpdGggY29udGFjdCBpbmZvcm1hdGlvbiB0aGF0IHJlamVjdHMgaW4gY2FzZSwgdXNlciBkZW5pZWQgYWNjZXNzLCBvciByZXF1ZXN0XG4gICAqIGZhaWxlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyByZXF1ZXN0Q29udGFjdCh7IHRpbWVvdXQ6IHQgPSA1ZTMgfSA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFJlcXVlc3RlZENvbnRhY3QoKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgaWYgKGF3YWl0IHRoaXMucmVxdWVzdFBob25lQWNjZXNzKCkgIT09IFwic2VudFwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWNjZXNzIGRlbmllZC5cIik7XG4gICAgY29uc3QgcyA9IERhdGUubm93KCkgKyB0O1xuICAgIGxldCBuID0gNTA7XG4gICAgcmV0dXJuIER0KGFzeW5jICgpID0+IHtcbiAgICAgIGZvciAoOyBEYXRlLm5vdygpIDwgczsgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UmVxdWVzdGVkQ29udGFjdCgpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB1cyhuKSwgbiArPSA1MDtcbiAgICAgIH1cbiAgICAgIHRocm93IE50KHQpO1xuICAgIH0sIHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBjdXJyZW50IHVzZXIgcGhvbmUgYWNjZXNzLiBNZXRob2QgcmV0dXJucyBwcm9taXNlLCB3aGljaCByZXNvbHZlc1xuICAgKiBzdGF0dXMgb2YgdGhlIHJlcXVlc3QuIEluIGNhc2UsIHVzZXIgYWNjZXB0ZWQgdGhlIHJlcXVlc3QsIE1pbmkgQXBwIGJvdCB3aWxsIHJlY2VpdmVcbiAgICogdGhlIGFjY29yZGluZyBub3RpZmljYXRpb24uXG4gICAqXG4gICAqIFRvIG9idGFpbiB0aGUgcmV0cmlldmVkIGluZm9ybWF0aW9uIGluc3RlYWQsIHV0aWxpemUgdGhlIGByZXF1ZXN0Q29udGFjdGAgbWV0aG9kLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHNlZSByZXF1ZXN0Q29udGFjdFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdFBob25lQWNjZXNzKHQgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQaG9uZUFjY2Vzc1Byb21pc2UgfHwgKHRoaXMucmVxdWVzdFBob25lQWNjZXNzUHJvbWlzZSA9IGcoe1xuICAgICAgLi4udCxcbiAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX3JlcXVlc3RfcGhvbmVcIixcbiAgICAgIGV2ZW50OiBcInBob25lX3JlcXVlc3RlZFwiLFxuICAgICAgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudFxuICAgIH0pLnRoZW4oKHsgc3RhdHVzOiBzIH0pID0+IHMpLmZpbmFsbHkoKCkgPT4gdGhpcy5yZXF1ZXN0UGhvbmVBY2Nlc3NQcm9taXNlID0gdm9pZCAwKSksIHRoaXMucmVxdWVzdFBob25lQWNjZXNzUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgd3JpdGUgbWVzc2FnZSBhY2Nlc3MgdG8gY3VycmVudCB1c2VyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIHJlcXVlc3RXcml0ZUFjY2Vzcyh0ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0V3JpdGVBY2Nlc3NQcm9taXNlIHx8ICh0aGlzLnJlcXVlc3RXcml0ZUFjY2Vzc1Byb21pc2UgPSBnKHtcbiAgICAgIC4uLnQsXG4gICAgICBtZXRob2Q6IFwid2ViX2FwcF9yZXF1ZXN0X3dyaXRlX2FjY2Vzc1wiLFxuICAgICAgZXZlbnQ6IFwid3JpdGVfYWNjZXNzX3JlcXVlc3RlZFwiLFxuICAgICAgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudFxuICAgIH0pLnRoZW4oKHsgc3RhdHVzOiBzIH0pID0+IHMpLmZpbmFsbHkoKCkgPT4gdGhpcy5yZXF1ZXN0V3JpdGVBY2Nlc3NQcm9taXNlID0gdm9pZCAwKSksIHRoaXMucmVxdWVzdFdyaXRlQWNjZXNzUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdXNlZCB0byBzZW5kIGRhdGEgdG8gdGhlIGJvdC4gV2hlbiB0aGlzIG1ldGhvZCBjYWxsZWQsIGEgc2VydmljZSBtZXNzYWdlIHNlbnQgdG9cbiAgICogdGhlIGJvdCBjb250YWluaW5nIHRoZSBkYXRhIG9mIHRoZSBsZW5ndGggdXAgdG8gNDA5NiBieXRlcywgYW5kIHRoZSBNaW5pIEFwcCBjbG9zZWQuIFNlZSB0aGVcbiAgICogZmllbGQgYHdlYl9hcHBfZGF0YWAgaW4gdGhlIGNsYXNzIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgTWluaSBBcHBzIGxhdW5jaGVkIHZpYSBhIEtleWJvYXJkIGJ1dHRvbi5cbiAgICogQHBhcmFtIGRhdGEgLSBkYXRhIHRvIHNlbmQgdG8gYm90LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gZGF0YSBoYXMgaW5jb3JyZWN0IHNpemUuXG4gICAqL1xuICBzZW5kRGF0YSh0KSB7XG4gICAgY29uc3QgeyBzaXplOiBzIH0gPSBuZXcgQmxvYihbdF0pO1xuICAgIGlmICghcyB8fCBzID4gNDA5NilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGFzc2VkIGRhdGEgaGFzIGluY29ycmVjdCBzaXplOiAke3N9YCk7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX2RhdGFfc2VuZFwiLCB7IGRhdGE6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY3VycmVudCBNaW5pIEFwcCBoZWFkZXIgY29sb3IuXG4gICAqXG4gICAqIEBzZWUgTm8gZWZmZWN0IG9uIGRlc2t0b3A6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvdG1hLmpzL2lzc3Vlcy85XG4gICAqIEBzZWUgV29ya3MgaW5jb3JyZWN0bHkgaW4gQW5kcm9pZDogaHR0cHM6Ly9naXRodWIuY29tL1RlbGVncmFtLU1pbmktQXBwcy90bWEuanMvaXNzdWVzLzhcbiAgICogQHBhcmFtIGNvbG9yIC0gY29sb3Iga2V5IG9yIFJHQiBjb2xvci5cbiAgICovXG4gIHNldEhlYWRlckNvbG9yKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiLCBjdCh0KSA/IHsgY29sb3I6IHQgfSA6IHsgY29sb3Jfa2V5OiB0IH0pLCB0aGlzLnNldChcImhlYWRlckNvbG9yXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGN1cnJlbnQgTWluaSBBcHAgYmFja2dyb3VuZCBjb2xvci5cbiAgICpcbiAgICogQHNlZSBObyBlZmZlY3Qgb24gZGVza3RvcDogaHR0cHM6Ly9naXRodWIuY29tL1RlbGVncmFtLU1pbmktQXBwcy90bWEuanMvaXNzdWVzLzlcbiAgICogQHNlZSBXb3JrcyBpbmNvcnJlY3RseSBpbiBBbmRyb2lkOiBodHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL3RtYS5qcy9pc3N1ZXMvOFxuICAgKiBAcGFyYW0gY29sb3IgLSBSR0IgY29sb3IuXG4gICAqL1xuICBzZXRCZ0NvbG9yKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0X2JhY2tncm91bmRfY29sb3JcIiwgeyBjb2xvcjogdCB9KSwgdGhpcy5zZXQoXCJiZ0NvbG9yXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIHRoZSBib3QncyB1c2VybmFtZSBhbmQgdGhlIHNwZWNpZmllZCBpbmxpbmUgcXVlcnkgaW4gdGhlIGN1cnJlbnQgY2hhdCdzIGlucHV0IGZpZWxkLlxuICAgKiBRdWVyeSBtYXkgYmUgZW1wdHksIGluIHdoaWNoIGNhc2Ugb25seSB0aGUgYm90J3MgdXNlcm5hbWUgd2lsbCBiZSBpbnNlcnRlZC4gVGhlIGNsaWVudCBwcm9tcHRzXG4gICAqIHRoZSB1c2VyIHRvIGNob29zZSBhIHNwZWNpZmljIGNoYXQsIHRoZW4gb3BlbnMgdGhhdCBjaGF0IGFuZCBpbnNlcnRzIHRoZSBib3QncyB1c2VybmFtZSBhbmRcbiAgICogdGhlIHNwZWNpZmllZCBpbmxpbmUgcXVlcnkgaW4gdGhlIGlucHV0IGZpZWxkLlxuICAgKiBAcGFyYW0gdGV4dCAtIHRleHQgd2hpY2ggc2hvdWxkIGJlIGluc2VydGVkIGluIHRoZSBpbnB1dCBhZnRlciB0aGUgY3VycmVudCBib3QgbmFtZS4gTWF4XG4gICAqIGxlbmd0aCBpcyAyNTYgc3ltYm9scy5cbiAgICogQHBhcmFtIGNoYXRUeXBlcyAtIExpc3Qgb2YgY2hhdCB0eXBlcyB3aGljaCBjb3VsZCBiZSBjaG9zZW4gdG8gc2VuZCB0aGUgbWVzc2FnZS4gQ291bGQgYmVcbiAgICogZW1wdHkgbGlzdC5cbiAgICovXG4gIHN3aXRjaElubGluZVF1ZXJ5KHQsIHMgPSBbXSkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0cyhcInN3aXRjaElubGluZVF1ZXJ5XCIpICYmICF0aGlzLmlzQm90SW5saW5lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIGlzIHVuc3VwcG9ydGVkIGJlY2F1c2UgTWluaSBBcHAgc2hvdWxkIGJlIGxhdW5jaGVkIGluIGlubGluZSBtb2RlLlwiKTtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc3dpdGNoX2lubGluZV9xdWVyeVwiLCB7IHF1ZXJ5OiB0LCBjaGF0X3R5cGVzOiBzIH0pO1xuICB9XG59XG5jb25zdCBkcyA9IGwoXG4gIFwibWluaUFwcFwiLFxuICAoe1xuICAgIHRoZW1lUGFyYW1zOiBlLFxuICAgIGJvdElubGluZTogdCA9ICExLFxuICAgIHN0YXRlOiBzID0ge1xuICAgICAgYmdDb2xvcjogZS5iZ0NvbG9yIHx8IFwiI2ZmZmZmZlwiLFxuICAgICAgaGVhZGVyQ29sb3I6IGUuaGVhZGVyQmdDb2xvciB8fCBcIiMwMDAwMDBcIlxuICAgIH0sXG4gICAgLi4ublxuICB9KSA9PiBuZXcgbHMoeyAuLi5uLCAuLi5zLCBib3RJbmxpbmU6IHQgfSlcbik7XG5mdW5jdGlvbiBfcyhlKSB7XG4gIGNvbnN0IHQgPSBlLm1lc3NhZ2UudHJpbSgpLCBzID0gKGUudGl0bGUgfHwgXCJcIikudHJpbSgpLCBuID0gZS5idXR0b25zIHx8IFtdO1xuICBsZXQgcjtcbiAgaWYgKHMubGVuZ3RoID4gNjQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaXRsZSBoYXMgaW5jb3JyZWN0IHNpemU6ICR7cy5sZW5ndGh9YCk7XG4gIGlmICghdC5sZW5ndGggfHwgdC5sZW5ndGggPiAyNTYpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdlIGhhcyBpbmNvcnJlY3Qgc2l6ZTogJHt0Lmxlbmd0aH1gKTtcbiAgaWYgKG4ubGVuZ3RoID4gMylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1dHRvbnMgaGF2ZSBpbmNvcnJlY3Qgc2l6ZTogJHtuLmxlbmd0aH1gKTtcbiAgcmV0dXJuIG4ubGVuZ3RoID8gciA9IG4ubWFwKChpKSA9PiB7XG4gICAgY29uc3QgeyBpZDogbyA9IFwiXCIgfSA9IGk7XG4gICAgaWYgKG8ubGVuZ3RoID4gNjQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1dHRvbiBJRCBoYXMgaW5jb3JyZWN0IHNpemU6ICR7b31gKTtcbiAgICBpZiAoIWkudHlwZSB8fCBpLnR5cGUgPT09IFwiZGVmYXVsdFwiIHx8IGkudHlwZSA9PT0gXCJkZXN0cnVjdGl2ZVwiKSB7XG4gICAgICBjb25zdCBhID0gaS50ZXh0LnRyaW0oKTtcbiAgICAgIGlmICghYS5sZW5ndGggfHwgYS5sZW5ndGggPiA2NCkge1xuICAgICAgICBjb25zdCBoID0gaS50eXBlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1dHRvbiB0ZXh0IHdpdGggdHlwZSBcIiR7aH1cIiBoYXMgaW5jb3JyZWN0IHNpemU6ICR7aS50ZXh0Lmxlbmd0aH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLmksIHRleHQ6IGEsIGlkOiBvIH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmksIGlkOiBvIH07XG4gIH0pIDogciA9IFt7IHR5cGU6IFwiY2xvc2VcIiwgaWQ6IFwiXCIgfV0sIHsgdGl0bGU6IHMsIG1lc3NhZ2U6IHQsIGJ1dHRvbnM6IHIgfTtcbn1cbmNsYXNzIGdzIGV4dGVuZHMgJCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih7IGlzT3BlbmVkOiB0IH0sIHMsIHsgb3BlbjogXCJ3ZWJfYXBwX29wZW5fcG9wdXBcIiB9KSwgdGhpcy5wb3N0RXZlbnQgPSBuO1xuICB9XG4gIHNldCBpc09wZW5lZCh0KSB7XG4gICAgdGhpcy5zZXQoXCJpc09wZW5lZFwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgUG9wdXAgaXMgb3BlbmVkLlxuICAgKi9cbiAgZ2V0IGlzT3BlbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzT3BlbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IHNob3dzIGEgbmF0aXZlIHBvcHVwIGRlc2NyaWJlZCBieSB0aGUgYHBhcmFtc2AgYXJndW1lbnQuXG4gICAqIFByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aGVuIHBvcHVwIGlzIGNsb3NlZC4gUmVzb2x2ZWQgdmFsdWUgd2lsbCBoYXZlXG4gICAqIGFuIGlkZW50aWZpZXIgb2YgcHJlc3NlZCBidXR0b24uXG4gICAqXG4gICAqIEluIGNhc2UsIHVzZXIgY2xpY2tlZCBvdXRzaWRlIHRoZSBwb3B1cCBvciBjbGlja2VkIHRvcCByaWdodCBwb3B1cCBjbG9zZVxuICAgKiBidXR0b24sIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBwb3B1cCBwYXJhbWV0ZXJzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gUG9wdXAgaXMgYWxyZWFkeSBvcGVuZWQuXG4gICAqL1xuICBhc3luYyBvcGVuKHQpIHtcbiAgICBpZiAodGhpcy5pc09wZW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvcHVwIGlzIGFscmVhZHkgb3BlbmVkLlwiKTtcbiAgICB0aGlzLmlzT3BlbmVkID0gITA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgYnV0dG9uX2lkOiBzID0gbnVsbCB9ID0gYXdhaXQgZyh7XG4gICAgICAgIGV2ZW50OiBcInBvcHVwX2Nsb3NlZFwiLFxuICAgICAgICBtZXRob2Q6IFwid2ViX2FwcF9vcGVuX3BvcHVwXCIsXG4gICAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICAgIHBhcmFtczogX3ModClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaXNPcGVuZWQgPSAhMTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHdzID0gbChcbiAgKHsgcG9zdEV2ZW50OiBlLCB2ZXJzaW9uOiB0IH0pID0+IG5ldyBncyghMSwgdCwgZSlcbik7XG5jbGFzcyBmcyBleHRlbmRzICQge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgc3VwZXIoeyBpc09wZW5lZDogdCB9LCBzLCB7XG4gICAgICBjbG9zZTogXCJ3ZWJfYXBwX2Nsb3NlX3NjYW5fcXJfcG9wdXBcIixcbiAgICAgIG9wZW46IFwid2ViX2FwcF9vcGVuX3NjYW5fcXJfcG9wdXBcIlxuICAgIH0pLCB0aGlzLnBvc3RFdmVudCA9IG47XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgc2Nhbm5lci5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9jbG9zZV9zY2FuX3FyX3BvcHVwXCIpLCB0aGlzLmlzT3BlbmVkID0gITE7XG4gIH1cbiAgc2V0IGlzT3BlbmVkKHQpIHtcbiAgICB0aGlzLnNldChcImlzT3BlbmVkXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNjYW5uZXIgaXMgY3VycmVudGx5IG9wZW5lZC5cbiAgICovXG4gIGdldCBpc09wZW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc09wZW5lZFwiKTtcbiAgfVxuICBhc3luYyBvcGVuKHQpIHtcbiAgICBpZiAodGhpcy5pc09wZW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzY2FubmVyIGlzIGFscmVhZHkgb3BlbmVkXCIpO1xuICAgIGNvbnN0IHsgdGV4dDogcywgY2FwdHVyZTogbiB9ID0gKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB7IHRleHQ6IHQgfSA6IHQpIHx8IHt9O1xuICAgIHRoaXMuaXNPcGVuZWQgPSAhMDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgciA9IChhd2FpdCBnKHtcbiAgICAgICAgbWV0aG9kOiBcIndlYl9hcHBfb3Blbl9zY2FuX3FyX3BvcHVwXCIsXG4gICAgICAgIGV2ZW50OiBbXCJxcl90ZXh0X3JlY2VpdmVkXCIsIFwic2Nhbl9xcl9wb3B1cF9jbG9zZWRcIl0sXG4gICAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICAgIHBhcmFtczogeyB0ZXh0OiBzIH0sXG4gICAgICAgIGNhcHR1cmUoaSkge1xuICAgICAgICAgIHJldHVybiBpLmV2ZW50ID09PSBcInNjYW5fcXJfcG9wdXBfY2xvc2VkXCIgfHwgIW4gfHwgbihpLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9KSB8fCB7fSkuZGF0YSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHIgJiYgdGhpcy5jbG9zZSgpLCByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzT3BlbmVkID0gITE7XG4gICAgfVxuICB9XG4gIC8vIFRPRE86IFN0cmVhbWluZyBtb2RlLCBhbGxvd2luZyB0byBzY2FuIHNldmVyYWwgUVJzIHVudGlsIGNsb3NlZC5cbn1cbmNvbnN0IG1zID0gbChcbiAgKHsgdmVyc2lvbjogZSwgcG9zdEV2ZW50OiB0IH0pID0+IG5ldyBmcyghMSwgZSwgdClcbik7XG5jbGFzcyBicyBleHRlbmRzIHB0IHtcbiAgY29uc3RydWN0b3IodCwgcywgbikge1xuICAgIHN1cGVyKHsgaXNWaXNpYmxlOiB0IH0sIHMsIHtcbiAgICAgIHNob3c6IFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIixcbiAgICAgIGhpZGU6IFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIlxuICAgIH0pLCBjKHRoaXMsIFwib25cIiwgKHIsIGkpID0+IHIgPT09IFwiY2xpY2tcIiA/IHkoXCJzZXR0aW5nc19idXR0b25fcHJlc3NlZFwiLCBpKSA6IHRoaXMuc3RhdGUub24ociwgaSkpLCBjKHRoaXMsIFwib2ZmXCIsIChyLCBpKSA9PiByID09PSBcImNsaWNrXCIgPyB6KFwic2V0dGluZ3NfYnV0dG9uX3ByZXNzZWRcIiwgaSkgOiB0aGlzLnN0YXRlLm9mZihyLCBpKSksIHRoaXMucG9zdEV2ZW50ID0gbjtcbiAgfVxuICBzZXQgaXNWaXNpYmxlKHQpIHtcbiAgICB0aGlzLnNldChcImlzVmlzaWJsZVwiLCB0KSwgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldHVwX3NldHRpbmdzX2J1dHRvblwiLCB7IGlzX3Zpc2libGU6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIFNldHRpbmdzQnV0dG9uIGlzIHZpc2libGUuXG4gICAqL1xuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzVmlzaWJsZVwiKTtcbiAgfVxuICAvKipcbiAgICogSGlkZXMgdGhlIFNldHRpbmdzQnV0dG9uLlxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmlzVmlzaWJsZSA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgU2V0dGluZ3NCdXR0b24uXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMuaXNWaXNpYmxlID0gITA7XG4gIH1cbn1cbmNvbnN0IHZzID0gbChcbiAgXCJzZXR0aW5nc0J1dHRvblwiLFxuICAoe1xuICAgIHZlcnNpb246IGUsXG4gICAgcG9zdEV2ZW50OiB0LFxuICAgIHN0YXRlOiBzID0geyBpc1Zpc2libGU6ICExIH1cbiAgfSkgPT4gbmV3IGJzKHMuaXNWaXNpYmxlLCBlLCB0KVxuKTtcbmZ1bmN0aW9uIFp0KGUpIHtcbiAgcmV0dXJuIEh0KCkucGFyc2UoZSk7XG59XG5jbGFzcyB5cyBleHRlbmRzIGR0IHtcbiAgLyoqXG4gICAqIEBzaW5jZSB2Ni4xMFxuICAgKi9cbiAgZ2V0IGFjY2VudFRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJhY2NlbnRUZXh0Q29sb3JcIik7XG4gIH1cbiAgZ2V0IGJnQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYmdDb2xvclwiKTtcbiAgfVxuICBnZXQgYnV0dG9uQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYnV0dG9uQ29sb3JcIik7XG4gIH1cbiAgZ2V0IGJ1dHRvblRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJidXR0b25UZXh0Q29sb3JcIik7XG4gIH1cbiAgZ2V0IGRlc3RydWN0aXZlVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImRlc3RydWN0aXZlVGV4dENvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgY3VycmVudCBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqL1xuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBoZWFkZXJCZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImhlYWRlckJnQ29sb3JcIik7XG4gIH1cbiAgZ2V0IGhpbnRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJoaW50Q29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRydWUgaW4gY2FzZSwgY3VycmVudCBjb2xvciBzY2hlbWUgaXMgcmVjb2duaXplZCBhcyBkYXJrLiBUaGlzXG4gICAqIHZhbHVlIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZW1lIGJnIGNvbG9yLlxuICAgKi9cbiAgZ2V0IGlzRGFyaygpIHtcbiAgICByZXR1cm4gIXRoaXMuYmdDb2xvciB8fCBCdCh0aGlzLmJnQ29sb3IpO1xuICB9XG4gIGdldCBsaW5rQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwibGlua0NvbG9yXCIpO1xuICB9XG4gIGdldCBzZWNvbmRhcnlCZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNlY29uZGFyeUJnQ29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSB2Ni4xMFxuICAgKi9cbiAgZ2V0IHNlY3Rpb25CZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNlY3Rpb25CZ0NvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBzZWN0aW9uSGVhZGVyVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNlY3Rpb25IZWFkZXJUZXh0Q29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSB2Ny42XG4gICAqL1xuICBnZXQgc2VjdGlvblNlcGFyYXRvckNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNlY3Rpb25IZWFkZXJUZXh0Q29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyBsaXN0ZW5pbmcgdG8gdGhlIGV4dGVybmFsIHRoZW1lIGNoYW5nZXMgYW5kIGFwcGxpZXMgdGhlbS5cbiAgICogQHJldHVybnMgRnVuY3Rpb24gdG8gc3RvcCBsaXN0ZW5pbmcuXG4gICAqL1xuICBsaXN0ZW4oKSB7XG4gICAgcmV0dXJuIHkoXCJ0aGVtZV9jaGFuZ2VkXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLnNldChadCh0LnRoZW1lX3BhcmFtcykpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBzdWJ0aXRsZVRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzdWJ0aXRsZVRleHRDb2xvclwiKTtcbiAgfVxuICBnZXQgdGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRleHRDb2xvclwiKTtcbiAgfVxufVxuY29uc3QgRXMgPSBsKFxuICBcInRoZW1lUGFyYW1zXCIsXG4gICh7IHRoZW1lUGFyYW1zOiBlLCBzdGF0ZTogdCA9IGUsIGFkZENsZWFudXA6IHMgfSkgPT4ge1xuICAgIGNvbnN0IG4gPSBuZXcgeXModCk7XG4gICAgcmV0dXJuIHMobi5saXN0ZW4oKSksIG47XG4gIH1cbik7XG5mdW5jdGlvbiBibihlID0ge30pIHtcbiAgcmV0dXJuIGcoe1xuICAgIC4uLmUsXG4gICAgbWV0aG9kOiBcIndlYl9hcHBfcmVxdWVzdF90aGVtZVwiLFxuICAgIGV2ZW50OiBcInRoZW1lX2NoYW5nZWRcIlxuICB9KS50aGVuKFp0KTtcbn1cbmZ1bmN0aW9uIEIoZSwgdCkge1xuICByZXR1cm4gZS5zdGFydHNXaXRoKHQpID8gZSA6IGAke3R9JHtlfWA7XG59XG5mdW5jdGlvbiBNKGUpIHtcbiAgcmV0dXJuIG5ldyBVUkwoXG4gICAgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBgJHtlLnBhdGhuYW1lIHx8IFwiXCJ9JHtCKGUuc2VhcmNoIHx8IFwiXCIsIFwiP1wiKX0ke0IoZS5oYXNoIHx8IFwiXCIsIFwiI1wiKX1gLFxuICAgIFwiaHR0cDovL2FcIlxuICApO1xufVxuY2xhc3MgUHMgZXh0ZW5kcyBfdCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih0LCB7IHJlYWRUZXh0RnJvbUNsaXBib2FyZDogXCJ3ZWJfYXBwX3JlYWRfdGV4dF9mcm9tX2NsaXBib2FyZFwiIH0pLCBjKHRoaXMsIFwic3VwcG9ydHNQYXJhbVwiKSwgdGhpcy52ZXJzaW9uID0gdCwgdGhpcy5jcmVhdGVSZXF1ZXN0SWQgPSBzLCB0aGlzLnBvc3RFdmVudCA9IG4sIHRoaXMuc3VwcG9ydHNQYXJhbSA9IFl0KHQsIHtcbiAgICAgIFwib3BlbkxpbmsudHJ5SW5zdGFudFZpZXdcIjogW1wid2ViX2FwcF9vcGVuX2xpbmtcIiwgXCJ0cnlfaW5zdGFudF92aWV3XCJdXG4gICAgfSk7XG4gIH1cbiAgb3BlbkxpbmsodCwgcykge1xuICAgIGNvbnN0IG4gPSBNKHQpLnRvU3RyaW5nKCk7XG4gICAgaWYgKCFDKFwid2ViX2FwcF9vcGVuX2xpbmtcIiwgdGhpcy52ZXJzaW9uKSkge1xuICAgICAgd2luZG93Lm9wZW4obiwgXCJfYmxhbmtcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHIgPSB0eXBlb2YgcyA9PSBcImJvb2xlYW5cIiA/IHsgdHJ5SW5zdGFudFZpZXc6IHMgfSA6IHMgfHwge307XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX29wZW5fbGlua1wiLCB7XG4gICAgICB1cmw6IG4sXG4gICAgICB0cnlfYnJvd3Nlcjogci50cnlCcm93c2VyLFxuICAgICAgdHJ5X2luc3RhbnRfdmlldzogci50cnlJbnN0YW50Vmlld1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyBhIFRlbGVncmFtIGxpbmsgaW5zaWRlIFRlbGVncmFtIGFwcC4gVGhlIE1pbmkgQXBwIHdpbGwgYmUgY2xvc2VkLiBJdCBleHBlY3RzIHBhc3NpbmdcbiAgICogbGluayBpbiBmdWxsIGZvcm1hdCwgd2l0aCBob3N0bmFtZSBcInQubWVcIi5cbiAgICogQHBhcmFtIHVybCAtIFVSTCB0byBiZSBvcGVuZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBVUkwgaGFzIG5vdCBhbGxvd2VkIGhvc3RuYW1lLlxuICAgKi9cbiAgb3BlblRlbGVncmFtTGluayh0KSB7XG4gICAgY29uc3QgeyBob3N0bmFtZTogcywgcGF0aG5hbWU6IG4sIHNlYXJjaDogciB9ID0gbmV3IFVSTCh0LCBcImh0dHBzOi8vdC5tZVwiKTtcbiAgICBpZiAocyAhPT0gXCJ0Lm1lXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVSTCBoYXMgbm90IGFsbG93ZWQgaG9zdG5hbWU6ICR7c30uIE9ubHkgXCJ0Lm1lXCIgaXMgYWxsb3dlZGApO1xuICAgIGlmICghQyhcIndlYl9hcHBfb3Blbl90Z19saW5rXCIsIHRoaXMudmVyc2lvbikpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX29wZW5fdGdfbGlua1wiLCB7IHBhdGhfZnVsbDogbiArIHIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIHRleHQgZnJvbSBjbGlwYm9hcmQgYW5kIHJldHVybnMgc3RyaW5nIG9yIG51bGwuIG51bGwgaXMgcmV0dXJuZWRcbiAgICogaW4gY2FzZXM6XG4gICAqIC0gVmFsdWUgaW4gY2xpcGJvYXJkIGlzIG5vdCB0ZXh0XG4gICAqIC0gQWNjZXNzIHRvIGNsaXBib2FyZCBpcyBub3QgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgcmVhZFRleHRGcm9tQ2xpcGJvYXJkKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLCB7XG4gICAgICBkYXRhOiBzID0gbnVsbFxuICAgIH0gPSBhd2FpdCBnKHtcbiAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX3JlYWRfdGV4dF9mcm9tX2NsaXBib2FyZFwiLFxuICAgICAgZXZlbnQ6IFwiY2xpcGJvYXJkX3RleHRfcmVjZWl2ZWRcIixcbiAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICBwYXJhbXM6IHsgcmVxX2lkOiB0IH0sXG4gICAgICBjYXB0dXJlOiBxdCh0KVxuICAgIH0pO1xuICAgIHJldHVybiBzO1xuICB9XG4gIC8qKlxuICAgKiBTaGFyZXMgc3BlY2lmaWVkIFVSTCB3aXRoIHRoZSBwYXNzZWQgdG8gdGhlIGNoYXRzLCBzZWxlY3RlZCBieSB1c2VyLiBBZnRlciBiZWluZyBjYWxsZWQsXG4gICAqIGl0IGNsb3NlcyB0aGUgbWluaSBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgdXNlcyBUZWxlZ3JhbSdzIFNoYXJlIExpbmtzLlxuICAgKiBAcGFyYW0gdXJsIC0gVVJMIHRvIHNoYXJlLlxuICAgKiBAcGFyYW0gdGV4dCAtIHRleHQgdG8gYXBwZW5kIGFmdGVyIHRoZSBVUkwuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9hcGkvbGlua3Mjc2hhcmUtbGlua3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL3dpZGdldHMvc2hhcmUjY3VzdG9tLWJ1dHRvbnNcbiAgICovXG4gIHNoYXJlVVJMKHQsIHMpIHtcbiAgICB0aGlzLm9wZW5UZWxlZ3JhbUxpbmsoXG4gICAgICBcImh0dHBzOi8vdC5tZS9zaGFyZS91cmw/XCIgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgdXJsOiB0LCB0ZXh0OiBzIHx8IFwiXCIgfSkudG9TdHJpbmcoKS5yZXBsYWNlKC9cXCsvZywgXCIlMjBcIilcbiAgICApO1xuICB9XG59XG5jb25zdCBScyA9IGwoXG4gICh7IHZlcnNpb246IGUsIHBvc3RFdmVudDogdCwgY3JlYXRlUmVxdWVzdElkOiBzIH0pID0+IG5ldyBQcyhlLCBzLCB0KVxuKTtcbmFzeW5jIGZ1bmN0aW9uIFh0KGUgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaXNfZXhwYW5kZWQ6IHQsXG4gICAgaXNfc3RhdGVfc3RhYmxlOiBzLFxuICAgIC4uLm5cbiAgfSA9IGF3YWl0IGcoe1xuICAgIC4uLmUsXG4gICAgbWV0aG9kOiBcIndlYl9hcHBfcmVxdWVzdF92aWV3cG9ydFwiLFxuICAgIGV2ZW50OiBcInZpZXdwb3J0X2NoYW5nZWRcIlxuICB9KTtcbiAgcmV0dXJuIHsgLi4ubiwgaXNFeHBhbmRlZDogdCwgaXNTdGF0ZVN0YWJsZTogcyB9O1xufVxuZnVuY3Rpb24gTyhlKSB7XG4gIHJldHVybiBlIDwgMCA/IDAgOiBlO1xufVxuY2xhc3MgeHMgZXh0ZW5kcyBkdCB7XG4gIGNvbnN0cnVjdG9yKHsgcG9zdEV2ZW50OiB0LCBzdGFibGVIZWlnaHQ6IHMsIGhlaWdodDogbiwgd2lkdGg6IHIsIGlzRXhwYW5kZWQ6IGkgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGhlaWdodDogTyhuKSxcbiAgICAgIGlzRXhwYW5kZWQ6IGksXG4gICAgICBzdGFibGVIZWlnaHQ6IE8ocyksXG4gICAgICB3aWR0aDogTyhyKVxuICAgIH0pLCBjKHRoaXMsIFwicG9zdEV2ZW50XCIpLCB0aGlzLnBvc3RFdmVudCA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHZpZXdwb3J0IGluZm9ybWF0aW9uIGZyb20gdGhlIFRlbGVncmFtIGFwcGxpY2F0aW9uIGFuZCB1cGRhdGVzIGN1cnJlbnQgVmlld3BvcnRcbiAgICogaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyB0byByZXF1ZXN0IGZyZXNoIGRhdGEuXG4gICAqL1xuICBhc3luYyBzeW5jKHQpIHtcbiAgICBjb25zdCB7IGlzU3RhdGVTdGFibGU6IHMsIC4uLm4gfSA9IGF3YWl0IFh0KHQpO1xuICAgIHRoaXMuc2V0KHtcbiAgICAgIC4uLm4sXG4gICAgICBzdGFibGVIZWlnaHQ6IHMgPyBuLmhlaWdodCA6IHRoaXMuZ2V0KFwic3RhYmxlSGVpZ2h0XCIpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgKip2aXNpYmxlIGFyZWEqKiBvZiB0aGUgTWluaSBBcHAuXG4gICAqXG4gICAqIFRoZSBhcHBsaWNhdGlvbiBjYW4gZGlzcGxheSBqdXN0IHRoZSB0b3AgcGFydCBvZiB0aGUgTWluaSBBcHAsIHdpdGggaXRzIGxvd2VyIHBhcnQgcmVtYWluaW5nXG4gICAqIG91dHNpZGUgdGhlIHNjcmVlbiBhcmVhLiBGcm9tIHRoaXMgcG9zaXRpb24sIHRoZSB1c2VyIGNhbiBcInB1bGxcIiB0aGUgTWluaSBBcHAgdG8gaXRzXG4gICAqIG1heGltdW0gaGVpZ2h0LCB3aGlsZSB0aGUgYm90IGNhbiBkbyB0aGUgc2FtZSBieSBjYWxsaW5nIGBleHBhbmRgIG1ldGhvZC4gQXMgdGhlIHBvc2l0aW9uIG9mXG4gICAqIHRoZSBNaW5pIEFwcCBjaGFuZ2VzLCB0aGUgY3VycmVudCBoZWlnaHQgdmFsdWUgb2YgdGhlIHZpc2libGUgYXJlYSB3aWxsIGJlIHVwZGF0ZWQgIGluIHJlYWxcbiAgICogdGltZS5cbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGUgcmVmcmVzaCByYXRlIG9mIHRoaXMgdmFsdWUgaXMgbm90IHN1ZmZpY2llbnQgdG8gc21vb3RobHkgZm9sbG93IHRoZVxuICAgKiBsb3dlciBib3JkZXIgb2YgdGhlIHdpbmRvdy4gSXQgc2hvdWxkIG5vdCBiZSB1c2VkIHRvIHBpbiBpbnRlcmZhY2UgZWxlbWVudHMgdG8gdGhlIGJvdHRvbVxuICAgKiBvZiB0aGUgdmlzaWJsZSBhcmVhLiBJdCdzIG1vcmUgYXBwcm9wcmlhdGUgdG8gdXNlIHRoZSB2YWx1ZSBvZiB0aGUgYHN0YWJsZUhlaWdodGBcbiAgICogZmllbGQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICpcbiAgICogQHNlZSBzdGFibGVIZWlnaHRcbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaGVpZ2h0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSB2aXNpYmxlIGFyZWEgb2YgdGhlIE1pbmkgQXBwIGluIGl0cyBsYXN0IHN0YWJsZSBzdGF0ZS5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIGNhbiBkaXNwbGF5IGp1c3QgdGhlIHRvcCBwYXJ0IG9mIHRoZSBNaW5pIEFwcCwgd2l0aCBpdHMgbG93ZXIgcGFydCByZW1haW5pbmdcbiAgICogb3V0c2lkZSB0aGUgc2NyZWVuIGFyZWEuIEZyb20gdGhpcyBwb3NpdGlvbiwgdGhlIHVzZXIgY2FuIFwicHVsbFwiIHRoZSBNaW5pIEFwcCB0byBpdHNcbiAgICogbWF4aW11bSBoZWlnaHQsIHdoaWxlIHRoZSBhcHBsaWNhdGlvbiBjYW4gZG8gdGhlIHNhbWUgYnkgY2FsbGluZyBgZXhwYW5kYCBtZXRob2QuXG4gICAqXG4gICAqIFVubGlrZSB0aGUgdmFsdWUgb2YgYGhlaWdodGAsIHRoZSB2YWx1ZSBvZiBgc3RhYmxlSGVpZ2h0YCBkb2VzIG5vdCBjaGFuZ2UgYXMgdGhlIHBvc2l0aW9uXG4gICAqIG9mIHRoZSBNaW5pIEFwcCBjaGFuZ2VzIHdpdGggdXNlciBnZXN0dXJlcyBvciBkdXJpbmcgYW5pbWF0aW9ucy4gVGhlIHZhbHVlIG9mIGBzdGFibGVIZWlnaHRgXG4gICAqIHdpbGwgYmUgdXBkYXRlZCBhZnRlciBhbGwgZ2VzdHVyZXMgYW5kIGFuaW1hdGlvbnMgYXJlIGNvbXBsZXRlZCBhbmRcbiAgICogdGhlIE1pbmkgQXBwIHJlYWNoZXMgaXRzIGZpbmFsIHNpemUuXG4gICAqXG4gICAqIEBzZWUgaGVpZ2h0XG4gICAqL1xuICBnZXQgc3RhYmxlSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInN0YWJsZUhlaWdodFwiKTtcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIGxpc3RlbmluZyB0byB2aWV3cG9ydCBjaGFuZ2VzIGFuZCBhcHBsaWVzIHRoZW0uXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRvIHN0b3AgbGlzdGVuaW5nLlxuICAgKi9cbiAgbGlzdGVuKCkge1xuICAgIHJldHVybiB5KFwidmlld3BvcnRfY2hhbmdlZFwiLCAodCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBoZWlnaHQ6IHMsXG4gICAgICAgIHdpZHRoOiBuLFxuICAgICAgICBpc19leHBhbmRlZDogcixcbiAgICAgICAgaXNfc3RhdGVfc3RhYmxlOiBpXG4gICAgICB9ID0gdCwgbyA9IE8ocyk7XG4gICAgICB0aGlzLnNldCh7XG4gICAgICAgIGhlaWdodDogbyxcbiAgICAgICAgaXNFeHBhbmRlZDogcixcbiAgICAgICAgd2lkdGg6IE8obiksXG4gICAgICAgIC4uLmkgPyB7IHN0YWJsZUhlaWdodDogbyB9IDoge31cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBNaW5pIEFwcCBpcyBleHBhbmRlZCB0byB0aGUgbWF4aW11bSBhdmFpbGFibGUgaGVpZ2h0LiBPdGhlcndpc2UsIGlmXG4gICAqIHRoZSBNaW5pIEFwcCBvY2N1cGllcyBwYXJ0IG9mIHRoZSBzY3JlZW4gYW5kIGNhbiBiZSBleHBhbmRlZCB0byB0aGUgZnVsbCBoZWlnaHQgdXNpbmdcbiAgICogYGV4cGFuZGAgbWV0aG9kLlxuICAgKiBAc2VlIGV4cGFuZFxuICAgKi9cbiAgZ2V0IGlzRXhwYW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaXNFeHBhbmRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCB2aXNpYmxlIGFyZWEgd2lkdGguXG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwid2lkdGhcIik7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRoYXQgZXhwYW5kcyB0aGUgTWluaSBBcHAgdG8gdGhlIG1heGltdW0gYXZhaWxhYmxlIGhlaWdodC4gVG8gZmluZCBvdXQgaWYgdGhlIE1pbmlcbiAgICogQXBwIGlzIGV4cGFuZGVkIHRvIHRoZSBtYXhpbXVtIGhlaWdodCwgcmVmZXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBgaXNFeHBhbmRlZGAuXG4gICAqIEBzZWUgaXNFeHBhbmRlZFxuICAgKi9cbiAgZXhwYW5kKCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9leHBhbmRcIiksIHRoaXMuc2V0KFwiaXNFeHBhbmRlZFwiLCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIGN1cnJlbnQgdmlld3BvcnQgaGVpZ2h0IGlzIHN0YWJsZSBhbmQgaXMgbm90IGdvaW5nIHRvIGNoYW5nZSBpbiB0aGUgbmV4dCBtb21lbnQuXG4gICAqL1xuICBnZXQgaXNTdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhYmxlSGVpZ2h0ID09PSB0aGlzLmhlaWdodDtcbiAgfVxufVxuY29uc3QgQ3MgPSBsKFxuICBcInZpZXdwb3J0XCIsXG4gIGFzeW5jICh7IHN0YXRlOiBlLCBwbGF0Zm9ybTogdCwgcG9zdEV2ZW50OiBzLCBhZGRDbGVhbnVwOiBuIH0pID0+IHtcbiAgICBsZXQgciA9ICExLCBpID0gMCwgbyA9IDAsIGEgPSAwO1xuICAgIGlmIChlKVxuICAgICAgciA9IGUuaXNFeHBhbmRlZCwgaSA9IGUuaGVpZ2h0LCBvID0gZS53aWR0aCwgYSA9IGUuc3RhYmxlSGVpZ2h0O1xuICAgIGVsc2UgaWYgKFtcIm1hY29zXCIsIFwidGRlc2t0b3BcIiwgXCJ1bmlncmFtXCIsIFwid2Via1wiLCBcIndlYmFcIiwgXCJ3ZWJcIl0uaW5jbHVkZXModCkpXG4gICAgICByID0gITAsIGkgPSB3aW5kb3cuaW5uZXJIZWlnaHQsIG8gPSB3aW5kb3cuaW5uZXJXaWR0aCwgYSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHAgPSBhd2FpdCBYdCh7IHRpbWVvdXQ6IDFlMywgcG9zdEV2ZW50OiBzIH0pO1xuICAgICAgciA9IHAuaXNFeHBhbmRlZCwgaSA9IHAuaGVpZ2h0LCBvID0gcC53aWR0aCwgYSA9IHAuaXNTdGF0ZVN0YWJsZSA/IGkgOiAwO1xuICAgIH1cbiAgICBjb25zdCBoID0gbmV3IHhzKHtcbiAgICAgIHBvc3RFdmVudDogcyxcbiAgICAgIGhlaWdodDogaSxcbiAgICAgIHdpZHRoOiBvLFxuICAgICAgc3RhYmxlSGVpZ2h0OiBhLFxuICAgICAgaXNFeHBhbmRlZDogclxuICAgIH0pO1xuICAgIHJldHVybiBuKGgubGlzdGVuKCkpLCBoO1xuICB9XG4pO1xuZnVuY3Rpb24gUChlLCB0KSB7XG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShlLCB0KTtcbn1cbmZ1bmN0aW9uIHZuKGUsIHQsIHMpIHtcbiAgcyB8fCAocyA9IChhKSA9PiBgLS10Zy0ke2F9LWNvbG9yYCk7XG4gIGNvbnN0IG4gPSBzKFwiaGVhZGVyXCIpLCByID0gcyhcImJnXCIpLCBpID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgaGVhZGVyQ29sb3I6IGEgfSA9IGU7XG4gICAgaWYgKGN0KGEpKVxuICAgICAgUChuLCBhKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHsgYmdDb2xvcjogaCwgc2Vjb25kYXJ5QmdDb2xvcjogcCB9ID0gdDtcbiAgICAgIGEgPT09IFwiYmdfY29sb3JcIiAmJiBoID8gUChuLCBoKSA6IGEgPT09IFwic2Vjb25kYXJ5X2JnX2NvbG9yXCIgJiYgcCAmJiBQKG4sIHApO1xuICAgIH1cbiAgICBQKHIsIGUuYmdDb2xvcik7XG4gIH0sIG8gPSBbXG4gICAgdC5vbihcImNoYW5nZVwiLCBpKSxcbiAgICBlLm9uKFwiY2hhbmdlXCIsIGkpXG4gIF07XG4gIHJldHVybiBpKCksICgpID0+IG8uZm9yRWFjaCgoYSkgPT4gYSgpKTtcbn1cbmZ1bmN0aW9uIHluKGUsIHQpIHtcbiAgdCB8fCAodCA9IChuKSA9PiBgLS10Zy10aGVtZS0ke24ucmVwbGFjZSgvW0EtWl0vZywgKHIpID0+IGAtJHtyLnRvTG93ZXJDYXNlKCl9YCl9YCk7XG4gIGNvbnN0IHMgPSAoKSA9PiB7XG4gICAgT2JqZWN0LmVudHJpZXMoZS5nZXRTdGF0ZSgpKS5mb3JFYWNoKChbbiwgcl0pID0+IHtcbiAgICAgIHIgJiYgUCh0KG4pLCByKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHMoKSwgZS5vbihcImNoYW5nZVwiLCBzKTtcbn1cbmZ1bmN0aW9uIEVuKGUsIHQpIHtcbiAgdCB8fCAodCA9IChwKSA9PiBgLS10Zy12aWV3cG9ydC0ke3B9YCk7XG4gIGNvbnN0IFtcbiAgICBzLFxuICAgIG4sXG4gICAgclxuICBdID0gW1wiaGVpZ2h0XCIsIFwid2lkdGhcIiwgXCJzdGFibGUtaGVpZ2h0XCJdLm1hcCgocCkgPT4gdChwKSksIGkgPSAoKSA9PiBQKHMsIGAke2UuaGVpZ2h0fXB4YCksIG8gPSAoKSA9PiBQKG4sIGAke2Uud2lkdGh9cHhgKSwgYSA9ICgpID0+IFAociwgYCR7ZS5zdGFibGVIZWlnaHR9cHhgKSwgaCA9IFtcbiAgICBlLm9uKFwiY2hhbmdlOmhlaWdodFwiLCBpKSxcbiAgICBlLm9uKFwiY2hhbmdlOndpZHRoXCIsIG8pLFxuICAgIGUub24oXCJjaGFuZ2U6c3RhYmxlSGVpZ2h0XCIsIGEpXG4gIF07XG4gIHJldHVybiBpKCksIG8oKSwgYSgpLCAoKSA9PiBoLmZvckVhY2goKHApID0+IHAoKSk7XG59XG5mdW5jdGlvbiBTcyhlID0gITApIHtcbiAgY29uc3QgdCA9IFtcbiAgICB5KFwicmVsb2FkX2lmcmFtZVwiLCAoKSA9PiB7XG4gICAgICBWKFwiaWZyYW1lX3dpbGxfcmVsb2FkXCIpLCB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfSlcbiAgXSwgcyA9ICgpID0+IHQuZm9yRWFjaCgobikgPT4gbigpKTtcbiAgaWYgKGUpIHtcbiAgICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIG4uaWQgPSBcInRlbGVncmFtLWN1c3RvbS1zdHlsZXNcIiwgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChuKSwgdC5wdXNoKFxuICAgICAgeShcInNldF9jdXN0b21fc3R5bGVcIiwgKHIpID0+IHtcbiAgICAgICAgbi5pbm5lckhUTUwgPSByO1xuICAgICAgfSksXG4gICAgICAoKSA9PiBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKG4pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gVihcImlmcmFtZV9yZWFkeVwiLCB7IHJlbG9hZF9zdXBwb3J0ZWQ6ICEwIH0pLCBzO1xufVxuZnVuY3Rpb24gVHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID4gXCJ1XCI7XG59XG5hc3luYyBmdW5jdGlvbiBQbigpIHtcbiAgaWYgKGt0KHdpbmRvdykpXG4gICAgcmV0dXJuICEwO1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBnKHsgbWV0aG9kOiBcIndlYl9hcHBfcmVxdWVzdF90aGVtZVwiLCBldmVudDogXCJ0aGVtZV9jaGFuZ2VkXCIsIHRpbWVvdXQ6IDEwMCB9KSwgITA7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gUm4oZSkge1xuICBjb25zdCB0ID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGx0KGUpIDogZTtcbiAgSnQodCk7XG4gIGZ1bmN0aW9uIHMocikge1xuICAgIGlmICh0eXBlb2YgciA9PSBcInN0cmluZ1wiKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBldmVudFR5cGU6IGkgfSA9IEF0KHIpO1xuICAgICAgICBpID09PSBcIndlYl9hcHBfcmVxdWVzdF90aGVtZVwiICYmIGV0KFwidGhlbWVfY2hhbmdlZFwiLCB7XG4gICAgICAgICAgdGhlbWVfcGFyYW1zOiBKU09OLnBhcnNlKEt0KHQudGhlbWVQYXJhbXMpKVxuICAgICAgICB9KSwgaSA9PT0gXCJ3ZWJfYXBwX3JlcXVlc3Rfdmlld3BvcnRcIiAmJiBldChcInZpZXdwb3J0X2NoYW5nZWRcIiwge1xuICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICBpc19zdGF0ZV9zdGFibGU6ICEwLFxuICAgICAgICAgIGlzX2V4cGFuZGVkOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICB9XG4gIGlmIChhdCgpKSB7XG4gICAgY29uc3QgciA9IHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UuYmluZCh3aW5kb3cucGFyZW50KTtcbiAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlID0gKGkpID0+IHtcbiAgICAgIHMoaSksIHIoaSk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEl0KHdpbmRvdykpIHtcbiAgICBjb25zdCByID0gd2luZG93LmV4dGVybmFsLm5vdGlmeS5iaW5kKHdpbmRvdy5leHRlcm5hbCk7XG4gICAgd2luZG93LmV4dGVybmFsLm5vdGlmeSA9IChpKSA9PiB7XG4gICAgICBzKGkpLCByKGkpO1xuICAgIH07XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG4gPSB3aW5kb3cuVGVsZWdyYW1XZWJ2aWV3UHJveHk7XG4gIHdpbmRvdy5UZWxlZ3JhbVdlYnZpZXdQcm94eSA9IHtcbiAgICAuLi5uIHx8IHt9LFxuICAgIHBvc3RFdmVudCguLi5yKSB7XG4gICAgICBzKEpTT04uc3RyaW5naWZ5KHsgZXZlbnRUeXBlOiByWzBdLCBldmVudERhdGE6IHJbMV0gfSkpLCBuICYmIG4ucG9zdEV2ZW50KC4uLnIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIEFzKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBXO1xufVxuZnVuY3Rpb24geG4oZSwgdCkge1xuICByZXR1cm4gQXMoZSkgJiYgZS50eXBlID09PSB0O1xufVxuZnVuY3Rpb24gSihlLCB0KSB7XG4gIGxldCBzLCBuLCByO1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHMgPSBlIDogKHMgPSBlLnBhdGhuYW1lID09PSB2b2lkIDAgPyB0IDogZS5wYXRobmFtZSwgbiA9IGUucGFyYW1zLCByID0gZS5pZCksIE9iamVjdC5mcmVlemUoe1xuICAgIGlkOiByIHx8IChNYXRoLnJhbmRvbSgpICogMiAqKiAxNCB8IDApLnRvU3RyaW5nKDE2KSxcbiAgICBwYXRobmFtZTogcyxcbiAgICBwYXJhbXM6IG5cbiAgfSk7XG59XG5jbGFzcyBJcyB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4gPSBWKSB7XG4gICAgaWYgKGModGhpcywgXCJoaXN0b3J5XCIpLCBjKHRoaXMsIFwiZWVcIiwgbmV3IEQoKSksIGModGhpcywgXCJhdHRhY2hlZFwiLCAhMSksIGModGhpcywgXCJiYWNrXCIsICgpID0+IHRoaXMuZ28oLTEpKSwgYyh0aGlzLCBcIm9uXCIsIHRoaXMuZWUub24uYmluZCh0aGlzLmVlKSksIGModGhpcywgXCJvZmZcIiwgdGhpcy5lZS5vZmYuYmluZCh0aGlzLmVlKSksIHRoaXMuX2luZGV4ID0gcywgdGhpcy5wb3N0RXZlbnQgPSBuLCB0Lmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG0oYmUsIFwiSGlzdG9yeSBzaG91bGQgbm90IGJlIGVtcHR5LlwiKTtcbiAgICBpZiAocyA8IDAgfHwgcyA+PSB0Lmxlbmd0aClcbiAgICAgIHRocm93IG0oXG4gICAgICAgIHZlLFxuICAgICAgICBcIkluZGV4IHNob3VsZCBub3QgYmUgemVybyBhbmQgaGlnaGVyIG9yIGVxdWFsIHRoYW4gaGlzdG9yeSBzaXplLlwiXG4gICAgICApO1xuICAgIHRoaXMuaGlzdG9yeSA9IHQubWFwKChyKSA9PiBKKHIsIFwiXCIpKTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHRoaXMgbmF2aWdhdG9yIHRvIGNvbnRyb2wgdGhlIGBCYWNrQnV0dG9uYCB2aXNpYmlsaXR5IHN0YXRlLiBJdCBhbHNvIHRyYWNrcyB0aGVcbiAgICogYEJhY2tCdXR0b25gIGNsaWNrcyBhbmQgY2FsbHMgdGhlIGBiYWNrYCBtZXRob2QuXG4gICAqL1xuICBhdHRhY2goKSB7XG4gICAgdGhpcy5hdHRhY2hlZCB8fCAodGhpcy5hdHRhY2hlZCA9ICEwLCB0aGlzLnN5bmMoKSwgeShcImJhY2tfYnV0dG9uX3ByZXNzZWRcIiwgdGhpcy5iYWNrKSk7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnRseSBhY3RpdmUgaGlzdG9yeSBpdGVtLlxuICAgKi9cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeVt0aGlzLmluZGV4XTtcbiAgfVxuICAvKipcbiAgICogUHJldmVudHMgY3VycmVudCBuYXZpZ2F0b3IgZnJvbSBjb250cm9sbGluZyB0aGUgQmFja0J1dHRvbiB2aXNpYmlsaXR5IHN0YXRlLlxuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuYXR0YWNoZWQgPSAhMSwgeihcImJhY2tfYnV0dG9uX3ByZXNzZWRcIiwgdGhpcy5iYWNrKTtcbiAgfVxuICAvKipcbiAgICogR29lcyB0byB0aGUgbmV4dCBoaXN0b3J5IGl0ZW0uXG4gICAqL1xuICBmb3J3YXJkKCkge1xuICAgIHRoaXMuZ28oMSk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgY3VycmVudGx5IGFjdGl2ZSBoaXN0b3J5IGl0ZW0gaW5kZXggYnkgdGhlIHNwZWNpZmllZCBkZWx0YS4gVGhpcyBtZXRob2QgZG9lc24ndFxuICAgKiBjaGFuZ2UgaW5kZXggaW4gY2FzZSwgdGhlIHVwZGF0ZWQgaW5kZXggcG9pbnRzIHRvIHRoZSBub24tZXhpc3RpbmcgaGlzdG9yeSBpdGVtLiBUaGlzIGJlaGF2aW9yXG4gICAqIGlzIHByZXNlcnZlZCB1bnRpbCB0aGUgYGZpdGAgYXJndW1lbnQgaXMgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0gZGVsdGEgLSBpbmRleCBkZWx0YS5cbiAgICogQHBhcmFtIGZpdCAtIGN1dHMgdGhlIGRlbHRhIGFyZ3VtZW50IHRvIGZpdCB0aGUgYm91bmRzIGBbMCwgaGlzdG9yeS5sZW5ndGggLSAxXWAuXG4gICAqL1xuICBnbyh0LCBzKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuaW5kZXggKyB0LCByID0gTWF0aC5taW4oXG4gICAgICBNYXRoLm1heCgwLCBuKSxcbiAgICAgIHRoaXMuaGlzdG9yeS5sZW5ndGggLSAxXG4gICAgKTtcbiAgICAobiA9PT0gciB8fCBzKSAmJiB0aGlzLnJlcGxhY2VBbmRNb3ZlKHIsIHRoaXMuaGlzdG9yeVtyXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdvZXMgdG8gdGhlIHNwZWNpZmllZCBpbmRleC4gTWV0aG9kIGRvZXMgbm90aGluZyBpbiBjYXNlLCBwYXNzZWQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICpcbiAgICogSWYgXCJmaXRcIiBvcHRpb24gd2FzIHNwZWNpZmllZCBhbmQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcywgaXQgd2lsbCBiZSBjdXQgdG8gdGhlIG5lYXJlc3RcbiAgICogYm91bmQuXG4gICAqIEBwYXJhbSBpbmRleCAtIHRhcmdldCBpbmRleC5cbiAgICogQHBhcmFtIGZpdCAtIGN1dHMgdGhlIGluZGV4IGFyZ3VtZW50IHRvIGZpdCB0aGUgYm91bmRzIGBbMCwgaGlzdG9yeS5sZW5ndGggLSAxXWAuXG4gICAqL1xuICBnb1RvKHQsIHMpIHtcbiAgICB0aGlzLmdvKHQgLSB0aGlzLmluZGV4LCBzKTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBuYXZpZ2F0b3IgaGFzIGl0ZW1zIGJlZm9yZSB0aGUgY3VycmVudCBpdGVtLlxuICAgKi9cbiAgZ2V0IGhhc1ByZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggPiAwO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIG5hdmlnYXRvciBoYXMgaXRlbXMgYWZ0ZXIgdGhlIGN1cnJlbnQgaXRlbS5cbiAgICovXG4gIGdldCBoYXNOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ICE9PSB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudGx5IGFjdGl2ZSBoaXN0b3J5IGl0ZW0gaW5kZXguXG4gICAqL1xuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGhpc3RvcnkgaXRlbSByZW1vdmluZyBhbGwgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gYWRkLlxuICAgKi9cbiAgcHVzaCh0KSB7XG4gICAgdGhpcy5oYXNOZXh0ICYmIHRoaXMuaGlzdG9yeS5zcGxpY2UodGhpcy5pbmRleCArIDEpLCB0aGlzLnJlcGxhY2VBbmRNb3ZlKHRoaXMuaW5kZXggKyAxLCBKKHQsIHRoaXMuY3VycmVudC5wYXRobmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBoaXN0b3J5IGl0ZW0uXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byByZXBsYWNlIHRoZSBjdXJyZW50IGl0ZW0gd2l0aC5cbiAgICovXG4gIHJlcGxhY2UodCkge1xuICAgIHRoaXMucmVwbGFjZUFuZE1vdmUodGhpcy5pbmRleCwgSih0LCB0aGlzLmN1cnJlbnQucGF0aG5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBoaXN0b3J5IGl0ZW0gYnkgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IC0gaGlzdG9yeSBpdGVtIGluZGV4IHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSBoaXN0b3J5SXRlbSAtIGhpc3RvcnkgaXRlbSB0byBzZXQuXG4gICAqL1xuICByZXBsYWNlQW5kTW92ZSh0LCBzKSB7XG4gICAgY29uc3QgbiA9IHQgLSB0aGlzLmluZGV4O1xuICAgIGlmICghbiAmJiB0aGlzLmN1cnJlbnQgPT09IHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gdCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2luZGV4O1xuICAgICAgdGhpcy5faW5kZXggPSB0LCB0aGlzLmF0dGFjaGVkICYmIGkgPiAwICE9IHQgPiAwICYmIHRoaXMuc3luYygpO1xuICAgIH1cbiAgICB0aGlzLmhpc3RvcnlbdF0gPSBzLCB0aGlzLmVlLmVtaXQoXCJjaGFuZ2VcIiwge1xuICAgICAgbmF2aWdhdG9yOiB0aGlzLFxuICAgICAgZnJvbTogcixcbiAgICAgIHRvOiB0aGlzLmN1cnJlbnQsXG4gICAgICBkZWx0YTogblxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBY3R1YWxpemVzIHRoZSBgQmFja0J1dHRvbmAgdmlzaWJpbGl0eSBzdGF0ZS5cbiAgICovXG4gIHN5bmMoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCIsIHsgaXNfdmlzaWJsZTogISF0aGlzLmluZGV4IH0pO1xuICB9XG59XG5mdW5jdGlvbiBGKHtcbiAgcGFyYW1zOiBlLFxuICAuLi50XG59KSB7XG4gIHJldHVybiB7IC4uLmUgfHwgeyBoYXNoOiBcIlwiLCBzZWFyY2g6IFwiXCIgfSwgLi4udCB9O1xufVxuZnVuY3Rpb24gVShlKSB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZS5zdGFydHNXaXRoKFwiL1wiKSA6ICEhKGUucGF0aG5hbWUgJiYgZS5wYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSksIHMgPSBNKGUpO1xuICByZXR1cm4gYCR7dCA/IHMucGF0aG5hbWUgOiBzLnBhdGhuYW1lLnNsaWNlKDEpfSR7cy5zZWFyY2h9JHtzLmhhc2h9YDtcbn1cbmZ1bmN0aW9uIFEoZSwgdCwgcykge1xuICBsZXQgbiwgcjtcbiAgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IG4gPSBlIDogKG4gPSBVKGUpLCBzID0gZS5zdGF0ZSwgciA9IGUuaWQpO1xuICBjb25zdCB7IHBhdGhuYW1lOiBpLCBzZWFyY2g6IG8sIGhhc2g6IGEgfSA9IG5ldyBVUkwobiwgYGh0dHA6Ly9hJHtCKHQsIFwiL1wiKX1gKTtcbiAgcmV0dXJuIHsgaWQ6IHIsIHBhdGhuYW1lOiBpLCBwYXJhbXM6IHsgaGFzaDogYSwgc2VhcmNoOiBvLCBzdGF0ZTogcyB9IH07XG59XG5hc3luYyBmdW5jdGlvbiBOKGUpIHtcbiAgcmV0dXJuIGUgPT09IDAgPyAhMCA6IFByb21pc2UucmFjZShbXG4gICAgbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0dChcInBvcHN0YXRlXCIsICgpID0+IHtcbiAgICAgICAgcygpLCB0KCEwKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93Lmhpc3RvcnkuZ28oZSk7XG4gICAgfSksXG4gICAgLy8gVXN1YWxseSwgaXQgdGFrZXMgYWJvdXQgMW1zIHRvIGVtaXQgdGhpcyBldmVudCwgYnV0IHdlIHVzZSBzb21lIGJ1ZmZlci5cbiAgICBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgc2V0VGltZW91dCh0LCA1MCwgITEpO1xuICAgIH0pXG4gIF0pO1xufVxuYXN5bmMgZnVuY3Rpb24ga3MoKSB7XG4gIGlmICh3aW5kb3cuaGlzdG9yeS5sZW5ndGggPD0gMSB8fCAod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIFwiXCIpLCBhd2FpdCBOKDEgLSB3aW5kb3cuaGlzdG9yeS5sZW5ndGgpKSlcbiAgICByZXR1cm47XG4gIGxldCBlID0gYXdhaXQgTigtMSk7XG4gIGZvciAoOyBlOyApXG4gICAgZSA9IGF3YWl0IE4oLTEpO1xufVxuZnVuY3Rpb24gdGUoZSkge1xuICByZXR1cm4gTShlKS5wYXRobmFtZTtcbn1cbmNvbnN0IEV0ID0gMCwgWSA9IDEsIFogPSAyO1xuY2xhc3MgZWUge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCB7IHBvc3RFdmVudDogbiwgaGFzaE1vZGU6IHIgPSBcImNsYXNzaWNcIiwgYmFzZTogaSB9ID0ge30pIHtcbiAgICBjKHRoaXMsIFwibmF2aWdhdG9yXCIpLCBjKHRoaXMsIFwiZWVcIiwgbmV3IEQoKSksIGModGhpcywgXCJoYXNoTW9kZVwiKSwgYyh0aGlzLCBcImJhc2VcIiksIGModGhpcywgXCJhdHRhY2hlZFwiLCAhMSksIGModGhpcywgXCJvblBvcFN0YXRlXCIsICh7IHN0YXRlOiBvIH0pID0+IHtcbiAgICAgIGlmIChvID09PSBudWxsKVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKHRoaXMucGFyc2VQYXRoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSk7XG4gICAgICBvID09PSBFdCA/IHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKSA6IG8gPT09IFkgJiYgdGhpcy5iYWNrKCksIG8gPT09IFogJiYgdGhpcy5mb3J3YXJkKCk7XG4gICAgfSksIGModGhpcywgXCJvbk5hdmlnYXRvckNoYW5nZVwiLCBhc3luYyAoe1xuICAgICAgdG86IG8sXG4gICAgICBmcm9tOiBhLFxuICAgICAgZGVsdGE6IGhcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkICYmIGF3YWl0IHRoaXMuc3luY0hpc3RvcnkoKSwgdGhpcy5lZS5lbWl0KFwiY2hhbmdlXCIsIHtcbiAgICAgICAgZGVsdGE6IGgsXG4gICAgICAgIGZyb206IEYoYSksXG4gICAgICAgIHRvOiBGKG8pLFxuICAgICAgICBuYXZpZ2F0b3I6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0pLCBjKHRoaXMsIFwib25cIiwgdGhpcy5lZS5vbi5iaW5kKHRoaXMuZWUpKSwgYyh0aGlzLCBcIm9mZlwiLCB0aGlzLmVlLm9mZi5iaW5kKHRoaXMuZWUpKSwgdGhpcy5uYXZpZ2F0b3IgPSBuZXcgSXMoXG4gICAgICB0Lm1hcCgobykgPT4gUShvLCBcIi9cIikpLFxuICAgICAgcyxcbiAgICAgIG5cbiAgICApLCB0aGlzLm5hdmlnYXRvci5vbihcImNoYW5nZVwiLCAobykgPT4ge1xuICAgICAgdGhpcy5vbk5hdmlnYXRvckNoYW5nZShvKTtcbiAgICB9KSwgdGhpcy5oYXNoTW9kZSA9IHIsIHRoaXMuYmFzZSA9IHRlKGkgfHwgXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGN1cnJlbnQgbmF2aWdhdG9yIHRvIHRoZSBicm93c2VyIGhpc3RvcnkgYWxsb3dpbmcgbmF2aWdhdG9yIHRvIG1hbmlwdWxhdGUgaXQuXG4gICAqL1xuICBhc3luYyBhdHRhY2goKSB7XG4gICAgdGhpcy5hdHRhY2hlZCB8fCAodGhpcy5hdHRhY2hlZCA9ICEwLCB0aGlzLm5hdmlnYXRvci5hdHRhY2goKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpLCBhd2FpdCB0aGlzLnN5bmNIaXN0b3J5KCkpO1xuICB9XG4gIC8qKlxuICAgKiBHb2VzIGJhY2sgaW4gaGlzdG9yeSBieSAxLlxuICAgKi9cbiAgYmFjaygpIHtcbiAgICB0aGlzLm5hdmlnYXRvci5iYWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaGVzIGN1cnJlbnQgbmF2aWdhdG9yIGZyb20gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmF0dGFjaGVkID0gITEsIHRoaXMubmF2aWdhdG9yLmRldGFjaCgpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdvZXMgZm9yd2FyZCBpbiBoaXN0b3J5LlxuICAgKi9cbiAgZm9yd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuZm9yd2FyZCgpO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IGhpc3RvcnkgY3Vyc29yLlxuICAgKi9cbiAgZ2V0IGluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5pbmRleDtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBoaXN0b3J5IGl0ZW0gaWRlbnRpZmllci5cbiAgICovXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuY3VycmVudC5pZDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBjdXJyZW50bHkgYWN0aXZlIGhpc3RvcnkgaXRlbSBpbmRleCBieSB0aGUgc3BlY2lmaWVkIGRlbHRhLiBUaGlzIG1ldGhvZCBkb2Vzbid0XG4gICAqIGNoYW5nZSBpbmRleCBpbiBjYXNlLCB0aGUgdXBkYXRlZCBpbmRleCBwb2ludHMgdG8gdGhlIG5vbi1leGlzdGluZyBoaXN0b3J5IGl0ZW0uIFRoaXMgYmVoYXZpb3JcbiAgICogaXMgcHJlc2VydmVkIHVudGlsIHRoZSBgZml0YCBhcmd1bWVudCBpcyBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSBkZWx0YSAtIGluZGV4IGRlbHRhLlxuICAgKiBAcGFyYW0gZml0IC0gY3V0cyB0aGUgZGVsdGEgYXJndW1lbnQgdG8gZml0IHRoZSBib3VuZHMgYFswLCBoaXN0b3J5Lmxlbmd0aCAtIDFdYC5cbiAgICovXG4gIGdvKHQsIHMpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuZ28odCwgcyk7XG4gIH1cbiAgLyoqXG4gICAqIEdvZXMgdG8gdGhlIHNwZWNpZmllZCBpbmRleC4gTWV0aG9kIGRvZXMgbm90aGluZyBpbiBjYXNlLCBwYXNzZWQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICpcbiAgICogSWYgXCJmaXRcIiBvcHRpb24gd2FzIHNwZWNpZmllZCBhbmQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcywgaXQgd2lsbCBiZSBjdXQgdG8gdGhlIG5lYXJlc3RcbiAgICogYm91bmQuXG4gICAqIEBwYXJhbSBpbmRleCAtIHRhcmdldCBpbmRleC5cbiAgICogQHBhcmFtIGZpdCAtIGN1dHMgdGhlIGluZGV4IGFyZ3VtZW50IHRvIGZpdCB0aGUgYm91bmRzIGBbMCwgaGlzdG9yeS5sZW5ndGggLSAxXWAuXG4gICAqL1xuICBnb1RvKHQsIHMpIHtcbiAgICB0aGlzLm5hdmlnYXRvci5nb1RvKHQsIHMpO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IGhpc3RvcnkgaXRlbSBoYXNoLlxuICAgKiBAc2VlIFVSTC5oYXNoXG4gICAqIEBleGFtcGxlXG4gICAqIFwiXCIsIFwiI215LWhhc2hcIlxuICAgKi9cbiAgZ2V0IGhhc2goKSB7XG4gICAgcmV0dXJuICh0aGlzLm5hdmlnYXRvci5jdXJyZW50LnBhcmFtcyB8fCB7fSkuaGFzaCB8fCBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIG5hdmlnYXRvciBoYXMgaXRlbXMgYmVmb3JlIHRoZSBjdXJyZW50IGl0ZW0uXG4gICAqL1xuICBnZXQgaGFzUHJldigpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuaGFzUHJldjtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBuYXZpZ2F0b3IgaGFzIGl0ZW1zIGFmdGVyIHRoZSBjdXJyZW50IGl0ZW0uXG4gICAqL1xuICBnZXQgaGFzTmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuaGFzTmV4dDtcbiAgfVxuICAvKipcbiAgICogTmF2aWdhdGlvbiBoaXN0b3J5LlxuICAgKi9cbiAgZ2V0IGhpc3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmhpc3RvcnkubWFwKEYpO1xuICB9XG4gIC8qKlxuICAgKiBQYXRoLCBpbmNsdWRpbmcgcGF0aG5hbWUsIHNlYXJjaCBhbmQgaGFzaC5cbiAgICogQGV4YW1wbGUgUGF0aG5hbWUgb25seS5cbiAgICogXCIvcGF0aG5hbWVcIlxuICAgKiBAZXhhbXBsZSBQYXRobmFtZSArIHNlYXJjaC5cbiAgICogXCIvcGF0aG5hbWU/c2VhcmNoXCJcbiAgICogQGV4YW1wbGUgUGF0aG5hbWUgKyBoYXNoLlxuICAgKiBcIi9wYXRobmFtZSNoYXNoXCJcbiAgICogQGV4YW1wbGUgUGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoLlxuICAgKiBcIi9wYXRobmFtZT9zZWFyY2gjaGFzaFwiXG4gICAqL1xuICBnZXQgcGF0aCgpIHtcbiAgICByZXR1cm4gVSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBwYXRobmFtZS4gQWx3YXlzIHN0YXJ0cyB3aXRoIHRoZSBzbGFzaC5cbiAgICogQHNlZSBVUkwucGF0aG5hbWVcbiAgICogQGV4YW1wbGVcbiAgICogXCIvXCIsIFwiL2FiY1wiXG4gICAqL1xuICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmN1cnJlbnQucGF0aG5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIERlcGVuZGluZyBvbiB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIHR5cGUsIHBhcnNlcyBpbmNvbWluZyBwYXRoIGFuZCByZXR1cm5zIGl0IHByZXNlbnRlZCBhc1xuICAgKiBhbiBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG1ldGhvZCBwYXJzZXMgdGhlIHBhc3NlZCBwYXRoIGFuZCByZXR1cm5zIG9iamVjdCwgZGVzY3JpYmluZ1xuICAgKiBob3cgdGhlIG5hdmlnYXRvciBcInNlZXNcIiBpdC5cbiAgICpcbiAgICogQGV4YW1wbGUgSGFzaCBtb2RlIGlzIG9taXR0ZWQuXG4gICAqIHBhcnNlUGF0aCgnL2FiYz9hPTEjaGFzaCcpO1xuICAgKiAvLyB7IHBhdGhuYW1lOiAnL2FiYycsIHNlYXJjaDogJz9hPTEnLCBoYXNoOiAnI2hhc2gnIH1cbiAgICogcGFyc2VQYXRoKCdodHRwOi8vZXhhbXBsZS5jb20vYWJjP2E9MSNoYXNoJyk7XG4gICAqIC8vIHsgcGF0aG5hbWU6ICcvYWJjJywgc2VhcmNoOiAnP2E9MScsIGhhc2g6ICcjaGFzaCcgfVxuICAgKlxuICAgKiBAZXhhbXBsZSBIYXNoIG1vZGUgaXMgZW5hYmxlZC5cbiAgICogcGFyc2VQYXRoKCcvYWJjP2E9MSN0bWE/aXM9Y29vbCN5ZWFoJyk7XG4gICAqIC8vIHsgcGF0aG5hbWU6ICcvdG1hJywgc2VhcmNoOiAnP2lzPWNvb2wnLCBoYXNoOiAnI3llYWgnIH1cbiAgICogcGFyc2VQYXRoKCdodHRwOi8vZXhhbXBsZS5jb20vYWJjP2E9MSN0bWE/aXM9Y29vbCN5ZWFoJyk7XG4gICAqIC8vIHsgcGF0aG5hbWU6ICcvdG1hJywgc2VhcmNoOiAnP2lzPWNvb2wnLCBoYXNoOiAnI3llYWgnIH1cbiAgICovXG4gIHBhcnNlUGF0aCh0KSB7XG4gICAgbGV0IHMgPSBNKHQpO1xuICAgIHJldHVybiB0aGlzLmhhc2hNb2RlICYmIChzID0gTShzLmhhc2guc2xpY2UoMSkpKSwge1xuICAgICAgcGF0aG5hbWU6IHMucGF0aG5hbWUsXG4gICAgICBzZWFyY2g6IHMuc2VhcmNoLFxuICAgICAgaGFzaDogcy5oYXNoXG4gICAgfTtcbiAgfVxuICBwdXNoKHQsIHMpIHtcbiAgICBjb25zdCBuID0gUSh0LCB0aGlzLnBhdGgpLCB7IHN0YXRlOiByID0gcyB9ID0gbi5wYXJhbXM7XG4gICAgdGhpcy5uYXZpZ2F0b3IucHVzaCh7IC4uLm4sIHBhcmFtczogeyAuLi5uLnBhcmFtcywgc3RhdGU6IHIgfSB9KTtcbiAgfVxuICByZXBsYWNlKHQsIHMpIHtcbiAgICBjb25zdCBuID0gUSh0LCB0aGlzLnBhdGgpLCB7IHN0YXRlOiByID0gcyB9ID0gbi5wYXJhbXM7XG4gICAgdGhpcy5uYXZpZ2F0b3IucmVwbGFjZSh7IC4uLm4sIHBhcmFtczogeyAuLi5uLnBhcmFtcywgc3RhdGU6IHIgfSB9KTtcbiAgfVxuICAvKipcbiAgICogQ29tYmluZXMgdGhlIG5hdmlnYXRvciBgYmFzZWAgcHJvcGVydHkgd2l0aCB0aGUgcGFzc2VkIHBhdGggZGF0YSBhcHBseWluZyB0aGUgbmF2aWdhdG9yXG4gICAqIG5hdmlnYXRpb24gbW9kZS5cbiAgICogQHBhcmFtIHZhbHVlIC0gcGF0aCBwcmVzZW50ZWQgYXMgc3RyaW5nIG9yIFVSTExpa2UuXG4gICAqL1xuICByZW5kZXJQYXRoKHQpIHtcbiAgICBjb25zdCBzID0gKHRoaXMuYmFzZS5sZW5ndGggPT09IDEgPyBcIlwiIDogdGhpcy5iYXNlKSArIEIoVSh0KSwgXCIvXCIpO1xuICAgIHJldHVybiB0aGlzLmhhc2hNb2RlID8gQihzLnNsaWNlKDEpLCB0aGlzLmhhc2hNb2RlID09PSBcImNsYXNzaWNcIiA/IFwiI1wiIDogXCIjL1wiKSA6IHM7XG4gIH1cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyBjdXJyZW50IG5hdmlnYXRvciBzdGF0ZSB3aXRoIGJyb3dzZXIgaGlzdG9yeS5cbiAgICovXG4gIGFzeW5jIHN5bmNIaXN0b3J5KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKTtcbiAgICBjb25zdCB7IHN0YXRlOiB0IH0gPSB0aGlzLCBzID0gdGhpcy5yZW5kZXJQYXRoKHRoaXMpO1xuICAgIGF3YWl0IGtzKCksIHRoaXMuaGFzUHJldiAmJiB0aGlzLmhhc05leHQgPyAod2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFksIFwiXCIpLCB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUodCwgXCJcIiwgcyksIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShaLCBcIlwiKSwgYXdhaXQgTigtMSkpIDogdGhpcy5oYXNQcmV2ID8gKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShZLCBcIlwiKSwgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHQsIFwiXCIsIHMpKSA6IHRoaXMuaGFzTmV4dCA/ICh3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUodCwgcyksIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShaLCBcIlwiKSwgYXdhaXQgTigtMSkpIDogKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShFdCwgXCJcIiksIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh0LCBcIlwiLCBzKSksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgKiBAc2VlIFVSTC5zZWFyY2hcbiAgICogQGV4YW1wbGVcbiAgICogXCJcIiwgXCI/XCIsIFwiP2E9MVwiXG4gICAqL1xuICBnZXQgc2VhcmNoKCkge1xuICAgIHJldHVybiAodGhpcy5uYXZpZ2F0b3IuY3VycmVudC5wYXJhbXMgfHwge30pLnNlYXJjaCB8fCBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IGhpc3RvcnkgaXRlbSBzdGF0ZS5cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gKHRoaXMubmF2aWdhdG9yLmN1cnJlbnQucGFyYW1zIHx8IHt9KS5zdGF0ZTtcbiAgfVxufVxuZnVuY3Rpb24gT3MoZSkge1xuICBlIHx8IChlID0ge30pO1xuICBjb25zdCB7IGhyZWY6IHQsIGhhc2g6IHMgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgbGV0IG4gPSBVKFxuICAgIGUuaGFzaE1vZGUgPT09IG51bGwgPyB0IDogcy5pbmNsdWRlcyhcIj9cIikgPyBzLnNsaWNlKDEpIDogYD8ke3Muc2xpY2UoMSl9YFxuICApO1xuICBjb25zdCByID0gZS5iYXNlID8gdGUoZS5iYXNlKSA6IHZvaWQgMDtcbiAgaWYgKHIpIHtcbiAgICBpZiAoIW4uc3RhcnRzV2l0aChyKSlcbiAgICAgIHRocm93IG0oXG4gICAgICAgIHllLFxuICAgICAgICBgUGF0aCBcIiR7bn1cIiBleHBlY3RlZCB0byBiZSBzdGFydGluZyB3aXRoIFwiJHtyfVwiYFxuICAgICAgKTtcbiAgICBuID0gbi5zbGljZShyLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBlZShbbl0sIDAsIGUpO1xufVxuZnVuY3Rpb24gQ24oZSkge1xuICBjb25zdCB0ID0gZS5tYXRjaCgvIyguKykvKTtcbiAgcmV0dXJuIHQgPyB0WzFdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHFzKGUsIHQpIHtcbiAgaWYgKEZ0KCkpIHtcbiAgICBjb25zdCBzID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShlKTtcbiAgICBpZiAocylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgaW5kZXg6IG4sIGhpc3Rvcnk6IHIgfSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgIHJldHVybiBuZXcgZWUoXG4gICAgICAgICAgcixcbiAgICAgICAgICBuLFxuICAgICAgICAgIHRcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byByZXN0b3JlIGhhc2ggbmF2aWdhdG9yIHN0YXRlLlwiLCBuKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gT3ModCk7XG59XG5mdW5jdGlvbiBTbihlLCB0KSB7XG4gIGNvbnN0IHMgPSBxcyhlLCB0KSwgbiA9ICgpID0+IHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oZSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgIGluZGV4OiBzLmluZGV4LFxuICAgIGhpc3Rvcnk6IHMuaGlzdG9yeVxuICB9KSk7XG4gIHJldHVybiBzLm9uKFwiY2hhbmdlXCIsIG4pLCBuKCksIHM7XG59XG5mdW5jdGlvbiBkKGUsIHQpIHtcbiAgZnVuY3Rpb24gcyhuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGksIG8sIGEpIHtcbiAgICAgIHJldHVybiAoaCkgPT4ge1xuICAgICAgICBjb25zdCBwID0ge1xuICAgICAgICAgIC4uLmgsXG4gICAgICAgICAgW2ldOiBuKG8pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUHQoYSwgeyAuLi5wIH0pO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBbcyhlKSwgcyh0KV07XG59XG5jb25zdCBzZSA9IG5lKHZvaWQgMCk7XG5mdW5jdGlvbiBOcygpIHtcbiAgY29uc3QgZSA9IHJlKHNlKTtcbiAgaWYgKCFlKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZVNESyB3YXMgdXNlZCBvdXRzaWRlIHRoZSBTREtQcm92aWRlci5cIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gXyhlKSB7XG4gIGZ1bmN0aW9uIHQobikge1xuICAgIGNvbnN0IHIgPSBOcygpLCBbaSwgb10gPSBydChcbiAgICAgIG4gPyB2b2lkIDAgOiAoKSA9PiB7XG4gICAgICAgIGlmIChUcygpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzaW5nIGhvb2tzIG9uIHRoZSBzZXJ2ZXIgc2lkZSwgeW91IG11c3QgZXhwbGljaXRseSBzcGVjaWZ5IHNzciA9IHRydWUgb3B0aW9uXCIpO1xuICAgICAgICByZXR1cm4gci51c2UoZSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gUigoKSA9PiB7XG4gICAgICBvKHIudXNlKGUpKTtcbiAgICB9LCBbcl0pLCBpO1xuICB9XG4gIGZ1bmN0aW9uIHMobikge1xuICAgIGNvbnN0IHIgPSB0KG4pO1xuICAgIGlmIChyKSB7XG4gICAgICBpZiAoXCJlcnJvclwiIGluIHIpXG4gICAgICAgIHRocm93IHIuZXJyb3I7XG4gICAgICByZXR1cm4gci5yZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBbdCwgc107XG59XG5jb25zdCBbRHMsIFZzXSA9IF8oamUpLCBbVG4sIEFuXSA9IGQoXG4gIERzLFxuICBWc1xuKSwgW0JzLCBNc10gPSBfKEplKSwgW0luLCBrbl0gPSBkKFxuICBCcyxcbiAgTXNcbiksIFtMcywgJHNdID0gXyhRZSksIFtPbiwgcW5dID0gZChcbiAgTHMsXG4gICRzXG4pLCBbSHMsIFVzXSA9IF8oZXMpLCBbTm4sIERuXSA9IGQoXG4gIEhzLFxuICBVc1xuKSwgW1dzLCBHc10gPSBfKG5zKSwgW1ZuLCBCbl0gPSBkKFxuICBXcyxcbiAgR3NcbiksIFtqcywgenNdID0gXyhpcyksIFtNbiwgTG5dID0gZChqcywgenMpLCBbS3MsIEpzXSA9IF8oYXMpLCBbJG4sIEhuXSA9IGQoS3MsIEpzKSwgW0ZzLCBRc10gPSBfKGhzKSwgW1VuLCBXbl0gPSBkKEZzLCBRcyksIFtZcywgWnNdID0gXyhkcyksIFtHbiwgam5dID0gZChZcywgWnMpLCBbWHMsIHRuXSA9IF8od3MpLCBbem4sIEtuXSA9IGQoWHMsIHRuKSwgW2VuLCBzbl0gPSBfKG1zKSwgW0puLCBGbl0gPSBkKGVuLCBzbiksIFtubiwgcm5dID0gXyh2cyksIFtRbiwgWW5dID0gZChcbiAgbm4sXG4gIHJuXG4pLCBbb24sIGFuXSA9IF8oRXMpLCBbWm4sIFhuXSA9IGQob24sIGFuKTtcbmZ1bmN0aW9uIHRyKGUpIHtcbiAgY29uc3QgW3QsIHNdID0gcnQoKCkgPT4gZSA/IHZvaWQgMCA6IG50KCkpO1xuICByZXR1cm4gUigoKSA9PiB7XG4gICAgZSAmJiBzKG50KCkpO1xuICB9LCBbXSksIHQ7XG59XG5jb25zdCBbY24sIGhuXSA9IF8oUnMpLCBbZXIsIHNyXSA9IGQoY24sIGhuKSwgW3BuLCB1bl0gPSBfKENzKSwgW25yLCBycl0gPSBkKHBuLCB1bik7XG5mdW5jdGlvbiBpcih7IGNoaWxkcmVuOiBlLCBhY2NlcHRDdXN0b21TdHlsZXM6IHQsIGRlYnVnOiBzIH0pIHtcbiAgY29uc3QgbiA9IG10KCEwKSwgW3IsIGldID0gcnQoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIG8gPSBtdChyKSwgYSA9IGllKFxuICAgIChwKSA9PiB7XG4gICAgICBuLmN1cnJlbnQgJiYgaSgoUykgPT4gKHAgJiYgcChTKSwgbmV3IE1hcChTKSkpO1xuICAgIH0sXG4gICAgW11cbiAgKSwgaCA9IG9lKCgpID0+ICh7XG4gICAgdXNlKHAsIC4uLlMpIHtcbiAgICAgIGNvbnN0IGd0ID0gci5nZXQocCk7XG4gICAgICBpZiAoZ3QpXG4gICAgICAgIHJldHVybiBndDtcbiAgICAgIGxldCBiLCBLO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYiA9IHAoLi4uUyk7XG4gICAgICB9IGNhdGNoICh3KSB7XG4gICAgICAgIEsgPSB3O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gSCh3KSB7XG4gICAgICAgIHJldHVybiByLnNldChwLCB3KSwgdztcbiAgICAgIH1cbiAgICAgIGlmIChLKVxuICAgICAgICByZXR1cm4gSCh7IGVycm9yOiBLIH0pO1xuICAgICAgbGV0IEk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSAmJiAoSSA9IGJbMV0sIGIgPSBiWzBdKSwgIWIpXG4gICAgICAgIHJldHVybiBIKHsgcmVzdWx0OiBiLCBjbGVhbnVwOiBJIH0pO1xuICAgICAgZnVuY3Rpb24gd3Qodykge1xuICAgICAgICBpZiAoXCJvblwiIGluIHcpIHtcbiAgICAgICAgICBjb25zdCBrID0gdy5vbihcImNoYW5nZVwiLCAoKSA9PiBhKCkpLCBmdCA9IEk7XG4gICAgICAgICAgSSA9ICgpID0+IHtcbiAgICAgICAgICAgIGZ0ICYmIGZ0KCksIGsoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdywgY2xlYW51cDogSSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGIgaW5zdGFuY2VvZiBQcm9taXNlID8gKGIudGhlbihcbiAgICAgICAgKHcpID0+IGEoKGspID0+IGsuc2V0KHAsIHd0KHcpKSksXG4gICAgICAgICh3KSA9PiBhKChrKSA9PiBrLnNldChwLCB7IGVycm9yOiB3IH0pKVxuICAgICAgKSwgSCh7fSkpIDogSCh3dChiKSk7XG4gICAgfVxuICB9KSwgW3JdKTtcbiAgcmV0dXJuIFIoKCkgPT4gKG4uY3VycmVudCA9ICEwLCAoKSA9PiB7XG4gICAgbi5jdXJyZW50ID0gITE7XG4gIH0pLCBbXSksIFIoKCkgPT4ge1xuICAgIGlmIChhdCgpKVxuICAgICAgcmV0dXJuIFNzKHQpO1xuICB9LCBbdF0pLCBSKCgpID0+IHtcbiAgICB1ZShzIHx8ICExKTtcbiAgfSwgW3NdKSwgUigoKSA9PiB7XG4gICAgby5jdXJyZW50ID0gcjtcbiAgfSwgW3JdKSwgUigoKSA9PiAoKSA9PiB7XG4gICAgby5jdXJyZW50LmZvckVhY2goKHApID0+IHtcbiAgICAgIFwiY2xlYW51cFwiIGluIHAgJiYgcC5jbGVhbnVwICYmIHAuY2xlYW51cCgpO1xuICAgIH0pO1xuICB9LCBbXSksIC8qIEBfX1BVUkVfXyAqLyBQdChzZS5Qcm92aWRlciwgeyB2YWx1ZTogaCwgY2hpbGRyZW46IGUgfSk7XG59XG5leHBvcnQge1xuICBOZSBhcyBCYWNrQnV0dG9uLFxuICBJcyBhcyBCYXNpY05hdmlnYXRvcixcbiAgemUgYXMgQmlvbWV0cnlNYW5hZ2VyLFxuICBlZSBhcyBCcm93c2VyTmF2aWdhdG9yLFxuICBGZSBhcyBDbG9zaW5nQmVoYXZpb3IsXG4gIHRzIGFzIENsb3VkU3RvcmFnZSxcbiAgeWUgYXMgRVJSX0lOVkFMSURfUEFUSF9CQVNFLFxuICB3ZSBhcyBFUlJfSU5WT0tFX0NVU1RPTV9NRVRIT0RfUkVTUE9OU0UsXG4gIF9lIGFzIEVSUl9NRVRIT0RfUEFSQU1FVEVSX1VOU1VQUE9SVEVELFxuICBkZSBhcyBFUlJfTUVUSE9EX1VOU1VQUE9SVEVELFxuICBiZSBhcyBFUlJfTkFWSUdBVElPTl9ISVNUT1JZX0VNUFRZLFxuICB2ZSBhcyBFUlJfTkFWSUdBVElPTl9JTkRFWF9JTlZBTElELFxuICBfbiBhcyBFUlJfTkFWSUdBVElPTl9JVEVNX0lOVkFMSUQsXG4gIEN0IGFzIEVSUl9QQVJTRSxcbiAgZ24gYXMgRVJSX1NTUl9JTklULFxuICBmZSBhcyBFUlJfVElNRURfT1VULFxuICBtZSBhcyBFUlJfVU5FWFBFQ1RFRF9UWVBFLFxuICBnZSBhcyBFUlJfVU5LTk9XTl9FTlYsXG4gIEQgYXMgRXZlbnRFbWl0dGVyLFxuICBzcyBhcyBIYXB0aWNGZWVkYmFjayxcbiAgcnMgYXMgSW5pdERhdGEsXG4gIG9zIGFzIEludm9pY2UsXG4gIGNzIGFzIE1haW5CdXR0b24sXG4gIGxzIGFzIE1pbmlBcHAsXG4gIGdzIGFzIFBvcHVwLFxuICBmcyBhcyBRUlNjYW5uZXIsXG4gIFcgYXMgU0RLRXJyb3IsXG4gIGlyIGFzIFNES1Byb3ZpZGVyLFxuICBicyBhcyBTZXR0aW5nc0J1dHRvbixcbiAgeXMgYXMgVGhlbWVQYXJhbXMsXG4gIFBzIGFzIFV0aWxzLFxuICB4cyBhcyBWaWV3cG9ydCxcbiAgWGUgYXMgYXJyYXksXG4gIHZuIGFzIGJpbmRNaW5pQXBwQ1NTVmFycyxcbiAgeW4gYXMgYmluZFRoZW1lUGFyYW1zQ1NTVmFycyxcbiAgRW4gYXMgYmluZFZpZXdwb3J0Q1NTVmFycyxcbiAgRSBhcyBib29sZWFuLFxuICBxdCBhcyBjYXB0dXJlU2FtZVJlcSxcbiAgc3QgYXMgY2xhc3NOYW1lcyxcbiAgVGUgYXMgY29tcGFyZVZlcnNpb25zLFxuICBPcyBhcyBjcmVhdGVCcm93c2VyTmF2aWdhdG9yRnJvbUxvY2F0aW9uLFxuICBrZSBhcyBjcmVhdGVQb3N0RXZlbnQsXG4gIE0gYXMgY3JlYXRlU2FmZVVSTCxcbiAgTHQgYXMgZGF0ZSxcbiAgQ24gYXMgZ2V0SGFzaCxcbiAgdGUgYXMgZ2V0UGF0aG5hbWUsXG4gIGplIGFzIGluaXRCYWNrQnV0dG9uLFxuICBKZSBhcyBpbml0QmlvbWV0cnlNYW5hZ2VyLFxuICBRZSBhcyBpbml0Q2xvc2luZ0JlaGF2aW9yLFxuICBlcyBhcyBpbml0Q2xvdWRTdG9yYWdlLFxuICBucyBhcyBpbml0SGFwdGljRmVlZGJhY2ssXG4gIGlzIGFzIGluaXRJbml0RGF0YSxcbiAgYXMgYXMgaW5pdEludm9pY2UsXG4gIGhzIGFzIGluaXRNYWluQnV0dG9uLFxuICBkcyBhcyBpbml0TWluaUFwcCxcbiAgU24gYXMgaW5pdE5hdmlnYXRvcixcbiAgd3MgYXMgaW5pdFBvcHVwLFxuICBtcyBhcyBpbml0UVJTY2FubmVyLFxuICB2cyBhcyBpbml0U2V0dGluZ3NCdXR0b24sXG4gIEVzIGFzIGluaXRUaGVtZVBhcmFtcyxcbiAgUnMgYXMgaW5pdFV0aWxzLFxuICBDcyBhcyBpbml0Vmlld3BvcnQsXG4gIFNzIGFzIGluaXRXZWIsXG4gIHEgYXMgaW52b2tlQ3VzdG9tTWV0aG9kLFxuICBCdCBhcyBpc0NvbG9yRGFyayxcbiAgYXQgYXMgaXNJZnJhbWUsXG4gIEZ0IGFzIGlzUGFnZVJlbG9hZCxcbiAgY3QgYXMgaXNSR0IsXG4gIE9lIGFzIGlzUkdCU2hvcnQsXG4gIEFzIGFzIGlzU0RLRXJyb3IsXG4gIHhuIGFzIGlzU0RLRXJyb3JPZlR5cGUsXG4gIFRzIGFzIGlzU1NSLFxuICBQbiBhcyBpc1RNQSxcbiAgdiBhcyBqc29uLFxuICBmbiBhcyBtZXJnZUNsYXNzTmFtZXMsXG4gIFJuIGFzIG1vY2tUZWxlZ3JhbUVudixcbiAgeCBhcyBudW1iZXIsXG4gIHogYXMgb2ZmLFxuICB5IGFzIG9uLFxuICBtbiBhcyBwYXJzZUluaXREYXRhLFxuICBsdCBhcyBwYXJzZUxhdW5jaFBhcmFtcyxcbiAgWnQgYXMgcGFyc2VUaGVtZVBhcmFtcyxcbiAgViBhcyBwb3N0RXZlbnQsXG4gIGcgYXMgcmVxdWVzdCxcbiAgS2UgYXMgcmVxdWVzdEJpb21ldHJ5SW5mbyxcbiAgYm4gYXMgcmVxdWVzdFRoZW1lUGFyYW1zLFxuICBYdCBhcyByZXF1ZXN0Vmlld3BvcnQsXG4gIG50IGFzIHJldHJpZXZlTGF1bmNoUGFyYW1zLFxuICBWZSBhcyByZ2IsXG4gIHV0IGFzIHNlYXJjaFBhcmFtcyxcbiAgVWUgYXMgc2VyaWFsaXplTGF1bmNoUGFyYW1zLFxuICBLdCBhcyBzZXJpYWxpemVUaGVtZVBhcmFtcyxcbiAgUCBhcyBzZXRDU1NWYXIsXG4gIHVlIGFzIHNldERlYnVnLFxuICB3biBhcyBzZXRUYXJnZXRPcmlnaW4sXG4gIHUgYXMgc3RyaW5nLFxuICBoZSBhcyBzdWJzY3JpYmUsXG4gIEMgYXMgc3VwcG9ydHMsXG4gIEllIGFzIHRhcmdldE9yaWdpbixcbiAgVnQgYXMgdG9SR0IsXG4gIHh0IGFzIHVuc3Vic2NyaWJlLFxuICBVIGFzIHVybFRvUGF0aCxcbiAgVnMgYXMgdXNlQmFja0J1dHRvbixcbiAgRHMgYXMgdXNlQmFja0J1dHRvblJhdyxcbiAgTXMgYXMgdXNlQmlvbWV0cnlNYW5hZ2VyLFxuICBCcyBhcyB1c2VCaW9tZXRyeU1hbmFnZXJSYXcsXG4gICRzIGFzIHVzZUNsb3NpbmdCZWhhdmlvcixcbiAgTHMgYXMgdXNlQ2xvc2luZ0JlaGF2aW9yUmF3LFxuICBVcyBhcyB1c2VDbG91ZFN0b3JhZ2UsXG4gIEhzIGFzIHVzZUNsb3VkU3RvcmFnZVJhdyxcbiAgR3MgYXMgdXNlSGFwdGljRmVlZGJhY2ssXG4gIFdzIGFzIHVzZUhhcHRpY0ZlZWRiYWNrUmF3LFxuICB6cyBhcyB1c2VJbml0RGF0YSxcbiAganMgYXMgdXNlSW5pdERhdGFSYXcsXG4gIEpzIGFzIHVzZUludm9pY2UsXG4gIEtzIGFzIHVzZUludm9pY2VSYXcsXG4gIHRyIGFzIHVzZUxhdW5jaFBhcmFtcyxcbiAgUXMgYXMgdXNlTWFpbkJ1dHRvbixcbiAgRnMgYXMgdXNlTWFpbkJ1dHRvblJhdyxcbiAgWnMgYXMgdXNlTWluaUFwcCxcbiAgWXMgYXMgdXNlTWluaUFwcFJhdyxcbiAgdG4gYXMgdXNlUG9wdXAsXG4gIFhzIGFzIHVzZVBvcHVwUmF3LFxuICBzbiBhcyB1c2VRUlNjYW5uZXIsXG4gIGVuIGFzIHVzZVFSU2Nhbm5lclJhdyxcbiAgTnMgYXMgdXNlU0RLLFxuICBybiBhcyB1c2VTZXR0aW5nc0J1dHRvbixcbiAgbm4gYXMgdXNlU2V0dGluZ3NCdXR0b25SYXcsXG4gIGFuIGFzIHVzZVRoZW1lUGFyYW1zLFxuICBvbiBhcyB1c2VUaGVtZVBhcmFtc1JhdyxcbiAgaG4gYXMgdXNlVXRpbHMsXG4gIGNuIGFzIHVzZVV0aWxzUmF3LFxuICB1biBhcyB1c2VWaWV3cG9ydCxcbiAgcG4gYXMgdXNlVmlld3BvcnRSYXcsXG4gIEFuIGFzIHdpdGhCYWNrQnV0dG9uLFxuICBUbiBhcyB3aXRoQmFja0J1dHRvblJhdyxcbiAga24gYXMgd2l0aEJpb21ldHJ5TWFuYWdlcixcbiAgSW4gYXMgd2l0aEJpb21ldHJ5TWFuYWdlclJhdyxcbiAgcW4gYXMgd2l0aENsb3NpbmdCZWhhdmlvcixcbiAgT24gYXMgd2l0aENsb3NpbmdCZWhhdmlvclJhdyxcbiAgRG4gYXMgd2l0aENsb3VkU3RvcmFnZSxcbiAgTm4gYXMgd2l0aENsb3VkU3RvcmFnZVJhdyxcbiAgQm4gYXMgd2l0aEhhcHRpY0ZlZWRiYWNrLFxuICBWbiBhcyB3aXRoSGFwdGljRmVlZGJhY2tSYXcsXG4gIExuIGFzIHdpdGhJbml0RGF0YSxcbiAgTW4gYXMgd2l0aEluaXREYXRhUmF3LFxuICBIbiBhcyB3aXRoSW52b2ljZSxcbiAgJG4gYXMgd2l0aEludm9pY2VSYXcsXG4gIFduIGFzIHdpdGhNYWluQnV0dG9uLFxuICBVbiBhcyB3aXRoTWFpbkJ1dHRvblJhdyxcbiAgam4gYXMgd2l0aE1pbmlBcHAsXG4gIEduIGFzIHdpdGhNaW5pQXBwUmF3LFxuICBLbiBhcyB3aXRoUG9wdXAsXG4gIHpuIGFzIHdpdGhQb3B1cFJhdyxcbiAgRm4gYXMgd2l0aFFSU2Nhbm5lcixcbiAgSm4gYXMgd2l0aFFSU2Nhbm5lclJhdyxcbiAgWW4gYXMgd2l0aFNldHRpbmdzQnV0dG9uLFxuICBRbiBhcyB3aXRoU2V0dGluZ3NCdXR0b25SYXcsXG4gIFhuIGFzIHdpdGhUaGVtZVBhcmFtcyxcbiAgWm4gYXMgd2l0aFRoZW1lUGFyYW1zUmF3LFxuICBEdCBhcyB3aXRoVGltZW91dCxcbiAgc3IgYXMgd2l0aFV0aWxzLFxuICBlciBhcyB3aXRoVXRpbHNSYXcsXG4gIHJyIGFzIHdpdGhWaWV3cG9ydCxcbiAgbnIgYXMgd2l0aFZpZXdwb3J0UmF3XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tma.js/sdk-react/dist/index.js\n");

/***/ })

};
;